__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _reactNative = _$$_REQUIRE(_dependencyMap[1], "react-native");

  var _App = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./app/App"));

  var _package = _$$_REQUIRE(_dependencyMap[3], "./package");

  var _app = _$$_REQUIRE(_dependencyMap[4], "./app.json");

  var _AppDebug = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "./app/AppDebug"));

  console.ignoredYellowBox = ['Warning: BackAndroid is deprecated. Please use BackHandler instead.', 'source.uri should not be an empty string', 'Invalid props.style key'];
  console.disableYellowBox = true;

  _reactNative.AppRegistry.registerConfig([{
    appKey: 'HeadTurn1199',
    component: function component() {
      return _App.default;
    },
    intent: 'demonstrate_app&open',
    appId: _package.appid,
    priority: 1
  }]);

  _reactNative.AppRegistry.registerComponent(_app.name, function () {
    return _AppDebug.default;
  });
},"system_2d01160272669884793b18983a46dcd0_index.js",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","system_2d01160272669884793b18983a46dcd0_app_App.js","system_2d01160272669884793b18983a46dcd0_package.json","system_2d01160272669884793b18983a46dcd0_app.json","system_2d01160272669884793b18983a46dcd0_app_AppDebug.js"],"index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.8.3
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      var _assign = _$$_REQUIRE(_dependencyMap[0], "object-assign");

      var checkPropTypes = _$$_REQUIRE(_dependencyMap[1], "prop-types/checkPropTypes");

      var ReactVersion = '16.8.3';
      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = '@@iterator';

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === 'function') {
          return maybeIterator;
        }

        return null;
      }

      var validateFormat = function validateFormat() {};

      {
        validateFormat = function validateFormat(format) {
          if (format === undefined) {
            throw new Error('invariant requires an error message argument');
          }
        };
      }

      function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);

        if (!condition) {
          var error = void 0;

          if (format === undefined) {
            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function () {
              return args[argIndex++];
            }));
            error.name = 'Invariant Violation';
          }

          error.framesToPop = 1;
          throw error;
        }
      }

      var lowPriorityWarning = function lowPriorityWarning() {};

      {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function () {
            return args[argIndex++];
          });

          if (typeof console !== 'undefined') {
            console.warn(message);
          }

          try {
            throw new Error(message);
          } catch (x) {}
        };

        lowPriorityWarning = function lowPriorityWarning(condition, format) {
          if (format === undefined) {
            throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
          }

          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
          }
        };
      }
      var lowPriorityWarning$1 = lowPriorityWarning;

      var warningWithoutStack = function warningWithoutStack() {};

      {
        warningWithoutStack = function warningWithoutStack(condition, format) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          if (format === undefined) {
            throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
          }

          if (args.length > 8) {
            throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
          }

          if (condition) {
            return;
          }

          if (typeof console !== 'undefined') {
            var argsWithFormat = args.map(function (item) {
              return '' + item;
            });
            argsWithFormat.unshift('Warning: ' + format);
            Function.prototype.apply.call(console.error, console, argsWithFormat);
          }

          try {
            var argIndex = 0;
            var message = 'Warning: ' + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            throw new Error(message);
          } catch (x) {}
        };
      }
      var warningWithoutStack$1 = warningWithoutStack;
      var didWarnStateUpdateForUnmountedComponent = {};

      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
          var warningKey = componentName + '.' + callerName;

          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }

          warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }

      var ReactNoopUpdateQueue = {
        isMounted: function isMounted(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
          warnNoop(publicInstance, 'forceUpdate');
        },
        enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, 'replaceState');
        },
        enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, 'setState');
        }
      };
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }

      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      Component.prototype.isReactComponent = {};

      Component.prototype.setState = function (partialState, callback) {
        !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
        this.updater.enqueueSetState(this, partialState, callback, 'setState');
      };

      Component.prototype.forceUpdate = function (callback) {
        this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
      };

      {
        var deprecatedAPIs = {
          isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
          replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
        };

        var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function get() {
              lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
              return undefined;
            }
          });
        };

        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }

      function ComponentDummy() {}

      ComponentDummy.prototype = Component.prototype;

      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;

      _assign(pureComponentPrototype, Component.prototype);

      pureComponentPrototype.isPureReactComponent = true;

      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }

      var ReactCurrentDispatcher = {
        current: null
      };
      var ReactCurrentOwner = {
        current: null
      };
      var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        var sourceInfo = '';

        if (source) {
          var path = source.fileName;
          var fileName = path.replace(BEFORE_SLASH_RE, '');
          {
            if (/^index\./.test(fileName)) {
              var match = path.match(BEFORE_SLASH_RE);

              if (match) {
                var pathBeforeSlash = match[1];

                if (pathBeforeSlash) {
                  var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
                  fileName = folderName + '/' + fileName;
                }
              }
            }
          }
          sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
        } else if (ownerName) {
          sourceInfo = ' (created by ' + ownerName + ')';
        }

        return '\n    in ' + (name || 'Unknown') + sourceInfo;
      };

      var Resolved = 1;

      function refineResolvedLazyComponent(lazyComponent) {
        return lazyComponent._status === Resolved ? lazyComponent._result : null;
      }

      function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName);
      }

      function getComponentName(type) {
        if (type == null) {
          return null;
        }

        {
          if (typeof type.tag === 'number') {
            warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
          }
        }

        if (typeof type === 'function') {
          return type.displayName || type.name || null;
        }

        if (typeof type === 'string') {
          return type;
        }

        switch (type) {
          case REACT_CONCURRENT_MODE_TYPE:
            return 'ConcurrentMode';

          case REACT_FRAGMENT_TYPE:
            return 'Fragment';

          case REACT_PORTAL_TYPE:
            return 'Portal';

          case REACT_PROFILER_TYPE:
            return 'Profiler';

          case REACT_STRICT_MODE_TYPE:
            return 'StrictMode';

          case REACT_SUSPENSE_TYPE:
            return 'Suspense';
        }

        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return 'Context.Consumer';

            case REACT_PROVIDER_TYPE:
              return 'Context.Provider';

            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, 'ForwardRef');

            case REACT_MEMO_TYPE:
              return getComponentName(type.type);

            case REACT_LAZY_TYPE:
              {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);

                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
              }
          }
        }

        return null;
      }

      var ReactDebugCurrentFrame = {};
      var currentlyValidatingElement = null;

      function setCurrentlyValidatingElement(element) {
        {
          currentlyValidatingElement = element;
        }
      }

      {
        ReactDebugCurrentFrame.getCurrentStack = null;

        ReactDebugCurrentFrame.getStackAddendum = function () {
          var stack = '';

          if (currentlyValidatingElement) {
            var name = getComponentName(currentlyValidatingElement.type);
            var owner = currentlyValidatingElement._owner;
            stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
          }

          var impl = ReactDebugCurrentFrame.getCurrentStack;

          if (impl) {
            stack += impl() || '';
          }

          return stack;
        };
      }
      var ReactSharedInternals = {
        ReactCurrentDispatcher: ReactCurrentDispatcher,
        ReactCurrentOwner: ReactCurrentOwner,
        assign: _assign
      };
      {
        _assign(ReactSharedInternals, {
          ReactDebugCurrentFrame: ReactDebugCurrentFrame,
          ReactComponentTreeHook: {}
        });
      }
      var warning = warningWithoutStack$1;
      {
        warning = function warning(condition, format) {
          if (condition) {
            return;
          }

          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();

          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
        };
      }
      var warning$1 = warning;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown = void 0;
      var specialPropRefWarningShown = void 0;

      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }

      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }

      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function warnAboutAccessingKey() {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
          }
        };

        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }

      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function warnAboutAccessingRef() {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
          }
        };

        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }

      var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type,
          key: key,
          ref: ref,
          props: props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });

          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };

      function createElement(type, config, children) {
        var propName = void 0;
        var props = {};
        var key = null;
        var ref = null;
        var self = null;
        var source = null;

        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
          }

          if (hasValidKey(config)) {
            key = '' + config.key;
          }

          self = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;

          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        }

        var childrenLength = arguments.length - 2;

        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);

          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }

          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }

        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;

          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }

        {
          if (key || ref) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }

            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }

      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }

      function cloneElement(element, config, children) {
        !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;
        var propName = void 0;

        var props = _assign({}, element.props);

        var key = element.key;
        var ref = element.ref;
        var self = element._self;
        var source = element._source;
        var owner = element._owner;

        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }

          if (hasValidKey(config)) {
            key = '' + config.key;
          }

          var defaultProps = void 0;

          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }

          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        }

        var childrenLength = arguments.length - 2;

        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);

          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }

          props.children = childArray;
        }

        return ReactElement(element.type, key, ref, self, source, owner, props);
      }

      function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      var SEPARATOR = '.';
      var SUBSEPARATOR = ':';

      function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          '=': '=0',
          ':': '=2'
        };
        var escapedString = ('' + key).replace(escapeRegex, function (match) {
          return escaperLookup[match];
        });
        return '$' + escapedString;
      }

      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;

      function escapeUserProvidedKey(text) {
        return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
      }

      var POOL_SIZE = 10;
      var traverseContextPool = [];

      function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
        if (traverseContextPool.length) {
          var traverseContext = traverseContextPool.pop();
          traverseContext.result = mapResult;
          traverseContext.keyPrefix = keyPrefix;
          traverseContext.func = mapFunction;
          traverseContext.context = mapContext;
          traverseContext.count = 0;
          return traverseContext;
        } else {
          return {
            result: mapResult,
            keyPrefix: keyPrefix,
            func: mapFunction,
            context: mapContext,
            count: 0
          };
        }
      }

      function releaseTraverseContext(traverseContext) {
        traverseContext.result = null;
        traverseContext.keyPrefix = null;
        traverseContext.func = null;
        traverseContext.context = null;
        traverseContext.count = 0;

        if (traverseContextPool.length < POOL_SIZE) {
          traverseContextPool.push(traverseContext);
        }
      }

      function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
        var type = typeof children;

        if (type === 'undefined' || type === 'boolean') {
          children = null;
        }

        var invokeCallback = false;

        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case 'string':
            case 'number':
              invokeCallback = true;
              break;

            case 'object':
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }

          }
        }

        if (invokeCallback) {
          callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
          return 1;
        }

        var child = void 0;
        var nextName = void 0;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getComponentKey(child, i);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else {
          var iteratorFn = getIteratorFn(children);

          if (typeof iteratorFn === 'function') {
            {
              if (iteratorFn === children.entries) {
                !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(children);
            var step = void 0;
            var ii = 0;

            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else if (type === 'object') {
            var addendum = '';
            {
              addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
            }
            var childrenString = '' + children;
            invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
          }
        }

        return subtreeCount;
      }

      function traverseAllChildren(children, callback, traverseContext) {
        if (children == null) {
          return 0;
        }

        return traverseAllChildrenImpl(children, '', callback, traverseContext);
      }

      function getComponentKey(component, index) {
        if (typeof component === 'object' && component !== null && component.key != null) {
          return escape(component.key);
        }

        return index.toString(36);
      }

      function forEachSingleChild(bookKeeping, child, name) {
        var func = bookKeeping.func,
            context = bookKeeping.context;
        func.call(context, child, bookKeeping.count++);
      }

      function forEachChildren(children, forEachFunc, forEachContext) {
        if (children == null) {
          return children;
        }

        var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
        traverseAllChildren(children, forEachSingleChild, traverseContext);
        releaseTraverseContext(traverseContext);
      }

      function mapSingleChildIntoContext(bookKeeping, child, childKey) {
        var result = bookKeeping.result,
            keyPrefix = bookKeeping.keyPrefix,
            func = bookKeeping.func,
            context = bookKeeping.context;
        var mappedChild = func.call(context, child, bookKeeping.count++);

        if (Array.isArray(mappedChild)) {
          mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
            return c;
          });
        } else if (mappedChild != null) {
          if (isValidElement(mappedChild)) {
            mappedChild = cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
          }

          result.push(mappedChild);
        }
      }

      function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
        var escapedPrefix = '';

        if (prefix != null) {
          escapedPrefix = escapeUserProvidedKey(prefix) + '/';
        }

        var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
        releaseTraverseContext(traverseContext);
      }

      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }

        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, func, context);
        return result;
      }

      function countChildren(children) {
        return traverseAllChildren(children, function () {
          return null;
        }, null);
      }

      function toArray(children) {
        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
          return child;
        });
        return result;
      }

      function onlyChild(children) {
        !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
        return children;
      }

      function createContext(defaultValue, calculateChangedBits) {
        if (calculateChangedBits === undefined) {
          calculateChangedBits = null;
        } else {
          {
            !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
          }
        }

        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _calculateChangedBits: calculateChangedBits,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context,
            _calculateChangedBits: context._calculateChangedBits
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function get() {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  warning$1(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                }

                return context.Provider;
              },
              set: function set(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function get() {
                return context._currentValue;
              },
              set: function set(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function get() {
                return context._currentValue2;
              },
              set: function set(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function get() {
                return context._threadCount;
              },
              set: function set(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function get() {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  warning$1(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                }

                return context.Consumer;
              }
            }
          });
          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }

      function lazy(ctor) {
        var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _ctor: ctor,
          _status: -1,
          _result: null
        };
        {
          var defaultProps = void 0;
          var propTypes = void 0;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: true,
              get: function get() {
                return defaultProps;
              },
              set: function set(newDefaultProps) {
                warning$1(false, 'React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                defaultProps = newDefaultProps;
                Object.defineProperty(lazyType, 'defaultProps', {
                  enumerable: true
                });
              }
            },
            propTypes: {
              configurable: true,
              get: function get() {
                return propTypes;
              },
              set: function set(newPropTypes) {
                warning$1(false, 'React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                propTypes = newPropTypes;
                Object.defineProperty(lazyType, 'propTypes', {
                  enumerable: true
                });
              }
            }
          });
        }
        return lazyType;
      }

      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            warningWithoutStack$1(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
          } else if (typeof render !== 'function') {
            warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
          } else {
            !(render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;
          }

          if (render != null) {
            !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
          }
        }
        return {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render: render
        };
      }

      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
      }

      function memo(type, compare) {
        {
          if (!isValidElementType(type)) {
            warningWithoutStack$1(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
          }
        }
        return {
          $$typeof: REACT_MEMO_TYPE,
          type: type,
          compare: compare === undefined ? null : compare
        };
      }

      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        !(dispatcher !== null) ? invariant(false, 'Hooks can only be called inside the body of a function component. (https://fb.me/react-invalid-hook-call)') : void 0;
        return dispatcher;
      }

      function useContext(Context, unstable_observedBits) {
        var dispatcher = resolveDispatcher();
        {
          !(unstable_observedBits === undefined) ? warning$1(false, 'useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '') : void 0;

          if (Context._context !== undefined) {
            var realContext = Context._context;

            if (realContext.Consumer === Context) {
              warning$1(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
            } else if (realContext.Provider === Context) {
              warning$1(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
            }
          }
        }
        return dispatcher.useContext(Context, unstable_observedBits);
      }

      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }

      function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
      }

      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }

      function useEffect(create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, inputs);
      }

      function useLayoutEffect(create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, inputs);
      }

      function useCallback(callback, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, inputs);
      }

      function useMemo(create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, inputs);
      }

      function useImperativeHandle(ref, create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, inputs);
      }

      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }

      var propTypesMisspellWarningShown = void 0;
      {
        propTypesMisspellWarningShown = false;
      }

      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentName(ReactCurrentOwner.current.type);

          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }

        return '';
      }

      function getSourceInfoErrorAddendum(elementProps) {
        if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
          var source = elementProps.__source;
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }

        return '';
      }

      var ownerHasKeyUseWarning = {};

      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();

        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

          if (parentName) {
            info = '\n\nCheck the top-level render call using <' + parentName + '>.';
          }
        }

        return info;
      }

      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }

        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = '';

        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';
        }

        setCurrentlyValidatingElement(element);
        {
          warning$1(false, 'Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
        }
        setCurrentlyValidatingElement(null);
      }

      function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') {
          return;
        }

        if (Array.isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];

            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);

          if (typeof iteratorFn === 'function') {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step = void 0;

              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }

      function validatePropTypes(element) {
        var type = element.type;

        if (type === null || type === undefined || typeof type === 'string') {
          return;
        }

        var name = getComponentName(type);
        var propTypes = void 0;

        if (typeof type === 'function') {
          propTypes = type.propTypes;
        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }

        if (propTypes) {
          setCurrentlyValidatingElement(element);
          checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
          setCurrentlyValidatingElement(null);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true;
          warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
        }

        if (typeof type.getDefaultProps === 'function') {
          !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
        }
      }

      function validateFragmentProps(fragment) {
        setCurrentlyValidatingElement(fragment);
        var keys = Object.keys(fragment.props);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (key !== 'children' && key !== 'key') {
            warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
            break;
          }
        }

        if (fragment.ref !== null) {
          warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
        }

        setCurrentlyValidatingElement(null);
      }

      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);

        if (!validType) {
          var info = '';

          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }

          var sourceInfo = getSourceInfoErrorAddendum(props);

          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }

          var typeString = void 0;

          if (type === null) {
            typeString = 'null';
          } else if (Array.isArray(type)) {
            typeString = 'array';
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';
            info = ' Did you accidentally export a JSX literal instead of a component?';
          } else {
            typeString = typeof type;
          }

          warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }

        var element = createElement.apply(this, arguments);

        if (element == null) {
          return element;
        }

        if (validType) {
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }

        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }

        return element;
      }

      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function get() {
              lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
              Object.defineProperty(this, 'type', {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }

      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);

        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }

        validatePropTypes(newElement);
        return newElement;
      }

      var enableStableConcurrentModeAPIs = false;
      var React = {
        Children: {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray,
          only: onlyChild
        },
        createRef: createRef,
        Component: Component,
        PureComponent: PureComponent,
        createContext: createContext,
        forwardRef: forwardRef,
        lazy: lazy,
        memo: memo,
        useCallback: useCallback,
        useContext: useContext,
        useEffect: useEffect,
        useImperativeHandle: useImperativeHandle,
        useDebugValue: useDebugValue,
        useLayoutEffect: useLayoutEffect,
        useMemo: useMemo,
        useReducer: useReducer,
        useRef: useRef,
        useState: useState,
        Fragment: REACT_FRAGMENT_TYPE,
        StrictMode: REACT_STRICT_MODE_TYPE,
        Suspense: REACT_SUSPENSE_TYPE,
        createElement: createElementWithValidation,
        cloneElement: cloneElementWithValidation,
        createFactory: createFactoryWithValidation,
        isValidElement: isValidElement,
        version: ReactVersion,
        unstable_ConcurrentMode: REACT_CONCURRENT_MODE_TYPE,
        unstable_Profiler: REACT_PROFILER_TYPE,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
      };

      if (enableStableConcurrentModeAPIs) {
        React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        React.Profiler = REACT_PROFILER_TYPE;
        React.unstable_ConcurrentMode = undefined;
        React.unstable_Profiler = undefined;
      }

      var React$2 = Object.freeze({
        default: React
      });
      var React$3 = React$2 && React || React$2;
      var react = React$3.default || React$3;
      module.exports = react;
    })();
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_react_cjs_react.development.js",["node_modules_object-assign_index.js","system_2d01160272669884793b18983a46dcd0_node_modules_prop-types_checkPropTypes.js"],"node_modules/react/cjs/react.development.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var printWarning = function printWarning() {};

  if (process.env.NODE_ENV !== 'production') {
    var ReactPropTypesSecret = _$$_REQUIRE(_dependencyMap[0], "./lib/ReactPropTypesSecret");

    var loggedTypeFailures = {};
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    printWarning = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        throw new Error(message);
      } catch (x) {}
    };
  }

  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if (process.env.NODE_ENV !== 'production') {
      for (var typeSpecName in typeSpecs) {
        if (has(typeSpecs, typeSpecName)) {
          var error;

          try {
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
              err.name = 'Invariant Violation';
              throw err;
            }

            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }

          if (error && !(error instanceof Error)) {
            printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
          }

          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
          }
        }
      }
    }
  }

  checkPropTypes.resetWarningCache = function () {
    if (process.env.NODE_ENV !== 'production') {
      loggedTypeFailures = {};
    }
  };

  module.exports = checkPropTypes;
},"system_2d01160272669884793b18983a46dcd0_node_modules_prop-types_checkPropTypes.js",["node_modules_prop-types_lib_ReactPropTypesSecret.js"],"node_modules/prop-types/checkPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }

      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;

          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;

              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;

                default:
                  var $$typeofType = type && type.$$typeof;

                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;

                    default:
                      return $$typeof;
                  }

              }

            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }

        return undefined;
      }

      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }

      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }

      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }

      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }

      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }

      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }

      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }

      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }

      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }

      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }

      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }

      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }

      exports.AsyncMode = AsyncMode;
      exports.ConcurrentMode = ConcurrentMode;
      exports.ContextConsumer = ContextConsumer;
      exports.ContextProvider = ContextProvider;
      exports.Element = Element;
      exports.ForwardRef = ForwardRef;
      exports.Fragment = Fragment;
      exports.Lazy = Lazy;
      exports.Memo = Memo;
      exports.Portal = Portal;
      exports.Profiler = Profiler;
      exports.StrictMode = StrictMode;
      exports.Suspense = Suspense;
      exports.isAsyncMode = isAsyncMode;
      exports.isConcurrentMode = isConcurrentMode;
      exports.isContextConsumer = isContextConsumer;
      exports.isContextProvider = isContextProvider;
      exports.isElement = isElement;
      exports.isForwardRef = isForwardRef;
      exports.isFragment = isFragment;
      exports.isLazy = isLazy;
      exports.isMemo = isMemo;
      exports.isPortal = isPortal;
      exports.isProfiler = isProfiler;
      exports.isStrictMode = isStrictMode;
      exports.isSuspense = isSuspense;
      exports.isValidElementType = isValidElementType;
      exports.typeOf = typeOf;
    })();
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-is_cjs_react-is.development.js",[],"node_modules/react-is/cjs/react-is.development.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactIs = _$$_REQUIRE(_dependencyMap[0], "react-is");

  var assign = _$$_REQUIRE(_dependencyMap[1], "object-assign");

  var ReactPropTypesSecret = _$$_REQUIRE(_dependencyMap[2], "./lib/ReactPropTypesSecret");

  var checkPropTypes = _$$_REQUIRE(_dependencyMap[3], "./checkPropTypes");

  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  var printWarning = function printWarning() {};

  if (process.env.NODE_ENV !== 'production') {
    printWarning = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  module.exports = function (isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    var ANONYMOUS = '<<anonymous>>';
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };

    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }

    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }

    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== 'production') {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }

      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
            err.name = 'Invariant Violation';
            throw err;
          } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
            var cacheKey = componentName + ':' + propName;

            if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
              printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }

        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }

            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }

          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }

        var propValue = props[propName];

        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }

        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);

          if (error instanceof Error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!ReactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        if (process.env.NODE_ENV !== 'production') {
          if (arguments.length > 1) {
            printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
          } else {
            printWarning('Invalid argument supplied to oneOf, expected an array.');
          }
        }

        return emptyFunctionThatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);

          if (type === 'symbol') {
            return String(value);
          }

          return value;
        });
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }

        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }

        for (var key in propValue) {
          if (has(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

            if (error instanceof Error) {
              return error;
            }
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];

        if (typeof checker !== 'function') {
          printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];

          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        for (var key in shapeTypes) {
          var checker = shapeTypes[key];

          if (!checker) {
            continue;
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        var allKeys = assign({}, props[propName], shapeTypes);

        for (var key in allKeys) {
          var checker = shapeTypes[key];

          if (!checker) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;

        case 'boolean':
          return !propValue;

        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }

          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);

          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;

            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;

                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;

        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      if (propType === 'symbol') {
        return true;
      }

      if (!propValue) {
        return false;
      }

      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    function getPropType(propValue) {
      var propType = typeof propValue;

      if (Array.isArray(propValue)) {
        return 'array';
      }

      if (propValue instanceof RegExp) {
        return 'object';
      }

      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }

      return propType;
    }

    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }

      var propType = getPropType(propValue);

      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }

      return propType;
    }

    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);

      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;

        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;

        default:
          return type;
      }
    }

    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }

      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
},"system_2d01160272669884793b18983a46dcd0_node_modules_prop-types_factoryWithTypeCheckers.js",["node_modules_react-is_index.js","node_modules_object-assign_index.js","node_modules_prop-types_lib_ReactPropTypesSecret.js","system_2d01160272669884793b18983a46dcd0_node_modules_prop-types_checkPropTypes.js"],"node_modules/prop-types/factoryWithTypeCheckers.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  if (__DEV__) {
    (function () {
      "use strict";

      _$$_REQUIRE(_dependencyMap[1], "InitializeCore");

      var ReactNativeViewConfigRegistry = _$$_REQUIRE(_dependencyMap[2], "ReactNativeViewConfigRegistry");

      var UIManager = _$$_REQUIRE(_dependencyMap[3], "UIManager");

      var RCTEventEmitter = _$$_REQUIRE(_dependencyMap[4], "RCTEventEmitter");

      var React = _$$_REQUIRE(_dependencyMap[5], "react");

      var deepFreezeAndThrowOnMutationInDev = _$$_REQUIRE(_dependencyMap[6], "deepFreezeAndThrowOnMutationInDev");

      var deepDiffer = _$$_REQUIRE(_dependencyMap[7], "deepDiffer");

      var flattenStyle = _$$_REQUIRE(_dependencyMap[8], "flattenStyle");

      var TextInputState = _$$_REQUIRE(_dependencyMap[9], "TextInputState");

      var checkPropTypes = _$$_REQUIRE(_dependencyMap[10], "prop-types/checkPropTypes");

      var tracing = _$$_REQUIRE(_dependencyMap[11], "scheduler/tracing");

      var scheduler = _$$_REQUIRE(_dependencyMap[12], "scheduler");

      var ExceptionsManager = _$$_REQUIRE(_dependencyMap[13], "ExceptionsManager");

      var validateFormat = function validateFormat() {};

      {
        validateFormat = function validateFormat(format) {
          if (format === undefined) {
            throw new Error("invariant requires an error message argument");
          }
        };
      }

      function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);

        if (!condition) {
          var error = void 0;

          if (format === undefined) {
            error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function () {
              return args[argIndex++];
            }));
            error.name = "Invariant Violation";
          }

          error.framesToPop = 1;
          throw error;
        }
      }

      var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);

        try {
          func.apply(context, funcArgs);
        } catch (error) {
          this.onError(error);
        }
      };

      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");

          var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            invariant(typeof document !== "undefined", "The `document` global was defined when React was initialized, but is not " + "defined anymore. This can happen in a test environment if a component " + "schedules an update from an asynchronous callback, but the test has already " + "finished running. To solve this, you can either unmount the component at " + "the end of your test (and ensure that any asynchronous operations get " + "canceled in `componentWillUnmount`), or you can change the test itself " + "to be asynchronous.");
            var evt = document.createEvent("Event");
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            var funcArgs = Array.prototype.slice.call(arguments, 3);

            function callCallback() {
              fakeNode.removeEventListener(evtType, callCallback, false);

              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }

              func.apply(context, funcArgs);
              didError = false;
            }

            var error = void 0;
            var didSetError = false;
            var isCrossOriginError = false;

            function handleWindowError(event) {
              error = event.error;
              didSetError = true;

              if (error === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }

              if (event.defaultPrevented) {
                if (error != null && typeof error === "object") {
                  try {
                    error._suppressLogging = true;
                  } catch (inner) {}
                }
              }
            }

            var evtType = "react-" + (name ? name : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);

            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }

            if (didError) {
              if (!didSetError) {
                error = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
              } else if (isCrossOriginError) {
                error = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://fb.me/react-crossorigin-error for more information.");
              }

              this.onError(error);
            }

            window.removeEventListener("error", handleWindowError);
          };

          invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function onError(error) {
          hasError = true;
          caughtError = error;
        }
      };

      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }

      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);

        if (hasError) {
          var error = clearCaughtError();

          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error;
          }
        }
      }

      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error;
        }
      }

      function hasCaughtError() {
        return hasError;
      }

      function clearCaughtError() {
        if (hasError) {
          var error = caughtError;
          hasError = false;
          caughtError = null;
          return error;
        } else {
          invariant(false, "clearCaughtError was called but no error was captured. This error " + "is likely caused by a bug in React. Please file an issue.");
        }
      }

      var eventPluginOrder = null;
      var namesToPlugins = {};

      function recomputePluginOrdering() {
        if (!eventPluginOrder) {
          return;
        }

        for (var pluginName in namesToPlugins) {
          var pluginModule = namesToPlugins[pluginName];
          var pluginIndex = eventPluginOrder.indexOf(pluginName);
          invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName);

          if (plugins[pluginIndex]) {
            continue;
          }

          invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName);
          plugins[pluginIndex] = pluginModule;
          var publishedEvents = pluginModule.eventTypes;

          for (var eventName in publishedEvents) {
            invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
          }
        }
      }

      function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
        invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName);
        eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

        if (phasedRegistrationNames) {
          for (var phaseName in phasedRegistrationNames) {
            if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
              var phasedRegistrationName = phasedRegistrationNames[phaseName];
              publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
            }
          }

          return true;
        } else if (dispatchConfig.registrationName) {
          publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
          return true;
        }

        return false;
      }

      function publishRegistrationName(registrationName, pluginModule, eventName) {
        invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName);
        registrationNameModules[registrationName] = pluginModule;
        registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
        }
      }

      var plugins = [];
      var eventNameDispatchConfigs = {};
      var registrationNameModules = {};
      var registrationNameDependencies = {};

      function injectEventPluginOrder(injectedEventPluginOrder) {
        invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.");
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      }

      function injectEventPluginsByName(injectedNamesToPlugins) {
        var isOrderingDirty = false;

        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }

          var pluginModule = injectedNamesToPlugins[pluginName];

          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
            invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName);
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }

        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      }

      var warningWithoutStack = function warningWithoutStack() {};

      {
        warningWithoutStack = function warningWithoutStack(condition, format) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          if (format === undefined) {
            throw new Error("`warningWithoutStack(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (args.length > 8) {
            throw new Error("warningWithoutStack() currently supports at most 8 arguments.");
          }

          if (condition) {
            return;
          }

          if (typeof console !== "undefined") {
            var argsWithFormat = args.map(function (item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console.error, console, argsWithFormat);
          }

          try {
            var argIndex = 0;
            var message = "Warning: " + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            throw new Error(message);
          } catch (x) {}
        };
      }
      var warningWithoutStack$1 = warningWithoutStack;
      var getFiberCurrentPropsFromNode = null;
      var getInstanceFromNode = null;
      var getNodeFromInstance = null;

      function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
        getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
        getInstanceFromNode = getInstanceFromNodeImpl;
        getNodeFromInstance = getNodeFromInstanceImpl;
        {
          !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, "EventPluginUtils.setComponentTree(...): Injected " + "module is missing getNodeFromInstance or getInstanceFromNode.") : void 0;
        }
      }

      var validateEventDispatches = void 0;
      {
        validateEventDispatches = function validateEventDispatches(event) {
          var dispatchListeners = event._dispatchListeners;
          var dispatchInstances = event._dispatchInstances;
          var listenersIsArr = Array.isArray(dispatchListeners);
          var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
          var instancesIsArr = Array.isArray(dispatchInstances);
          var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
          !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, "EventPluginUtils: Invalid `event`.") : void 0;
        };
      }

      function executeDispatch(event, listener, inst) {
        var type = event.type || "unknown-event";
        event.currentTarget = getNodeFromInstance(inst);
        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
      }

      function executeDispatchesInOrder(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
          }
        } else if (dispatchListeners) {
          executeDispatch(event, dispatchListeners, dispatchInstances);
        }

        event._dispatchListeners = null;
        event._dispatchInstances = null;
      }

      function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            if (dispatchListeners[i](event, dispatchInstances[i])) {
              return dispatchInstances[i];
            }
          }
        } else if (dispatchListeners) {
          if (dispatchListeners(event, dispatchInstances)) {
            return dispatchInstances;
          }
        }

        return null;
      }

      function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        event._dispatchInstances = null;
        event._dispatchListeners = null;
        return ret;
      }

      function executeDirectDispatch(event) {
        {
          validateEventDispatches(event);
        }
        var dispatchListener = event._dispatchListeners;
        var dispatchInstance = event._dispatchInstances;
        invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
        event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
        var res = dispatchListener ? dispatchListener(event) : null;
        event.currentTarget = null;
        event._dispatchListeners = null;
        event._dispatchInstances = null;
        return res;
      }

      function hasDispatches(event) {
        return !!event._dispatchListeners;
      }

      function accumulateInto(current, next) {
        invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          if (Array.isArray(next)) {
            current.push.apply(current, next);
            return current;
          }

          current.push(next);
          return current;
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      function forEachAccumulated(arr, cb, scope) {
        if (Array.isArray(arr)) {
          arr.forEach(cb, scope);
        } else if (arr) {
          cb.call(scope, arr);
        }
      }

      var eventQueue = null;

      var executeDispatchesAndRelease = function executeDispatchesAndRelease(event) {
        if (event) {
          executeDispatchesInOrder(event);

          if (!event.isPersistent()) {
            event.constructor.release(event);
          }
        }
      };

      var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
        return executeDispatchesAndRelease(e);
      };

      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }

      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
            return !!(props.disabled && isInteractive(type));

          default:
            return false;
        }
      }

      var injection = {
        injectEventPluginOrder: injectEventPluginOrder,
        injectEventPluginsByName: injectEventPluginsByName
      };

      function getListener(inst, registrationName) {
        var listener = void 0;
        var stateNode = inst.stateNode;

        if (!stateNode) {
          return null;
        }

        var props = getFiberCurrentPropsFromNode(stateNode);

        if (!props) {
          return null;
        }

        listener = props[registrationName];

        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }

        invariant(!listener || typeof listener === "function", "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
        return listener;
      }

      function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = null;

        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];

          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);

            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }

        return events;
      }

      function runEventsInBatch(events) {
        if (events !== null) {
          eventQueue = accumulateInto(eventQueue, events);
        }

        var processingEventQueue = eventQueue;
        eventQueue = null;

        if (!processingEventQueue) {
          return;
        }

        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.");
        rethrowCaughtError();
      }

      function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        runEventsInBatch(events);
      }

      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;
      var DehydratedSuspenseComponent = 18;

      function getParent(inst) {
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);

        if (inst) {
          return inst;
        }

        return null;
      }

      function getLowestCommonAncestor(instA, instB) {
        var depthA = 0;

        for (var tempA = instA; tempA; tempA = getParent(tempA)) {
          depthA++;
        }

        var depthB = 0;

        for (var tempB = instB; tempB; tempB = getParent(tempB)) {
          depthB++;
        }

        while (depthA - depthB > 0) {
          instA = getParent(instA);
          depthA--;
        }

        while (depthB - depthA > 0) {
          instB = getParent(instB);
          depthB--;
        }

        var depth = depthA;

        while (depth--) {
          if (instA === instB || instA === instB.alternate) {
            return instA;
          }

          instA = getParent(instA);
          instB = getParent(instB);
        }

        return null;
      }

      function isAncestor(instA, instB) {
        while (instB) {
          if (instA === instB || instA === instB.alternate) {
            return true;
          }

          instB = getParent(instB);
        }

        return false;
      }

      function getParentInstance(inst) {
        return getParent(inst);
      }

      function traverseTwoPhase(inst, fn, arg) {
        var path = [];

        while (inst) {
          path.push(inst);
          inst = getParent(inst);
        }

        var i = void 0;

        for (i = path.length; i-- > 0;) {
          fn(path[i], "captured", arg);
        }

        for (i = 0; i < path.length; i++) {
          fn(path[i], "bubbled", arg);
        }
      }

      function listenerAtPhase(inst, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(inst, registrationName);
      }

      function accumulateDirectionalDispatches(inst, phase, event) {
        {
          !inst ? warningWithoutStack$1(false, "Dispatching inst must not be null") : void 0;
        }
        var listener = listenerAtPhase(inst, event, phase);

        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }

      function accumulateTwoPhaseDispatchesSingle(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          var targetInst = event._targetInst;
          var parentInst = targetInst ? getParentInstance(targetInst) : null;
          traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateDispatches(inst, ignoredDirection, event) {
        if (inst && event && event.dispatchConfig.registrationName) {
          var registrationName = event.dispatchConfig.registrationName;
          var listener = getListener(inst, registrationName);

          if (listener) {
            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
          }
        }
      }

      function accumulateDirectDispatchesSingle(event) {
        if (event && event.dispatchConfig.registrationName) {
          accumulateDispatches(event._targetInst, null, event);
        }
      }

      function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
      }

      function accumulateTwoPhaseDispatchesSkipTarget(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
      }

      function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle);
      }

      var EVENT_POOL_SIZE = 10;
      var EventInterface = {
        type: null,
        target: null,
        currentTarget: function currentTarget() {
          return null;
        },
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function timeStamp(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: null,
        isTrusted: null
      };

      function functionThatReturnsTrue() {
        return true;
      }

      function functionThatReturnsFalse() {
        return false;
      }

      function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
        {
          delete this.nativeEvent;
          delete this.preventDefault;
          delete this.stopPropagation;
          delete this.isDefaultPrevented;
          delete this.isPropagationStopped;
        }
        this.dispatchConfig = dispatchConfig;
        this._targetInst = targetInst;
        this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;

        for (var propName in Interface) {
          if (!Interface.hasOwnProperty(propName)) {
            continue;
          }

          {
            delete this[propName];
          }
          var normalize = Interface[propName];

          if (normalize) {
            this[propName] = normalize(nativeEvent);
          } else {
            if (propName === "target") {
              this.target = nativeEventTarget;
            } else {
              this[propName] = nativeEvent[propName];
            }
          }
        }

        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

        if (defaultPrevented) {
          this.isDefaultPrevented = functionThatReturnsTrue;
        } else {
          this.isDefaultPrevented = functionThatReturnsFalse;
        }

        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }

      _extends(SyntheticEvent.prototype, {
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.preventDefault) {
            event.preventDefault();
          } else if (typeof event.returnValue !== "unknown") {
            event.returnValue = false;
          }

          this.isDefaultPrevented = functionThatReturnsTrue;
        },
        stopPropagation: function stopPropagation() {
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.stopPropagation) {
            event.stopPropagation();
          } else if (typeof event.cancelBubble !== "unknown") {
            event.cancelBubble = true;
          }

          this.isPropagationStopped = functionThatReturnsTrue;
        },
        persist: function persist() {
          this.isPersistent = functionThatReturnsTrue;
        },
        isPersistent: functionThatReturnsFalse,
        destructor: function destructor() {
          var Interface = this.constructor.Interface;

          for (var propName in Interface) {
            {
              Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
            }
          }

          this.dispatchConfig = null;
          this._targetInst = null;
          this.nativeEvent = null;
          this.isDefaultPrevented = functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          this._dispatchListeners = null;
          this._dispatchInstances = null;
          {
            Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
            Object.defineProperty(this, "isDefaultPrevented", getPooledWarningPropertyDefinition("isDefaultPrevented", functionThatReturnsFalse));
            Object.defineProperty(this, "isPropagationStopped", getPooledWarningPropertyDefinition("isPropagationStopped", functionThatReturnsFalse));
            Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", function () {}));
            Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", function () {}));
          }
        }
      });

      SyntheticEvent.Interface = EventInterface;

      SyntheticEvent.extend = function (Interface) {
        var Super = this;

        var E = function E() {};

        E.prototype = Super.prototype;
        var prototype = new E();

        function Class() {
          return Super.apply(this, arguments);
        }

        _extends(prototype, Class.prototype);

        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.Interface = _extends({}, Super.Interface, Interface);
        Class.extend = Super.extend;
        addEventPoolingTo(Class);
        return Class;
      };

      addEventPoolingTo(SyntheticEvent);

      function getPooledWarningPropertyDefinition(propName, getVal) {
        var isFunction = typeof getVal === "function";
        return {
          configurable: true,
          set: set,
          get: get$$1
        };

        function set(val) {
          var action = isFunction ? "setting the method" : "setting the property";
          warn(action, "This is effectively a no-op");
          return val;
        }

        function get$$1() {
          var action = isFunction ? "accessing the method" : "accessing the property";
          var result = isFunction ? "This is a no-op function" : "This is set to null";
          warn(action, result);
          return getVal;
        }

        function warn(action, result) {
          var warningCondition = false;
          !warningCondition ? warningWithoutStack$1(false, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + "If you must keep the original synthetic event around, use event.persist(). " + "See https://fb.me/react-event-pooling for more information.", action, propName, result) : void 0;
        }
      }

      function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
        var EventConstructor = this;

        if (EventConstructor.eventPool.length) {
          var instance = EventConstructor.eventPool.pop();
          EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
          return instance;
        }

        return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
      }

      function releasePooledEvent(event) {
        var EventConstructor = this;
        invariant(event instanceof EventConstructor, "Trying to release an event instance into a pool of a different type.");
        event.destructor();

        if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
          EventConstructor.eventPool.push(event);
        }
      }

      function addEventPoolingTo(EventConstructor) {
        EventConstructor.eventPool = [];
        EventConstructor.getPooled = getPooledEvent;
        EventConstructor.release = releasePooledEvent;
      }

      var ResponderSyntheticEvent = SyntheticEvent.extend({
        touchHistory: function touchHistory(nativeEvent) {
          return null;
        }
      });
      var TOP_TOUCH_START = "topTouchStart";
      var TOP_TOUCH_MOVE = "topTouchMove";
      var TOP_TOUCH_END = "topTouchEnd";
      var TOP_TOUCH_CANCEL = "topTouchCancel";
      var TOP_SCROLL = "topScroll";
      var TOP_SELECTION_CHANGE = "topSelectionChange";

      function isStartish(topLevelType) {
        return topLevelType === TOP_TOUCH_START;
      }

      function isMoveish(topLevelType) {
        return topLevelType === TOP_TOUCH_MOVE;
      }

      function isEndish(topLevelType) {
        return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;
      }

      var startDependencies = [TOP_TOUCH_START];
      var moveDependencies = [TOP_TOUCH_MOVE];
      var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];
      var MAX_TOUCH_BANK = 20;
      var touchBank = [];
      var touchHistory = {
        touchBank: touchBank,
        numberActiveTouches: 0,
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };

      function timestampForTouch(touch) {
        return touch.timeStamp || touch.timestamp;
      }

      function createTouchRecord(touch) {
        return {
          touchActive: true,
          startPageX: touch.pageX,
          startPageY: touch.pageY,
          startTimeStamp: timestampForTouch(touch),
          currentPageX: touch.pageX,
          currentPageY: touch.pageY,
          currentTimeStamp: timestampForTouch(touch),
          previousPageX: touch.pageX,
          previousPageY: touch.pageY,
          previousTimeStamp: timestampForTouch(touch)
        };
      }

      function resetTouchRecord(touchRecord, touch) {
        touchRecord.touchActive = true;
        touchRecord.startPageX = touch.pageX;
        touchRecord.startPageY = touch.pageY;
        touchRecord.startTimeStamp = timestampForTouch(touch);
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchRecord.previousPageX = touch.pageX;
        touchRecord.previousPageY = touch.pageY;
        touchRecord.previousTimeStamp = timestampForTouch(touch);
      }

      function getTouchIdentifier(_ref) {
        var identifier = _ref.identifier;
        invariant(identifier != null, "Touch object is missing identifier.");
        {
          !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, "Touch identifier %s is greater than maximum supported %s which causes " + "performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK) : void 0;
        }
        return identifier;
      }

      function recordTouchStart(touch) {
        var identifier = getTouchIdentifier(touch);
        var touchRecord = touchBank[identifier];

        if (touchRecord) {
          resetTouchRecord(touchRecord, touch);
        } else {
          touchBank[identifier] = createTouchRecord(touch);
        }

        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      }

      function recordTouchMove(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = true;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch move without a touch start.\n" + "Touch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function recordTouchEnd(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = false;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch end without a touch start.\n" + "Touch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function printTouch(touch) {
        return JSON.stringify({
          identifier: touch.identifier,
          pageX: touch.pageX,
          pageY: touch.pageY,
          timestamp: timestampForTouch(touch)
        });
      }

      function printTouchBank() {
        var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));

        if (touchBank.length > MAX_TOUCH_BANK) {
          printed += " (original size: " + touchBank.length + ")";
        }

        return printed;
      }

      var ResponderTouchHistoryStore = {
        recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
          if (isMoveish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchMove);
          } else if (isStartish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchStart);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
            }
          } else if (isEndish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchEnd);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              for (var i = 0; i < touchBank.length; i++) {
                var touchTrackToCheck = touchBank[i];

                if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
                  touchHistory.indexOfSingleActiveTouch = i;
                  break;
                }
              }

              {
                var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
                !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, "Cannot find single active touch.") : void 0;
              }
            }
          }
        },
        touchHistory: touchHistory
      };

      function accumulate(current, next) {
        invariant(next != null, "accumulate(...): Accumulated items must be not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          return current.concat(next);
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      var responderInst = null;
      var trackedTouchCount = 0;

      var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
        var oldResponderInst = responderInst;
        responderInst = nextResponderInst;

        if (ResponderEventPlugin.GlobalResponderHandler !== null) {
          ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
        }
      };

      var eventTypes$1 = {
        startShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onStartShouldSetResponder",
            captured: "onStartShouldSetResponderCapture"
          },
          dependencies: startDependencies
        },
        scrollShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onScrollShouldSetResponder",
            captured: "onScrollShouldSetResponderCapture"
          },
          dependencies: [TOP_SCROLL]
        },
        selectionChangeShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onSelectionChangeShouldSetResponder",
            captured: "onSelectionChangeShouldSetResponderCapture"
          },
          dependencies: [TOP_SELECTION_CHANGE]
        },
        moveShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onMoveShouldSetResponder",
            captured: "onMoveShouldSetResponderCapture"
          },
          dependencies: moveDependencies
        },
        responderStart: {
          registrationName: "onResponderStart",
          dependencies: startDependencies
        },
        responderMove: {
          registrationName: "onResponderMove",
          dependencies: moveDependencies
        },
        responderEnd: {
          registrationName: "onResponderEnd",
          dependencies: endDependencies
        },
        responderRelease: {
          registrationName: "onResponderRelease",
          dependencies: endDependencies
        },
        responderTerminationRequest: {
          registrationName: "onResponderTerminationRequest",
          dependencies: []
        },
        responderGrant: {
          registrationName: "onResponderGrant",
          dependencies: []
        },
        responderReject: {
          registrationName: "onResponderReject",
          dependencies: []
        },
        responderTerminate: {
          registrationName: "onResponderTerminate",
          dependencies: []
        }
      };

      function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;
        var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);
        var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
        var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
        shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

        if (skipOverBubbleShouldSetFrom) {
          accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
        } else {
          accumulateTwoPhaseDispatches(shouldSetEvent);
        }

        var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);

        if (!shouldSetEvent.isPersistent()) {
          shouldSetEvent.constructor.release(shouldSetEvent);
        }

        if (!wantsResponderInst || wantsResponderInst === responderInst) {
          return null;
        }

        var extracted = void 0;
        var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);
        grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
        accumulateDirectDispatches(grantEvent);
        var blockHostResponder = executeDirectDispatch(grantEvent) === true;

        if (responderInst) {
          var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);
          terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(terminationRequestEvent);
          var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);

          if (!terminationRequestEvent.isPersistent()) {
            terminationRequestEvent.constructor.release(terminationRequestEvent);
          }

          if (shouldSwitch) {
            var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
            terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(terminateEvent);
            extracted = accumulate(extracted, [grantEvent, terminateEvent]);
            changeResponder(wantsResponderInst, blockHostResponder);
          } else {
            var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);
            rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(rejectEvent);
            extracted = accumulate(extracted, rejectEvent);
          }
        } else {
          extracted = accumulate(extracted, grantEvent);
          changeResponder(wantsResponderInst, blockHostResponder);
        }

        return extracted;
      }

      function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
        return topLevelInst && (topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));
      }

      function noResponderTouches(nativeEvent) {
        var touches = nativeEvent.touches;

        if (!touches || touches.length === 0) {
          return true;
        }

        for (var i = 0; i < touches.length; i++) {
          var activeTouch = touches[i];
          var target = activeTouch.target;

          if (target !== null && target !== undefined && target !== 0) {
            var targetInst = getInstanceFromNode(target);

            if (isAncestor(responderInst, targetInst)) {
              return false;
            }
          }
        }

        return true;
      }

      var ResponderEventPlugin = {
        _getResponder: function _getResponder() {
          return responderInst;
        },
        eventTypes: eventTypes$1,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (isStartish(topLevelType)) {
            trackedTouchCount += 1;
          } else if (isEndish(topLevelType)) {
            if (trackedTouchCount >= 0) {
              trackedTouchCount -= 1;
            } else {
              console.error("Ended a touch event which was not counted in `trackedTouchCount`.");
              return null;
            }
          }

          ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);
          var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;
          var isResponderTouchStart = responderInst && isStartish(topLevelType);
          var isResponderTouchMove = responderInst && isMoveish(topLevelType);
          var isResponderTouchEnd = responderInst && isEndish(topLevelType);
          var incrementalTouch = isResponderTouchStart ? eventTypes$1.responderStart : isResponderTouchMove ? eventTypes$1.responderMove : isResponderTouchEnd ? eventTypes$1.responderEnd : null;

          if (incrementalTouch) {
            var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
            gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(gesture);
            extracted = accumulate(extracted, gesture);
          }

          var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;
          var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
          var finalTouch = isResponderTerminate ? eventTypes$1.responderTerminate : isResponderRelease ? eventTypes$1.responderRelease : null;

          if (finalTouch) {
            var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
            finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(finalEvent);
            extracted = accumulate(extracted, finalEvent);
            changeResponder(null);
          }

          return extracted;
        },
        GlobalResponderHandler: null,
        injection: {
          injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
            ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
          }
        }
      };
      var ReactNativeBridgeEventPlugin = {
        eventTypes: ReactNativeViewConfigRegistry.eventTypes,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (targetInst == null) {
            return null;
          }

          var bubbleDispatchConfig = ReactNativeViewConfigRegistry.customBubblingEventTypes[topLevelType];
          var directDispatchConfig = ReactNativeViewConfigRegistry.customDirectEventTypes[topLevelType];
          invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
          var event = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);

          if (bubbleDispatchConfig) {
            accumulateTwoPhaseDispatches(event);
          } else if (directDispatchConfig) {
            accumulateDirectDispatches(event);
          } else {
            return null;
          }

          return event;
        }
      };
      var ReactNativeEventPluginOrder = ["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"];
      injection.injectEventPluginOrder(ReactNativeEventPluginOrder);
      injection.injectEventPluginsByName({
        ResponderEventPlugin: ResponderEventPlugin,
        ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
      });
      var instanceCache = {};
      var instanceProps = {};

      function precacheFiberNode(hostInst, tag) {
        instanceCache[tag] = hostInst;
      }

      function uncacheFiberNode(tag) {
        delete instanceCache[tag];
        delete instanceProps[tag];
      }

      function getInstanceFromTag(tag) {
        return instanceCache[tag] || null;
      }

      function getTagFromInstance(inst) {
        var tag = inst.stateNode._nativeTag;

        if (tag === undefined) {
          tag = inst.stateNode.canonical._nativeTag;
        }

        invariant(tag, "All native instances should have a tag.");
        return tag;
      }

      function getFiberCurrentPropsFromNode$1(stateNode) {
        return instanceProps[stateNode._nativeTag] || null;
      }

      function updateFiberProps(tag, props) {
        instanceProps[tag] = props;
      }

      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;

      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);

        if (!internalInstance) {
          return;
        }

        invariant(typeof restoreImpl === "function", "setRestoreImplementation() needs to be called to handle a target for controlled " + "events. This error is likely caused by a bug in React. Please file an issue.");
        var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
        restoreImpl(internalInstance.stateNode, internalInstance.type, props);
      }

      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }

      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }

        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);

        if (queuedTargets) {
          for (var i = 0; i < queuedTargets.length; i++) {
            restoreStateOfTarget(queuedTargets[i]);
          }
        }
      }

      var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {
        return fn(bookkeeping);
      };

      var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};

      var isBatching = false;

      function batchedUpdates(fn, bookkeeping) {
        if (isBatching) {
          return fn(bookkeeping);
        }

        isBatching = true;

        try {
          return _batchedUpdatesImpl(fn, bookkeeping);
        } finally {
          isBatching = false;
          var controlledComponentsHavePendingUpdates = needsStateRestore();

          if (controlledComponentsHavePendingUpdates) {
            _flushInteractiveUpdatesImpl();

            restoreStateIfNeeded();
          }
        }
      }

      function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
        _batchedUpdatesImpl = batchedUpdatesImpl;
        _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
      }

      var EMPTY_NATIVE_EVENT = {};

      var touchSubsequence = function touchSubsequence(touches, indices) {
        var ret = [];

        for (var i = 0; i < indices.length; i++) {
          ret.push(touches[indices[i]]);
        }

        return ret;
      };

      var removeTouchesAtIndices = function removeTouchesAtIndices(touches, indices) {
        var rippedOut = [];
        var temp = touches;

        for (var i = 0; i < indices.length; i++) {
          var index = indices[i];
          rippedOut.push(touches[index]);
          temp[index] = null;
        }

        var fillAt = 0;

        for (var j = 0; j < temp.length; j++) {
          var cur = temp[j];

          if (cur !== null) {
            temp[fillAt++] = cur;
          }
        }

        temp.length = fillAt;
        return rippedOut;
      };

      function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
        var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;
        var inst = getInstanceFromTag(rootNodeID);
        batchedUpdates(function () {
          runExtractedEventsInBatch(topLevelType, inst, nativeEvent, nativeEvent.target);
        });
      }

      function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
        _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
      }

      function receiveTouches(eventTopLevelType, touches, changedIndices) {
        var changedTouches = eventTopLevelType === "topTouchEnd" || eventTopLevelType === "topTouchCancel" ? removeTouchesAtIndices(touches, changedIndices) : touchSubsequence(touches, changedIndices);

        for (var jj = 0; jj < changedTouches.length; jj++) {
          var touch = changedTouches[jj];
          touch.changedTouches = changedTouches;
          touch.touches = touches;
          var nativeEvent = touch;
          var rootNodeID = null;
          var target = nativeEvent.target;

          if (target !== null && target !== undefined) {
            if (target < 1) {
              {
                warningWithoutStack$1(false, "A view is reporting that a touch occurred on tag zero.");
              }
            } else {
              rootNodeID = target;
            }
          }

          _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);
        }
      }

      var ReactNativeGlobalResponderHandler = {
        onChange: function onChange(from, to, blockNativeResponder) {
          if (to !== null) {
            var tag = to.stateNode._nativeTag;
            UIManager.setJSResponder(tag, blockNativeResponder);
          } else {
            UIManager.clearJSResponder();
          }
        }
      };
      RCTEventEmitter.register({
        receiveEvent: receiveEvent,
        receiveTouches: receiveTouches
      });
      setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromTag, getTagFromInstance);
      ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactNativeGlobalResponderHandler);

      function get$1(key) {
        return key._reactInternalFiber;
      }

      function set(key, value) {
        key._reactInternalFiber = value;
      }

      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

      if (!ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher")) {
        ReactSharedInternals.ReactCurrentDispatcher = {
          current: null
        };
      }

      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }

        return null;
      }

      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;

      function refineResolvedLazyComponent(lazyComponent) {
        return lazyComponent._status === Resolved ? lazyComponent._result : null;
      }

      function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }

      function getComponentName(type) {
        if (type == null) {
          return null;
        }

        {
          if (typeof type.tag === "number") {
            warningWithoutStack$1(false, "Received an unexpected object in getComponentName(). " + "This is likely a bug in React. Please file an issue.");
          }
        }

        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }

        if (typeof type === "string") {
          return type;
        }

        switch (type) {
          case REACT_CONCURRENT_MODE_TYPE:
            return "ConcurrentMode";

          case REACT_FRAGMENT_TYPE:
            return "Fragment";

          case REACT_PORTAL_TYPE:
            return "Portal";

          case REACT_PROFILER_TYPE:
            return "Profiler";

          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";

          case REACT_SUSPENSE_TYPE:
            return "Suspense";
        }

        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return "Context.Consumer";

            case REACT_PROVIDER_TYPE:
              return "Context.Provider";

            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");

            case REACT_MEMO_TYPE:
              return getComponentName(type.type);

            case REACT_LAZY_TYPE:
              {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);

                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
              }
          }
        }

        return null;
      }

      var NoEffect = 0;
      var PerformedWork = 1;
      var Placement = 2;
      var Update = 4;
      var PlacementAndUpdate = 6;
      var Deletion = 8;
      var ContentReset = 16;
      var Callback = 32;
      var DidCapture = 64;
      var Ref = 128;
      var Snapshot = 256;
      var Passive = 512;
      var LifecycleEffectMask = 932;
      var HostEffectMask = 1023;
      var Incomplete = 1024;
      var ShouldCapture = 2048;
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var MOUNTING = 1;
      var MOUNTED = 2;
      var UNMOUNTED = 3;

      function isFiberMountedImpl(fiber) {
        var node = fiber;

        if (!fiber.alternate) {
          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }

          while (node.return) {
            node = node.return;

            if ((node.effectTag & Placement) !== NoEffect) {
              return MOUNTING;
            }
          }
        } else {
          while (node.return) {
            node = node.return;
          }
        }

        if (node.tag === HostRoot) {
          return MOUNTED;
        }

        return UNMOUNTED;
      }

      function isFiberMounted(fiber) {
        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function isMounted(component) {
        {
          var owner = ReactCurrentOwner$1.current;

          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component") : void 0;
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get$1(component);

        if (!fiber) {
          return false;
        }

        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function assertIsMounted(fiber) {
        invariant(isFiberMountedImpl(fiber) === MOUNTED, "Unable to find node on an unmounted component.");
      }

      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;

        if (!alternate) {
          var state = isFiberMountedImpl(fiber);
          invariant(state !== UNMOUNTED, "Unable to find node on an unmounted component.");

          if (state === MOUNTING) {
            return null;
          }

          return fiber;
        }

        var a = fiber;
        var b = alternate;

        while (true) {
          var parentA = a.return;
          var parentB = parentA ? parentA.alternate : null;

          if (!parentA || !parentB) {
            break;
          }

          if (parentA.child === parentB.child) {
            var child = parentA.child;

            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }

              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }

              child = child.sibling;
            }

            invariant(false, "Unable to find node on an unmounted component.");
          }

          if (a.return !== b.return) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;

            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }

              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }

              _child = _child.sibling;
            }

            if (!didFindChild) {
              _child = parentB.child;

              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }

                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }

                _child = _child.sibling;
              }

              invariant(didFindChild, "Child was not found in either parent set. This indicates a bug " + "in React related to the return pointer. Please file an issue.");
            }
          }

          invariant(a.alternate === b, "Return fibers should always be each others' alternates. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        invariant(a.tag === HostRoot, "Unable to find node on an unmounted component.");

        if (a.stateNode.current === a) {
          return fiber;
        }

        return alternate;
      }

      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);

        if (!currentParent) {
          return null;
        }

        var node = currentParent;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          } else if (node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === currentParent) {
            return null;
          }

          while (!node.sibling) {
            if (!node.return || node.return === currentParent) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }

        return null;
      }

      var emptyObject = {};
      var removedKeys = null;
      var removedKeyCount = 0;

      function defaultDiffer(prevProp, nextProp) {
        if (typeof nextProp !== "object" || nextProp === null) {
          return true;
        } else {
          return deepDiffer(prevProp, nextProp);
        }
      }

      function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
        if (Array.isArray(node)) {
          var i = node.length;

          while (i-- && removedKeyCount > 0) {
            restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
          }
        } else if (node && removedKeyCount > 0) {
          var obj = node;

          for (var propKey in removedKeys) {
            if (!removedKeys[propKey]) {
              continue;
            }

            var nextProp = obj[propKey];

            if (nextProp === undefined) {
              continue;
            }

            var attributeConfig = validAttributes[propKey];

            if (!attributeConfig) {
              continue;
            }

            if (typeof nextProp === "function") {
              nextProp = true;
            }

            if (typeof nextProp === "undefined") {
              nextProp = null;
            }

            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            removedKeys[propKey] = false;
            removedKeyCount--;
          }
        }
      }

      function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {
        var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
        var i = void 0;

        for (i = 0; i < minLength; i++) {
          updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);
        }

        for (; i < prevArray.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);
        }

        for (; i < nextArray.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);
        }

        return updatePayload;
      }

      function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
        if (!updatePayload && prevProp === nextProp) {
          return updatePayload;
        }

        if (!prevProp || !nextProp) {
          if (nextProp) {
            return addNestedProperty(updatePayload, nextProp, validAttributes);
          }

          if (prevProp) {
            return clearNestedProperty(updatePayload, prevProp, validAttributes);
          }

          return updatePayload;
        }

        if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {
          return diffProperties(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
          return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp)) {
          return diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes);
        }

        return diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);
      }

      function addNestedProperty(updatePayload, nextProp, validAttributes) {
        if (!nextProp) {
          return updatePayload;
        }

        if (!Array.isArray(nextProp)) {
          return addProperties(updatePayload, nextProp, validAttributes);
        }

        for (var i = 0; i < nextProp.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
        }

        return updatePayload;
      }

      function clearNestedProperty(updatePayload, prevProp, validAttributes) {
        if (!prevProp) {
          return updatePayload;
        }

        if (!Array.isArray(prevProp)) {
          return clearProperties(updatePayload, prevProp, validAttributes);
        }

        for (var i = 0; i < prevProp.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
        }

        return updatePayload;
      }

      function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
        var attributeConfig = void 0;
        var nextProp = void 0;
        var prevProp = void 0;

        for (var propKey in nextProps) {
          attributeConfig = validAttributes[propKey];

          if (!attributeConfig) {
            continue;
          }

          prevProp = prevProps[propKey];
          nextProp = nextProps[propKey];

          if (typeof nextProp === "function") {
            nextProp = true;

            if (typeof prevProp === "function") {
              prevProp = true;
            }
          }

          if (typeof nextProp === "undefined") {
            nextProp = null;

            if (typeof prevProp === "undefined") {
              prevProp = null;
            }
          }

          if (removedKeys) {
            removedKeys[propKey] = false;
          }

          if (updatePayload && updatePayload[propKey] !== undefined) {
            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            continue;
          }

          if (prevProp === nextProp) {
            continue;
          }

          if (typeof attributeConfig !== "object") {
            if (defaultDiffer(prevProp, nextProp)) {
              (updatePayload || (updatePayload = {}))[propKey] = nextProp;
            }
          } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === "function" ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));

            if (shouldUpdate) {
              var _nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;

              (updatePayload || (updatePayload = {}))[propKey] = _nextValue;
            }
          } else {
            removedKeys = null;
            removedKeyCount = 0;
            updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);

            if (removedKeyCount > 0 && updatePayload) {
              restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);
              removedKeys = null;
            }
          }
        }

        for (var _propKey in prevProps) {
          if (nextProps[_propKey] !== undefined) {
            continue;
          }

          attributeConfig = validAttributes[_propKey];

          if (!attributeConfig) {
            continue;
          }

          if (updatePayload && updatePayload[_propKey] !== undefined) {
            continue;
          }

          prevProp = prevProps[_propKey];

          if (prevProp === undefined) {
            continue;
          }

          if (typeof attributeConfig !== "object" || typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            (updatePayload || (updatePayload = {}))[_propKey] = null;

            if (!removedKeys) {
              removedKeys = {};
            }

            if (!removedKeys[_propKey]) {
              removedKeys[_propKey] = true;
              removedKeyCount++;
            }
          } else {
            updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);
          }
        }

        return updatePayload;
      }

      function addProperties(updatePayload, props, validAttributes) {
        return diffProperties(updatePayload, emptyObject, props, validAttributes);
      }

      function clearProperties(updatePayload, prevProps, validAttributes) {
        return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);
      }

      function create(props, validAttributes) {
        return addProperties(null, props, validAttributes);
      }

      function diff(prevProps, nextProps, validAttributes) {
        return diffProperties(null, prevProps, nextProps, validAttributes);
      }

      function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
        return function () {
          if (!callback) {
            return undefined;
          }

          if (typeof context.__isMounted === "boolean") {
            if (!context.__isMounted) {
              return undefined;
            }
          }

          return callback.apply(context, arguments);
        };
      }

      function throwOnStylesProp(component, props) {
        if (props.styles !== undefined) {
          var owner = component._owner || null;
          var name = component.constructor.displayName;
          var msg = "`styles` is not a supported property of `" + name + "`, did " + "you mean `style` (singular)?";

          if (owner && owner.constructor && owner.constructor.displayName) {
            msg += "\n\nCheck the `" + owner.constructor.displayName + "` parent " + " component.";
          }

          throw new Error(msg);
        }
      }

      function warnForStyleProps(props, validAttributes) {
        for (var key in validAttributes.style) {
          if (!(validAttributes[key] || props[key] === undefined)) {
            console.error("You are setting the style `{ " + key + ": ... }` as a prop. You " + "should nest it in a style object. " + "E.g. `{ style: { " + key + ": ... } }`");
          }
        }
      }

      var debugRenderPhaseSideEffects = false;
      var debugRenderPhaseSideEffectsForStrictMode = false;
      var enableUserTimingAPI = true;
      var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
      var warnAboutDeprecatedLifecycles = false;
      var enableProfilerTimer = true;
      var enableSchedulerTracing = true;
      var enableSuspenseServerRenderer = false;
      var warnAboutDeprecatedSetNativeProps = false;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var ReactNativeFiberHostComponent = function () {
        function ReactNativeFiberHostComponent(tag, viewConfig) {
          _classCallCheck(this, ReactNativeFiberHostComponent);

          this._nativeTag = tag;
          this._children = [];
          this.viewConfig = viewConfig;
        }

        ReactNativeFiberHostComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(this._nativeTag);
        };

        ReactNativeFiberHostComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(this._nativeTag);
        };

        ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {
          UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(callback) {
          UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        };

        ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
          {
            if (warnAboutDeprecatedSetNativeProps) {
              warningWithoutStack$1(false, "Warning: Calling ref.setNativeProps(nativeProps) " + "is deprecated and will be removed in a future release. " + "Use the setNativeProps export from the react-native package instead." + "\n\timport {setNativeProps} from 'react-native';\n\tsetNativeProps(ref, nativeProps);\n");
            }

            warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
          }
          var updatePayload = create(nativeProps, this.viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, updatePayload);
          }
        };

        return ReactNativeFiberHostComponent;
      }();

      var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
      var now$1 = hasNativePerformanceNow ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };
      var scheduledCallback = null;
      var frameDeadline = 0;

      function setTimeoutCallback() {
        frameDeadline = now$1() + 5;
        var callback = scheduledCallback;
        scheduledCallback = null;

        if (callback !== null) {
          callback();
        }
      }

      function scheduleDeferredCallback$1(callback, options) {
        scheduledCallback = callback;
        var timeoutId = setTimeout(setTimeoutCallback, 1);
        return timeoutId;
      }

      function cancelDeferredCallback$1(callbackID) {
        scheduledCallback = null;
        clearTimeout(callbackID);
      }

      function shouldYield$1() {
        return frameDeadline <= now$1();
      }

      function shim() {
        invariant(false, "The current renderer does not support persistence. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsPersistence = false;
      var cloneInstance = shim;
      var createContainerChildSet = shim;
      var appendChildToContainerChildSet = shim;
      var finalizeContainerChildren = shim;
      var replaceContainerChildren = shim;
      var cloneHiddenInstance = shim;
      var cloneUnhiddenInstance = shim;
      var createHiddenTextInstance = shim;

      function shim$1() {
        invariant(false, "The current renderer does not support hydration. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsHydration = false;
      var canHydrateInstance = shim$1;
      var canHydrateTextInstance = shim$1;
      var canHydrateSuspenseInstance = shim$1;
      var isSuspenseInstancePending = shim$1;
      var isSuspenseInstanceFallback = shim$1;
      var registerSuspenseInstanceRetry = shim$1;
      var getNextHydratableSibling = shim$1;
      var getFirstHydratableChild = shim$1;
      var hydrateInstance = shim$1;
      var hydrateTextInstance = shim$1;
      var getNextHydratableInstanceAfterSuspenseInstance = shim$1;
      var clearSuspenseBoundary = shim$1;
      var clearSuspenseBoundaryFromContainer = shim$1;
      var didNotMatchHydratedContainerTextInstance = shim$1;
      var didNotMatchHydratedTextInstance = shim$1;
      var didNotHydrateContainerInstance = shim$1;
      var didNotHydrateInstance = shim$1;
      var didNotFindHydratableContainerInstance = shim$1;
      var didNotFindHydratableContainerTextInstance = shim$1;
      var didNotFindHydratableContainerSuspenseInstance = shim$1;
      var didNotFindHydratableInstance = shim$1;
      var didNotFindHydratableTextInstance = shim$1;
      var didNotFindHydratableSuspenseInstance = shim$1;
      var UPDATE_SIGNAL = {};
      {
        Object.freeze(UPDATE_SIGNAL);
      }
      var nextReactTag = 3;

      function allocateTag() {
        var tag = nextReactTag;

        if (tag % 10 === 1) {
          tag += 2;
        }

        nextReactTag = tag + 2;
        return tag;
      }

      function recursivelyUncacheFiberNode(node) {
        if (typeof node === "number") {
          uncacheFiberNode(node);
        } else {
          uncacheFiberNode(node._nativeTag);

          node._children.forEach(recursivelyUncacheFiberNode);
        }
      }

      function appendInitialChild(parentInstance, child) {
        parentInstance._children.push(child);
      }

      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var tag = allocateTag();
        var viewConfig = ReactNativeViewConfigRegistry.get(type);
        {
          for (var key in viewConfig.validAttributes) {
            if (props.hasOwnProperty(key)) {
              deepFreezeAndThrowOnMutationInDev(props[key]);
            }
          }
        }
        invariant(type !== "RCTView" || !hostContext.isInAParentText, "Nesting of <View> within <Text> is not currently supported.");
        var updatePayload = create(props, viewConfig.validAttributes);
        UIManager.createView(tag, viewConfig.uiViewClassName, rootContainerInstance, updatePayload);
        var component = new ReactNativeFiberHostComponent(tag, viewConfig);
        precacheFiberNode(internalInstanceHandle, tag);
        updateFiberProps(tag, props);
        return component;
      }

      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        invariant(hostContext.isInAParentText, "Text strings must be rendered within a <Text> component.");
        var tag = allocateTag();
        UIManager.createView(tag, "RCTRawText", rootContainerInstance, {
          text: text
        });
        precacheFiberNode(internalInstanceHandle, tag);
        return tag;
      }

      function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {
        if (parentInstance._children.length === 0) {
          return false;
        }

        var nativeTags = parentInstance._children.map(function (child) {
          return typeof child === "number" ? child : child._nativeTag;
        });

        UIManager.setChildren(parentInstance._nativeTag, nativeTags);
        return false;
      }

      function getRootHostContext(rootContainerInstance) {
        return {
          isInAParentText: false
        };
      }

      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        var prevIsInAParentText = parentHostContext.isInAParentText;
        var isInAParentText = type === "AndroidTextInput" || type === "RCTMultilineTextInputView" || type === "RCTSinglelineTextInputView" || type === "RCTText" || type === "RCTVirtualText";

        if (prevIsInAParentText !== isInAParentText) {
          return {
            isInAParentText: isInAParentText
          };
        } else {
          return parentHostContext;
        }
      }

      function getPublicInstance(instance) {
        return instance;
      }

      function prepareForCommit(containerInfo) {}

      function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
        return UPDATE_SIGNAL;
      }

      function resetAfterCommit(containerInfo) {}

      var now$$1 = now$1;
      var isPrimaryRenderer = true;
      var scheduleDeferredCallback$$1 = scheduleDeferredCallback$1;
      var cancelDeferredCallback$$1 = cancelDeferredCallback$1;
      var shouldYield$$1 = shouldYield$1;
      var scheduleTimeout = setTimeout;
      var cancelTimeout = clearTimeout;
      var noTimeout = -1;
      var schedulePassiveEffects = scheduleDeferredCallback$$1;
      var cancelPassiveEffects = cancelDeferredCallback$$1;

      function shouldDeprioritizeSubtree(type, props) {
        return false;
      }

      function shouldSetTextContent(type, props) {
        return false;
      }

      var supportsMutation = true;

      function appendChild(parentInstance, child) {
        var childTag = typeof child === "number" ? child : child._nativeTag;
        var children = parentInstance._children;
        var index = children.indexOf(child);

        if (index >= 0) {
          children.splice(index, 1);
          children.push(child);
          UIManager.manageChildren(parentInstance._nativeTag, [index], [children.length - 1], [], [], []);
        } else {
          children.push(child);
          UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [children.length - 1], []);
        }
      }

      function appendChildToContainer(parentInstance, child) {
        var childTag = typeof child === "number" ? child : child._nativeTag;
        UIManager.setChildren(parentInstance, [childTag]);
      }

      function commitTextUpdate(textInstance, oldText, newText) {
        UIManager.updateView(textInstance, "RCTRawText", {
          text: newText
        });
      }

      function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps, internalInstanceHandle) {
        var viewConfig = instance.viewConfig;
        updateFiberProps(instance._nativeTag, newProps);
        var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);

        if (updatePayload != null) {
          UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
        }
      }

      function insertBefore(parentInstance, child, beforeChild) {
        var children = parentInstance._children;
        var index = children.indexOf(child);

        if (index >= 0) {
          children.splice(index, 1);
          var beforeChildIndex = children.indexOf(beforeChild);
          children.splice(beforeChildIndex, 0, child);
          UIManager.manageChildren(parentInstance._nativeTag, [index], [beforeChildIndex], [], [], []);
        } else {
          var _beforeChildIndex = children.indexOf(beforeChild);

          children.splice(_beforeChildIndex, 0, child);
          var childTag = typeof child === "number" ? child : child._nativeTag;
          UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [_beforeChildIndex], []);
        }
      }

      function insertInContainerBefore(parentInstance, child, beforeChild) {
        invariant(typeof parentInstance !== "number", "Container does not support insertBefore operation");
      }

      function removeChild(parentInstance, child) {
        recursivelyUncacheFiberNode(child);
        var children = parentInstance._children;
        var index = children.indexOf(child);
        children.splice(index, 1);
        UIManager.manageChildren(parentInstance._nativeTag, [], [], [], [], [index]);
      }

      function removeChildFromContainer(parentInstance, child) {
        recursivelyUncacheFiberNode(child);
        UIManager.manageChildren(parentInstance, [], [], [], [], [0]);
      }

      function resetTextContent(instance) {}

      function hideInstance(instance) {
        var viewConfig = instance.viewConfig;
        var updatePayload = create({
          style: {
            display: "none"
          }
        }, viewConfig.validAttributes);
        UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
      }

      function hideTextInstance(textInstance) {
        throw new Error("Not yet implemented.");
      }

      function unhideInstance(instance, props) {
        var viewConfig = instance.viewConfig;
        var updatePayload = diff(_extends({}, props, {
          style: [props.style, {
            display: "none"
          }]
        }), props, viewConfig.validAttributes);
        UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
      }

      function unhideTextInstance(textInstance, text) {
        throw new Error("Not yet implemented.");
      }

      var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        var sourceInfo = "";

        if (source) {
          var path = source.fileName;
          var fileName = path.replace(BEFORE_SLASH_RE, "");
          {
            if (/^index\./.test(fileName)) {
              var match = path.match(BEFORE_SLASH_RE);

              if (match) {
                var pathBeforeSlash = match[1];

                if (pathBeforeSlash) {
                  var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                  fileName = folderName + "/" + fileName;
                }
              }
            }
          }
          sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
        } else if (ownerName) {
          sourceInfo = " (created by " + ownerName + ")";
        }

        return "\n    in " + (name || "Unknown") + sourceInfo;
      };

      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

      function describeFiber(fiber) {
        switch (fiber.tag) {
          case HostRoot:
          case HostPortal:
          case HostText:
          case Fragment:
          case ContextProvider:
          case ContextConsumer:
            return "";

          default:
            var owner = fiber._debugOwner;
            var source = fiber._debugSource;
            var name = getComponentName(fiber.type);
            var ownerName = null;

            if (owner) {
              ownerName = getComponentName(owner.type);
            }

            return describeComponentFrame(name, source, ownerName);
        }
      }

      function getStackByFiberInDevAndProd(workInProgress) {
        var info = "";
        var node = workInProgress;

        do {
          info += describeFiber(node);
          node = node.return;
        } while (node);

        return info;
      }

      var current = null;
      var phase = null;

      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null) {
            return null;
          }

          var owner = current._debugOwner;

          if (owner !== null && typeof owner !== "undefined") {
            return getComponentName(owner.type);
          }
        }
        return null;
      }

      function getCurrentFiberStackInDev() {
        {
          if (current === null) {
            return "";
          }

          return getStackByFiberInDevAndProd(current);
        }
        return "";
      }

      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current = null;
          phase = null;
        }
      }

      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
          current = fiber;
          phase = null;
        }
      }

      function setCurrentPhase(lifeCyclePhase) {
        {
          phase = lifeCyclePhase;
        }
      }

      var reactEmoji = "\u269B";
      var warningEmoji = "\u26D4";
      var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
      var currentFiber = null;
      var currentPhase = null;
      var currentPhaseFiber = null;
      var isCommitting = false;
      var hasScheduledUpdateInCurrentCommit = false;
      var hasScheduledUpdateInCurrentPhase = false;
      var commitCountInCurrentWorkLoop = 0;
      var effectCountInCurrentCommit = 0;
      var isWaitingForCallback = false;
      var labelsInCurrentCommit = new Set();

      var formatMarkName = function formatMarkName(markName) {
        return reactEmoji + " " + markName;
      };

      var formatLabel = function formatLabel(label, warning) {
        var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
        var suffix = warning ? " Warning: " + warning : "";
        return "" + prefix + label + suffix;
      };

      var beginMark = function beginMark(markName) {
        performance.mark(formatMarkName(markName));
      };

      var clearMark = function clearMark(markName) {
        performance.clearMarks(formatMarkName(markName));
      };

      var endMark = function endMark(label, markName, warning) {
        var formattedMarkName = formatMarkName(markName);
        var formattedLabel = formatLabel(label, warning);

        try {
          performance.measure(formattedLabel, formattedMarkName);
        } catch (err) {}

        performance.clearMarks(formattedMarkName);
        performance.clearMeasures(formattedLabel);
      };

      var getFiberMarkName = function getFiberMarkName(label, debugID) {
        return label + " (#" + debugID + ")";
      };

      var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
        if (phase === null) {
          return componentName + " [" + (isMounted ? "update" : "mount") + "]";
        } else {
          return componentName + "." + phase;
        }
      };

      var beginFiberMark = function beginFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);

        if (isCommitting && labelsInCurrentCommit.has(label)) {
          return false;
        }

        labelsInCurrentCommit.add(label);
        var markName = getFiberMarkName(label, debugID);
        beginMark(markName);
        return true;
      };

      var clearFiberMark = function clearFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        clearMark(markName);
      };

      var endFiberMark = function endFiberMark(fiber, phase, warning) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        endMark(label, markName, warning);
      };

      var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
        switch (fiber.tag) {
          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case Fragment:
          case ContextProvider:
          case ContextConsumer:
          case Mode:
            return true;

          default:
            return false;
        }
      };

      var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
        if (currentPhase !== null && currentPhaseFiber !== null) {
          clearFiberMark(currentPhaseFiber, currentPhase);
        }

        currentPhaseFiber = null;
        currentPhase = null;
        hasScheduledUpdateInCurrentPhase = false;
      };

      var pauseTimers = function pauseTimers() {
        var fiber = currentFiber;

        while (fiber) {
          if (fiber._debugIsCurrentlyTiming) {
            endFiberMark(fiber, null, null);
          }

          fiber = fiber.return;
        }
      };

      var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
        if (fiber.return !== null) {
          resumeTimersRecursively(fiber.return);
        }

        if (fiber._debugIsCurrentlyTiming) {
          beginFiberMark(fiber, null);
        }
      };

      var resumeTimers = function resumeTimers() {
        if (currentFiber !== null) {
          resumeTimersRecursively(currentFiber);
        }
      };

      function recordEffect() {
        if (enableUserTimingAPI) {
          effectCountInCurrentCommit++;
        }
      }

      function recordScheduleUpdate() {
        if (enableUserTimingAPI) {
          if (isCommitting) {
            hasScheduledUpdateInCurrentCommit = true;
          }

          if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
            hasScheduledUpdateInCurrentPhase = true;
          }
        }
      }

      function startRequestCallbackTimer() {
        if (enableUserTimingAPI) {
          if (supportsUserTiming && !isWaitingForCallback) {
            isWaitingForCallback = true;
            beginMark("(Waiting for async callback...)");
          }
        }
      }

      function stopRequestCallbackTimer(didExpire, expirationTime) {
        if (enableUserTimingAPI) {
          if (supportsUserTiming) {
            isWaitingForCallback = false;
            var warning = didExpire ? "React was blocked by main thread" : null;
            endMark("(Waiting for async callback... will force flush in " + expirationTime + " ms)", "(Waiting for async callback...)", warning);
          }
        }
      }

      function startWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber;

          if (!beginFiberMark(fiber, null)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = true;
        }
      }

      function cancelWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          clearFiberMark(fiber, null);
        }
      }

      function stopWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          endFiberMark(fiber, null, null);
        }
      }

      function stopFailedWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          var warning = fiber.tag === SuspenseComponent || fiber.tag === DehydratedSuspenseComponent ? "Rendering was suspended" : "An error was thrown inside this error boundary";
          endFiberMark(fiber, null, warning);
        }
      }

      function startPhaseTimer(fiber, phase) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          clearPendingPhaseMeasurement();

          if (!beginFiberMark(fiber, phase)) {
            return;
          }

          currentPhaseFiber = fiber;
          currentPhase = phase;
        }
      }

      function stopPhaseTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          if (currentPhase !== null && currentPhaseFiber !== null) {
            var warning = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
            endFiberMark(currentPhaseFiber, currentPhase, warning);
          }

          currentPhase = null;
          currentPhaseFiber = null;
        }
      }

      function startWorkLoopTimer(nextUnitOfWork) {
        if (enableUserTimingAPI) {
          currentFiber = nextUnitOfWork;

          if (!supportsUserTiming) {
            return;
          }

          commitCountInCurrentWorkLoop = 0;
          beginMark("(React Tree Reconciliation)");
          resumeTimers();
        }
      }

      function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (interruptedBy !== null) {
            if (interruptedBy.tag === HostRoot) {
              warning = "A top-level update interrupted the previous render";
            } else {
              var componentName = getComponentName(interruptedBy.type) || "Unknown";
              warning = "An update to " + componentName + " interrupted the previous render";
            }
          } else if (commitCountInCurrentWorkLoop > 1) {
            warning = "There were cascading updates";
          }

          commitCountInCurrentWorkLoop = 0;
          var label = didCompleteRoot ? "(React Tree Reconciliation: Completed Root)" : "(React Tree Reconciliation: Yielded)";
          pauseTimers();
          endMark(label, "(React Tree Reconciliation)", warning);
        }
      }

      function startCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          isCommitting = true;
          hasScheduledUpdateInCurrentCommit = false;
          labelsInCurrentCommit.clear();
          beginMark("(Committing Changes)");
        }
      }

      function stopCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (hasScheduledUpdateInCurrentCommit) {
            warning = "Lifecycle hook scheduled a cascading update";
          } else if (commitCountInCurrentWorkLoop > 0) {
            warning = "Caused by a cascading update in earlier commit";
          }

          hasScheduledUpdateInCurrentCommit = false;
          commitCountInCurrentWorkLoop++;
          isCommitting = false;
          labelsInCurrentCommit.clear();
          endMark("(Committing Changes)", "(Committing Changes)", warning);
        }
      }

      function startCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Snapshot Effects)");
        }
      }

      function stopCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Snapshot Effects: " + count + " Total)", "(Committing Snapshot Effects)", null);
        }
      }

      function startCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Host Effects)");
        }
      }

      function stopCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
        }
      }

      function startCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Calling Lifecycle Methods)");
        }
      }

      function stopCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
        }
      }

      var valueStack = [];
      var fiberStack = void 0;
      {
        fiberStack = [];
      }
      var index = -1;

      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }

      function pop(cursor, fiber) {
        if (index < 0) {
          {
            warningWithoutStack$1(false, "Unexpected pop.");
          }
          return;
        }

        {
          if (fiber !== fiberStack[index]) {
            warningWithoutStack$1(false, "Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }

      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }

      function checkThatStackIsEmpty() {
        {
          if (index !== -1) {
            warningWithoutStack$1(false, "Expected an empty stack. Something was not reset properly.");
          }
        }
      }

      function resetStackAfterFatalErrorInDev() {
        {
          index = -1;
          valueStack.length = 0;
          fiberStack.length = 0;
        }
      }

      var warnedAboutMissingGetChildContext = void 0;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;

      function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
        if (didPushOwnContextIfProvider && isContextProvider(Component)) {
          return previousContext;
        }

        return contextStackCursor.current;
      }

      function cacheContext(workInProgress, unmaskedContext, maskedContext) {
        var instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
      }

      function getMaskedContext(workInProgress, unmaskedContext) {
        var type = workInProgress.type;
        var contextTypes = type.contextTypes;

        if (!contextTypes) {
          return emptyContextObject;
        }

        var instance = workInProgress.stateNode;

        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
          return instance.__reactInternalMemoizedMaskedChildContext;
        }

        var context = {};

        for (var key in contextTypes) {
          context[key] = unmaskedContext[key];
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(contextTypes, context, "context", name, getCurrentFiberStackInDev);
        }

        if (instance) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return context;
      }

      function hasContextChanged() {
        return didPerformWorkStackCursor.current;
      }

      function isContextProvider(type) {
        var childContextTypes = type.childContextTypes;
        return childContextTypes !== null && childContextTypes !== undefined;
      }

      function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function pushTopLevelContextObject(fiber, context, didChange) {
        invariant(contextStackCursor.current === emptyContextObject, "Unexpected context found on stack. " + "This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
      }

      function processChildContext(fiber, type, parentContext) {
        var instance = fiber.stateNode;
        var childContextTypes = type.childContextTypes;

        if (typeof instance.getChildContext !== "function") {
          {
            var componentName = getComponentName(type) || "Unknown";

            if (!warnedAboutMissingGetChildContext[componentName]) {
              warnedAboutMissingGetChildContext[componentName] = true;
              warningWithoutStack$1(false, "%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
            }
          }
          return parentContext;
        }

        var childContext = void 0;
        {
          setCurrentPhase("getChildContext");
        }
        startPhaseTimer(fiber, "getChildContext");
        childContext = instance.getChildContext();
        stopPhaseTimer();
        {
          setCurrentPhase(null);
        }

        for (var contextKey in childContext) {
          invariant(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || "Unknown", contextKey);
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(childContextTypes, childContext, "child context", name, getCurrentFiberStackInDev);
        }
        return _extends({}, parentContext, childContext);
      }

      function pushContextProvider(workInProgress) {
        var instance = workInProgress.stateNode;
        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        return true;
      }

      function invalidateContextProvider(workInProgress, type, didChange) {
        var instance = workInProgress.stateNode;
        invariant(instance, "Expected to have an instance by this point. " + "This error is likely caused by a bug in React. Please file an issue.");

        if (didChange) {
          var mergedContext = processChildContext(workInProgress, type, previousContext);
          instance.__reactInternalMemoizedMergedChildContext = mergedContext;
          pop(didPerformWorkStackCursor, workInProgress);
          pop(contextStackCursor, workInProgress);
          push(contextStackCursor, mergedContext, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        } else {
          pop(didPerformWorkStackCursor, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        }
      }

      function findCurrentUnmaskedContext(fiber) {
        invariant(isFiberMounted(fiber) && fiber.tag === ClassComponent, "Expected subtree parent to be a mounted class component. " + "This error is likely caused by a bug in React. Please file an issue.");
        var node = fiber;

        do {
          switch (node.tag) {
            case HostRoot:
              return node.stateNode.context;

            case ClassComponent:
              {
                var Component = node.type;

                if (isContextProvider(Component)) {
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                }

                break;
              }
          }

          node = node.return;
        } while (node !== null);

        invariant(false, "Found unexpected detached subtree parent. " + "This error is likely caused by a bug in React. Please file an issue.");
      }

      var onCommitFiberRoot = null;
      var onCommitFiberUnmount = null;
      var hasLoggedError = false;

      function catchErrors(fn) {
        return function (arg) {
          try {
            return fn(arg);
          } catch (err) {
            if (true && !hasLoggedError) {
              hasLoggedError = true;
              warningWithoutStack$1(false, "React DevTools encountered an error: %s", err);
            }
          }
        };
      }

      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";

      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }

        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook.isDisabled) {
          return true;
        }

        if (!hook.supportsFiber) {
          {
            warningWithoutStack$1(false, "The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://fb.me/react-devtools");
          }
          return true;
        }

        try {
          var rendererID = hook.inject(internals);
          onCommitFiberRoot = catchErrors(function (root) {
            return hook.onCommitFiberRoot(rendererID, root);
          });
          onCommitFiberUnmount = catchErrors(function (fiber) {
            return hook.onCommitFiberUnmount(rendererID, fiber);
          });
        } catch (err) {
          {
            warningWithoutStack$1(false, "React DevTools encountered an error: %s.", err);
          }
        }

        return true;
      }

      function onCommitRoot(root) {
        if (typeof onCommitFiberRoot === "function") {
          onCommitFiberRoot(root);
        }
      }

      function onCommitUnmount(fiber) {
        if (typeof onCommitFiberUnmount === "function") {
          onCommitFiberUnmount(fiber);
        }
      }

      var maxSigned31BitInt = 1073741823;
      var NoWork = 0;
      var Never = 1;
      var Sync = maxSigned31BitInt;
      var UNIT_SIZE = 10;
      var MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;

      function msToExpirationTime(ms) {
        return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);
      }

      function expirationTimeToMs(expirationTime) {
        return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
      }

      function ceiling(num, precision) {
        return ((num / precision | 0) + 1) * precision;
      }

      function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
        return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
      }

      var LOW_PRIORITY_EXPIRATION = 5000;
      var LOW_PRIORITY_BATCH_SIZE = 250;

      function computeAsyncExpiration(currentTime) {
        return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
      }

      var HIGH_PRIORITY_EXPIRATION = 500;
      var HIGH_PRIORITY_BATCH_SIZE = 100;

      function computeInteractiveExpiration(currentTime) {
        return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
      }

      var NoContext = 0;
      var ConcurrentMode = 1;
      var StrictMode = 2;
      var ProfileMode = 4;
      var hasBadMapPolyfill = void 0;
      {
        hasBadMapPolyfill = false;

        try {
          var nonExtensibleObject = Object.preventExtensions({});
          var testMap = new Map([[nonExtensibleObject, null]]);
          var testSet = new Set([nonExtensibleObject]);
          testMap.set(0, 0);
          testSet.add(0);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      var debugCounter = void 0;
      {
        debugCounter = 1;
      }

      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.contextDependencies = null;
        this.mode = mode;
        this.effectTag = NoEffect;
        this.nextEffect = null;
        this.firstEffect = null;
        this.lastEffect = null;
        this.expirationTime = NoWork;
        this.childExpirationTime = NoWork;
        this.alternate = null;

        if (enableProfilerTimer) {
          this.actualDuration = Number.NaN;
          this.actualStartTime = Number.NaN;
          this.selfBaseDuration = Number.NaN;
          this.treeBaseDuration = Number.NaN;
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }

        {
          this._debugID = debugCounter++;
          this._debugSource = null;
          this._debugOwner = null;
          this._debugIsCurrentlyTiming = false;

          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }

      var createFiber = function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };

      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }

      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined;
      }

      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== undefined && Component !== null) {
          var $$typeof = Component.$$typeof;

          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }

          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }

        return IndeterminateComponent;
      }

      function createWorkInProgress(current, pendingProps, expirationTime) {
        var workInProgress = current.alternate;

        if (workInProgress === null) {
          workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
          workInProgress.elementType = current.elementType;
          workInProgress.type = current.type;
          workInProgress.stateNode = current.stateNode;
          {
            workInProgress._debugID = current._debugID;
            workInProgress._debugSource = current._debugSource;
            workInProgress._debugOwner = current._debugOwner;
          }
          workInProgress.alternate = current;
          current.alternate = workInProgress;
        } else {
          workInProgress.pendingProps = pendingProps;
          workInProgress.effectTag = NoEffect;
          workInProgress.nextEffect = null;
          workInProgress.firstEffect = null;
          workInProgress.lastEffect = null;

          if (enableProfilerTimer) {
            workInProgress.actualDuration = 0;
            workInProgress.actualStartTime = -1;
          }
        }

        workInProgress.childExpirationTime = current.childExpirationTime;
        workInProgress.expirationTime = current.expirationTime;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.contextDependencies = current.contextDependencies;
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;

        if (enableProfilerTimer) {
          workInProgress.selfBaseDuration = current.selfBaseDuration;
          workInProgress.treeBaseDuration = current.treeBaseDuration;
        }

        return workInProgress;
      }

      function createHostRootFiber(isConcurrent) {
        var mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;

        if (enableProfilerTimer && isDevToolsPresent) {
          mode |= ProfileMode;
        }

        return createFiber(HostRoot, null, null, mode);
      }

      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
        var fiber = void 0;
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;

        if (typeof type === "function") {
          if (shouldConstruct(type)) {
            fiberTag = ClassComponent;
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);

            case REACT_CONCURRENT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | ConcurrentMode | StrictMode, expirationTime, key);

            case REACT_STRICT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | StrictMode, expirationTime, key);

            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, expirationTime, key);

            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, expirationTime, key);

            default:
              {
                if (typeof type === "object" && type !== null) {
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = ContextProvider;
                      break getTag;

                    case REACT_CONTEXT_TYPE:
                      fiberTag = ContextConsumer;
                      break getTag;

                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = ForwardRef;
                      break getTag;

                    case REACT_MEMO_TYPE:
                      fiberTag = MemoComponent;
                      break getTag;

                    case REACT_LAZY_TYPE:
                      fiberTag = LazyComponent;
                      resolvedType = null;
                      break getTag;
                  }
                }

                var info = "";
                {
                  if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                    info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
                  }

                  var ownerName = owner ? getComponentName(owner.type) : null;

                  if (ownerName) {
                    info += "\n\nCheck the render method of `" + ownerName + "`.";
                  }
                }
                invariant(false, "Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + "but got: %s.%s", type == null ? type : typeof type, info);
              }
          }
        }

        fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromElement(element, mode, expirationTime) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }

      function createFiberFromFragment(elements, mode, expirationTime, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
        {
          if (typeof pendingProps.id !== "string" || typeof pendingProps.onRender !== "function") {
            warningWithoutStack$1(false, 'Profiler must specify an "id" string and "onRender" function as props');
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.type = REACT_PROFILER_TYPE;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromMode(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(Mode, pendingProps, key, mode);
        var type = (mode & ConcurrentMode) === NoContext ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        var type = REACT_SUSPENSE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromText(content, mode, expirationTime) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoContext);
        fiber.elementType = "DELETED";
        fiber.type = "DELETED";
        return fiber;
      }

      function createFiberFromPortal(portal, mode, expirationTime) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.expirationTime = expirationTime;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return fiber;
      }

      function assignFiberPropertiesInDEV(target, source) {
        if (target === null) {
          target = createFiber(IndeterminateComponent, null, null, NoContext);
        }

        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.contextDependencies = source.contextDependencies;
        target.mode = source.mode;
        target.effectTag = source.effectTag;
        target.nextEffect = source.nextEffect;
        target.firstEffect = source.firstEffect;
        target.lastEffect = source.lastEffect;
        target.expirationTime = source.expirationTime;
        target.childExpirationTime = source.childExpirationTime;
        target.alternate = source.alternate;

        if (enableProfilerTimer) {
          target.actualDuration = source.actualDuration;
          target.actualStartTime = source.actualStartTime;
          target.selfBaseDuration = source.selfBaseDuration;
          target.treeBaseDuration = source.treeBaseDuration;
        }

        target._debugID = source._debugID;
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
        return target;
      }

      function createFiberRoot(containerInfo, isConcurrent, hydrate) {
        var uninitializedFiber = createHostRootFiber(isConcurrent);
        var root = void 0;

        if (enableSchedulerTracing) {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            pingCache: null,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null,
            interactionThreadID: tracing.unstable_getThreadID(),
            memoizedInteractions: new Set(),
            pendingInteractionMap: new Map()
          };
        } else {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            pingCache: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null
          };
        }

        uninitializedFiber.stateNode = root;
        return root;
      }

      var lowPriorityWarning = function lowPriorityWarning() {};

      {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message = "Warning: " + format.replace(/%s/g, function () {
            return args[argIndex++];
          });

          if (typeof console !== "undefined") {
            console.warn(message);
          }

          try {
            throw new Error(message);
          } catch (x) {}
        };

        lowPriorityWarning = function lowPriorityWarning(condition, format) {
          if (format === undefined) {
            throw new Error("`lowPriorityWarning(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
          }
        };
      }
      var lowPriorityWarning$1 = lowPriorityWarning;
      var ReactStrictModeWarnings = {
        discardPendingWarnings: function discardPendingWarnings() {},
        flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},
        flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
        recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},
        recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
        recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
        flushLegacyContextWarning: function flushLegacyContextWarning() {}
      };
      {
        var LIFECYCLE_SUGGESTIONS = {
          UNSAFE_componentWillMount: "componentDidMount",
          UNSAFE_componentWillReceiveProps: "static getDerivedStateFromProps",
          UNSAFE_componentWillUpdate: "componentDidUpdate"
        };
        var pendingComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUnsafeLifecycleWarnings = new Map();
        var pendingLegacyContextWarning = new Map();
        var didWarnAboutDeprecatedLifecycles = new Set();
        var didWarnAboutUnsafeLifecycles = new Set();
        var didWarnAboutLegacyContext = new Set();

        var setToSortedString = function setToSortedString(set) {
          var array = [];
          set.forEach(function (value) {
            array.push(value);
          });
          return array.sort().join(", ");
        };

        ReactStrictModeWarnings.discardPendingWarnings = function () {
          pendingComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUnsafeLifecycleWarnings = new Map();
          pendingLegacyContextWarning = new Map();
        };

        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
          pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
            var lifecyclesWarningMessages = [];
            Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
              var lifecycleWarnings = lifecycleWarningsMap[lifecycle];

              if (lifecycleWarnings.length > 0) {
                var componentNames = new Set();
                lifecycleWarnings.forEach(function (fiber) {
                  componentNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                var formatted = lifecycle.replace("UNSAFE_", "");
                var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
                var sortedComponentNames = setToSortedString(componentNames);
                lifecyclesWarningMessages.push(formatted + ": Please update the following components to use " + (suggestion + " instead: " + sortedComponentNames));
              }
            });

            if (lifecyclesWarningMessages.length > 0) {
              var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
              warningWithoutStack$1(false, "Unsafe lifecycle methods were found within a strict-mode tree:%s" + "\n\n%s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, lifecyclesWarningMessages.join("\n\n"));
            }
          });
          pendingUnsafeLifecycleWarnings = new Map();
        };

        var findStrictRoot = function findStrictRoot(fiber) {
          var maybeStrictRoot = null;
          var node = fiber;

          while (node !== null) {
            if (node.mode & StrictMode) {
              maybeStrictRoot = node;
            }

            node = node.return;
          }

          return maybeStrictRoot;
        };

        ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
          if (pendingComponentWillMountWarnings.length > 0) {
            var uniqueNames = new Set();
            pendingComponentWillMountWarnings.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            lowPriorityWarning$1(false, "componentWillMount is deprecated and will be removed in the next major version. " + "Use componentDidMount instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillMount." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", sortedNames);
            pendingComponentWillMountWarnings = [];
          }

          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            var _uniqueNames = new Set();

            pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
              _uniqueNames.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames = setToSortedString(_uniqueNames);

            lowPriorityWarning$1(false, "componentWillReceiveProps is deprecated and will be removed in the next major version. " + "Use static getDerivedStateFromProps instead." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames);
            pendingComponentWillReceivePropsWarnings = [];
          }

          if (pendingComponentWillUpdateWarnings.length > 0) {
            var _uniqueNames2 = new Set();

            pendingComponentWillUpdateWarnings.forEach(function (fiber) {
              _uniqueNames2.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames2 = setToSortedString(_uniqueNames2);

            lowPriorityWarning$1(false, "componentWillUpdate is deprecated and will be removed in the next major version. " + "Use componentDidUpdate instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillUpdate." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames2);
            pendingComponentWillUpdateWarnings = [];
          }
        };

        ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
          if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
            return;
          }

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
        };

        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }

          var warningsForRoot = void 0;

          if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
            warningsForRoot = {
              UNSAFE_componentWillMount: [],
              UNSAFE_componentWillReceiveProps: [],
              UNSAFE_componentWillUpdate: []
            };
            pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
          } else {
            warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
          }

          var unsafeLifecycles = [];

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillMount");
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillReceiveProps");
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillUpdate");
          }

          if (unsafeLifecycles.length > 0) {
            unsafeLifecycles.forEach(function (lifecycle) {
              warningsForRoot[lifecycle].push(fiber);
            });
          }
        };

        ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }

          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
            if (warningsForRoot === undefined) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }

            warningsForRoot.push(fiber);
          }
        };

        ReactStrictModeWarnings.flushLegacyContextWarning = function () {
          pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
            var uniqueNames = new Set();
            fiberArray.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
            warningWithoutStack$1(false, "Legacy context API has been detected within a strict-mode tree: %s" + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, sortedNames);
          });
        };
      }
      var ReactFiberInstrumentation = {
        debugTool: null
      };
      var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

      function markPendingPriorityLevel(root, expirationTime) {
        root.didError = false;
        var earliestPendingTime = root.earliestPendingTime;

        if (earliestPendingTime === NoWork) {
          root.earliestPendingTime = root.latestPendingTime = expirationTime;
        } else {
          if (earliestPendingTime < expirationTime) {
            root.earliestPendingTime = expirationTime;
          } else {
            var latestPendingTime = root.latestPendingTime;

            if (latestPendingTime > expirationTime) {
              root.latestPendingTime = expirationTime;
            }
          }
        }

        findNextExpirationTimeToWorkOn(expirationTime, root);
      }

      function markCommittedPriorityLevels(root, earliestRemainingTime) {
        root.didError = false;

        if (earliestRemainingTime === NoWork) {
          root.earliestPendingTime = NoWork;
          root.latestPendingTime = NoWork;
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        if (earliestRemainingTime < root.latestPingedTime) {
          root.latestPingedTime = NoWork;
        }

        var latestPendingTime = root.latestPendingTime;

        if (latestPendingTime !== NoWork) {
          if (latestPendingTime > earliestRemainingTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            var earliestPendingTime = root.earliestPendingTime;

            if (earliestPendingTime > earliestRemainingTime) {
              root.earliestPendingTime = root.latestPendingTime;
            }
          }
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestRemainingTime < latestSuspendedTime) {
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        if (earliestRemainingTime > earliestSuspendedTime) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        findNextExpirationTimeToWorkOn(NoWork, root);
      }

      function hasLowerPriorityWork(root, erroredExpirationTime) {
        var latestPendingTime = root.latestPendingTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var latestPingedTime = root.latestPingedTime;
        return latestPendingTime !== NoWork && latestPendingTime < erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime < erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime < erroredExpirationTime;
      }

      function isPriorityLevelSuspended(root, expirationTime) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        return earliestSuspendedTime !== NoWork && expirationTime <= earliestSuspendedTime && expirationTime >= latestSuspendedTime;
      }

      function markSuspendedPriorityLevel(root, suspendedTime) {
        root.didError = false;
        clearPing(root, suspendedTime);
        var earliestPendingTime = root.earliestPendingTime;
        var latestPendingTime = root.latestPendingTime;

        if (earliestPendingTime === suspendedTime) {
          if (latestPendingTime === suspendedTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            root.earliestPendingTime = latestPendingTime;
          }
        } else if (latestPendingTime === suspendedTime) {
          root.latestPendingTime = earliestPendingTime;
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
        } else {
          if (earliestSuspendedTime < suspendedTime) {
            root.earliestSuspendedTime = suspendedTime;
          } else if (latestSuspendedTime > suspendedTime) {
            root.latestSuspendedTime = suspendedTime;
          }
        }

        findNextExpirationTimeToWorkOn(suspendedTime, root);
      }

      function markPingedPriorityLevel(root, pingedTime) {
        root.didError = false;
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime === NoWork || latestPingedTime > pingedTime) {
          root.latestPingedTime = pingedTime;
        }

        findNextExpirationTimeToWorkOn(pingedTime, root);
      }

      function clearPing(root, completedTime) {
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime >= completedTime) {
          root.latestPingedTime = NoWork;
        }
      }

      function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
        var earliestExpirationTime = renderExpirationTime;
        var earliestPendingTime = root.earliestPendingTime;
        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestPendingTime > earliestExpirationTime) {
          earliestExpirationTime = earliestPendingTime;
        }

        if (earliestSuspendedTime > earliestExpirationTime) {
          earliestExpirationTime = earliestSuspendedTime;
        }

        return earliestExpirationTime;
      }

      function didExpireAtExpirationTime(root, currentTime) {
        var expirationTime = root.expirationTime;

        if (expirationTime !== NoWork && currentTime <= expirationTime) {
          root.nextExpirationTimeToWorkOn = currentTime;
        }
      }

      function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var earliestPendingTime = root.earliestPendingTime;
        var latestPingedTime = root.latestPingedTime;
        var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;

        if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime < completedExpirationTime)) {
          nextExpirationTimeToWorkOn = latestSuspendedTime;
        }

        var expirationTime = nextExpirationTimeToWorkOn;

        if (expirationTime !== NoWork && earliestSuspendedTime > expirationTime) {
          expirationTime = earliestSuspendedTime;
        }

        root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
        root.expirationTime = expirationTime;
      }

      var warning = warningWithoutStack$1;
      {
        warning = function warning(condition, format) {
          if (condition) {
            return;
          }

          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();

          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          warningWithoutStack$1.apply(undefined, [false, format + "%s"].concat(args, [stack]));
        };
      }
      var warning$1 = warning;

      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function shallowEqual(objA, objB) {
        if (is(objA, objB)) {
          return true;
        }

        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }

        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);

        if (keysA.length !== keysB.length) {
          return false;
        }

        for (var i = 0; i < keysA.length; i++) {
          if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
          }
        }

        return true;
      }

      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = _extends({}, baseProps);

          var defaultProps = Component.defaultProps;

          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }

          return props;
        }

        return baseProps;
      }

      function readLazyComponentType(lazyComponent) {
        var status = lazyComponent._status;
        var result = lazyComponent._result;

        switch (status) {
          case Resolved:
            {
              var Component = result;
              return Component;
            }

          case Rejected:
            {
              var error = result;
              throw error;
            }

          case Pending:
            {
              var thenable = result;
              throw thenable;
            }

          default:
            {
              lazyComponent._status = Pending;
              var ctor = lazyComponent._ctor;

              var _thenable = ctor();

              _thenable.then(function (moduleObject) {
                if (lazyComponent._status === Pending) {
                  var defaultExport = moduleObject.default;
                  {
                    if (defaultExport === undefined) {
                      warning$1(false, "lazy: Expected the result of a dynamic import() call. " + "Instead received: %s\n\nYour code should look like: \n  " + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    }
                  }
                  lazyComponent._status = Resolved;
                  lazyComponent._result = defaultExport;
                }
              }, function (error) {
                if (lazyComponent._status === Pending) {
                  lazyComponent._status = Rejected;
                  lazyComponent._result = error;
                }
              });

              switch (lazyComponent._status) {
                case Resolved:
                  return lazyComponent._result;

                case Rejected:
                  throw lazyComponent._result;
              }

              lazyComponent._result = _thenable;
              throw _thenable;
            }
        }
      }

      var fakeInternalInstance = {};
      var isArray$1 = Array.isArray;
      var emptyRefsObject = new React.Component().refs;
      var didWarnAboutStateAssignmentForComponent = void 0;
      var didWarnAboutUninitializedState = void 0;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
      var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
      var didWarnAboutUndefinedDerivedState = void 0;
      var warnOnUndefinedDerivedState = void 0;
      var warnOnInvalidCallback = void 0;
      var didWarnAboutDirectlyAssigningPropsToState = void 0;
      var didWarnAboutContextTypeAndContextTypes = void 0;
      var didWarnAboutInvalidateContextType = void 0;
      {
        didWarnAboutStateAssignmentForComponent = new Set();
        didWarnAboutUninitializedState = new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
        didWarnAboutDirectlyAssigningPropsToState = new Set();
        didWarnAboutUndefinedDerivedState = new Set();
        didWarnAboutContextTypeAndContextTypes = new Set();
        didWarnAboutInvalidateContextType = new Set();
        var didWarnOnInvalidCallback = new Set();

        warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }

          var key = callerName + "_" + callback;

          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            warningWithoutStack$1(false, "%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        };

        warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentName(type) || "Component";

            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              warningWithoutStack$1(false, "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
            }
          }
        };

        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function value() {
            invariant(false, "_processChildContext is not available in React 16+. This likely " + "means you have multiple copies of React and are attempting to nest " + "a React 15 tree inside a React 16 tree using " + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + "to make sure you have only one copy of React (and ideally, switch " + "to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }

      function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress.memoizedState;
        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            getDerivedStateFromProps(nextProps, prevState);
          }
        }
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === undefined ? prevState : _extends({}, prevState, partialState);
        workInProgress.memoizedState = memoizedState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
          updateQueue.baseState = memoizedState;
        }
      }

      var classComponentUpdater = {
        isMounted: isMounted,
        enqueueSetState: function enqueueSetState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ReplaceState;
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ForceUpdate;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        }
      };

      function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress.stateNode;

        if (typeof instance.shouldComponentUpdate === "function") {
          startPhaseTimer(workInProgress, "shouldComponentUpdate");
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          stopPhaseTimer();
          {
            !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component") : void 0;
          }
          return shouldUpdate;
        }

        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }

        return true;
      }

      function checkClassInstance(workInProgress, ctor, newProps) {
        var instance = workInProgress.stateNode;
        {
          var name = getComponentName(ctor) || "Component";
          var renderPresent = instance.render;

          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
            } else {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
            }
          }

          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
          !noGetInitialStateOnES6 ? warningWithoutStack$1(false, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name) : void 0;
          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
          !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name) : void 0;
          var noInstancePropTypes = !instance.propTypes;
          !noInstancePropTypes ? warningWithoutStack$1(false, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name) : void 0;
          var noInstanceContextType = !instance.contextType;
          !noInstanceContextType ? warningWithoutStack$1(false, "contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name) : void 0;
          var noInstanceContextTypes = !instance.contextTypes;
          !noInstanceContextTypes ? warningWithoutStack$1(false, "contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name) : void 0;

          if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            warningWithoutStack$1(false, "%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name);
          }

          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== "function";
          !noComponentShouldUpdate ? warningWithoutStack$1(false, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name) : void 0;

          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            warningWithoutStack$1(false, "%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
          }

          var noComponentDidUnmount = typeof instance.componentDidUnmount !== "function";
          !noComponentDidUnmount ? warningWithoutStack$1(false, "%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name) : void 0;
          var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== "function";
          !noComponentDidReceiveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name) : void 0;
          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== "function";
          !noComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name) : void 0;
          var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== "function";
          !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name) : void 0;
          var hasMutatedProps = instance.props !== newProps;
          !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, "%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name) : void 0;
          var noInstanceDefaultProps = !instance.defaultProps;
          !noInstanceDefaultProps ? warningWithoutStack$1(false, "Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name) : void 0;

          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
          }

          var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== "function";
          !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, "%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== "function";
          !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, "%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== "function";
          !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name) : void 0;
          var _state = instance.state;

          if (_state && (typeof _state !== "object" || isArray$1(_state))) {
            warningWithoutStack$1(false, "%s.state: must be set to an object or null", name);
          }

          if (typeof instance.getChildContext === "function") {
            !(typeof ctor.childContextTypes === "object") ? warningWithoutStack$1(false, "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name) : void 0;
          }
        }
      }

      function adoptClassInstance(workInProgress, instance) {
        instance.updater = classComponentUpdater;
        workInProgress.stateNode = instance;
        set(instance, workInProgress);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }

      function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = null;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          {
            if (contextType.$$typeof !== REACT_CONTEXT_TYPE && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              warningWithoutStack$1(false, "%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext(). " + "Did you accidentally pass the Context.Provider instead?", getComponentName(ctor) || "Component");
            }
          }
          context = _readContext(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
        }

        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            new ctor(props, context);
          }
        }
        var instance = new ctor(props, context);
        var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
        adoptClassInstance(workInProgress, instance);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              warningWithoutStack$1(false, "`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }

          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;

            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }

            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }

            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }

            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentName(ctor) || "Component";

              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";

              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                warningWithoutStack$1(false, "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" + "The above lifecycles should be removed. Learn more about this warning here:\n" + "https://fb.me/react-async-component-lifecycle-hooks", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }

        if (isLegacyContextConsumer) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return instance;
      }

      function callComponentWillMount(workInProgress, instance) {
        startPhaseTimer(workInProgress, "componentWillMount");
        var oldState = instance.state;

        if (typeof instance.componentWillMount === "function") {
          instance.componentWillMount();
        }

        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }

        stopPhaseTimer();

        if (oldState !== instance.state) {
          {
            warningWithoutStack$1(false, "%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentName(workInProgress.type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        var oldState = instance.state;
        startPhaseTimer(workInProgress, "componentWillReceiveProps");

        if (typeof instance.componentWillReceiveProps === "function") {
          instance.componentWillReceiveProps(newProps, nextContext);
        }

        if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }

        stopPhaseTimer();

        if (instance.state !== oldState) {
          {
            var componentName = getComponentName(workInProgress.type) || "Component";

            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              warningWithoutStack$1(false, "%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        {
          checkClassInstance(workInProgress, ctor, newProps);
        }
        var instance = workInProgress.stateNode;
        instance.props = newProps;
        instance.state = workInProgress.memoizedState;
        instance.refs = emptyRefsObject;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          instance.context = _readContext(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          instance.context = getMaskedContext(workInProgress, unmaskedContext);
        }

        {
          if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              warningWithoutStack$1(false, "%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
          }

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);
          }
        }
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          instance.state = workInProgress.memoizedState;
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          instance.state = workInProgress.memoizedState;
        }

        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(workInProgress, instance);
          updateQueue = workInProgress.updateQueue;

          if (updateQueue !== null) {
            processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
            instance.state = workInProgress.memoizedState;
          }
        }

        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
      }

      function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = _readContext(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            startPhaseTimer(workInProgress, "componentWillMount");

            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }

            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }
        } else {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = _readContext(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
            startPhaseTimer(workInProgress, "componentWillUpdate");

            if (typeof instance.componentWillUpdate === "function") {
              instance.componentWillUpdate(newProps, newState, nextContext);
            }

            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidUpdate === "function") {
            workInProgress.effectTag |= Update;
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            workInProgress.effectTag |= Snapshot;
          }
        } else {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      var didWarnAboutMaps = void 0;
      var didWarnAboutGenerators = void 0;
      var didWarnAboutStringRefInStrictMode = void 0;
      var ownerHasKeyUseWarning = void 0;
      var ownerHasFunctionTypeWarning = void 0;

      var warnForMissingKey = function warnForMissingKey(child) {};

      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefInStrictMode = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};

        warnForMissingKey = function warnForMissingKey(child) {
          if (child === null || typeof child !== "object") {
            return;
          }

          if (!child._store || child._store.validated || child.key != null) {
            return;
          }

          invariant(typeof child._store === "object", "React Component in warnForMissingKey should have a _store. " + "This error is likely caused by a bug in React. Please file an issue.");
          child._store.validated = true;
          var currentComponentErrorInfo = "Each child in a list should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information." + getCurrentFiberStackInDev();

          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }

          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          warning$1(false, "Each child in a list should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information.");
        };
      }
      var isArray = Array.isArray;

      function coerceRef(returnFiber, current$$1, element) {
        var mixedRef = element.ref;

        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if (returnFiber.mode & StrictMode) {
              var componentName = getComponentName(returnFiber.type) || "Component";

              if (!didWarnAboutStringRefInStrictMode[componentName]) {
                warningWithoutStack$1(false, 'A string ref, "%s", has been found within a strict mode tree. ' + "String refs are a source of potential bugs and should be avoided. " + "We recommend using createRef() instead." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-string-ref", mixedRef, getStackByFiberInDevAndProd(returnFiber));
                didWarnAboutStringRefInStrictMode[componentName] = true;
              }
            }
          }

          if (element._owner) {
            var owner = element._owner;
            var inst = void 0;

            if (owner) {
              var ownerFiber = owner;
              invariant(ownerFiber.tag === ClassComponent, "Function components cannot have refs. " + "Did you mean to use React.forwardRef()?");
              inst = ownerFiber.stateNode;
            }

            invariant(inst, "Missing owner for string ref %s. This error is likely caused by a " + "bug in React. Please file an issue.", mixedRef);
            var stringRef = "" + mixedRef;

            if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === "function" && current$$1.ref._stringRef === stringRef) {
              return current$$1.ref;
            }

            var ref = function ref(value) {
              var refs = inst.refs;

              if (refs === emptyRefsObject) {
                refs = inst.refs = {};
              }

              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };

            ref._stringRef = stringRef;
            return ref;
          } else {
            invariant(typeof mixedRef === "string", "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" + " the following reasons:\n" + "1. You may be adding a ref to a function component\n" + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + "3. You have multiple copies of React loaded\n" + "See https://fb.me/react-refs-must-have-owner for more information.", mixedRef);
          }
        }

        return mixedRef;
      }

      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== "textarea") {
          var addendum = "";
          {
            addendum = " If you meant to render a collection of children, use an array " + "instead." + getCurrentFiberStackInDev();
          }
          invariant(false, "Objects are not valid as a React child (found: %s).%s", Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, addendum);
        }
      }

      function warnOnFunctionType() {
        var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it." + getCurrentFiberStackInDev();

        if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
        warning$1(false, "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
      }

      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }

          var last = returnFiber.lastEffect;

          if (last !== null) {
            last.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
          }

          childToDelete.nextEffect = null;
          childToDelete.effectTag = Deletion;
        }

        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }

          var childToDelete = currentFirstChild;

          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }

          return null;
        }

        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = new Map();
          var existingChild = currentFirstChild;

          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }

            existingChild = existingChild.sibling;
          }

          return existingChildren;
        }

        function useFiber(fiber, pendingProps, expirationTime) {
          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }

        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;

          if (!shouldTrackSideEffects) {
            return lastPlacedIndex;
          }

          var current$$1 = newFiber.alternate;

          if (current$$1 !== null) {
            var oldIndex = current$$1.index;

            if (oldIndex < lastPlacedIndex) {
              newFiber.effectTag = Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          }
        }

        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.effectTag = Placement;
          }

          return newFiber;
        }

        function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateElement(returnFiber, current$$1, element, expirationTime) {
          if (current$$1 !== null && current$$1.elementType === element.type) {
            var existing = useFiber(current$$1, element.props, expirationTime);
            existing.ref = coerceRef(returnFiber, current$$1, element);
            existing.return = returnFiber;
            {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          } else {
            var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
            created.ref = coerceRef(returnFiber, current$$1, element);
            created.return = returnFiber;
            return created;
          }
        }

        function updatePortal(returnFiber, current$$1, portal, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, portal.children || [], expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
          if (current$$1 === null || current$$1.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, fragment, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function createChild(returnFiber, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);

                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }

              case REACT_PORTAL_TYPE:
                {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);

                  _created2.return = returnFiber;
                  return _created2;
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);

              _created3.return = returnFiber;
              return _created3;
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
          var key = oldFiber !== null ? oldFiber.key : null;

          if (typeof newChild === "string" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }

            return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  if (newChild.key === key) {
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                    }

                    return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }

              case REACT_PORTAL_TYPE:
                {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }

              return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                  }

                  return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                }

              case REACT_PORTAL_TYPE:
                {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;

              return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function warnOnInvalidKey(child, knownKeys) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }

            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child);
                var key = child.key;

                if (typeof key !== "string") {
                  break;
                }

                if (knownKeys === null) {
                  knownKeys = new Set();
                  knownKeys.add(key);
                  break;
                }

                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }

                warning$1(false, "Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted — the behavior is unsupported and " + "could change in a future version.", key);
                break;

              default:
                break;
            }
          }
          return knownKeys;
        }

        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
          {
            var knownKeys = null;

            for (var i = 0; i < newChildren.length; i++) {
              var child = newChildren[i];
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;

          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);

              if (!_newFiber) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }

              previousNewFiber = _newFiber;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);

            if (_newFiber2) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }

              previousNewFiber = _newFiber2;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          invariant(typeof iteratorFn === "function", "An object is not an iterable. This error is likely caused by a bug in " + "React. Please file an issue.");
          {
            if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
              !didWarnAboutGenerators ? warning$1(false, "Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.") : void 0;
              didWarnAboutGenerators = true;
            }

            if (newChildrenIterable.entries === iteratorFn) {
              !didWarnAboutMaps ? warning$1(false, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.") : void 0;
              didWarnAboutMaps = true;
            }

            var _newChildren = iteratorFn.call(newChildrenIterable);

            if (_newChildren) {
              var knownKeys = null;

              var _step = _newChildren.next();

              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          invariant(newChildren != null, "An iterable object provided no iterator.");
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();

          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

            if (newFiber === null) {
              if (!oldFiber) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, expirationTime);

              if (_newFiber3 === null) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }

              previousNewFiber = _newFiber3;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);

            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }

              previousNewFiber = _newFiber4;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }

          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
          var key = element.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.elementType === element.type) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
                existing.ref = coerceRef(returnFiber, child, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
            created.return = returnFiber;
            return created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);

            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }

        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
          var key = portal.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || [], expirationTime);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }

          var isObject = typeof newChild === "object" && newChild !== null;

          if (isObject) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
            }
          }

          if (typeof newChild === "string" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
          }

          if (isArray(newChild)) {
            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (getIteratorFn(newChild)) {
            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (isObject) {
            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }

          if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
            switch (returnFiber.tag) {
              case ClassComponent:
                {
                  {
                    var instance = returnFiber.stateNode;

                    if (instance.render._isMockFunction) {
                      break;
                    }
                  }
                }

              case FunctionComponent:
                {
                  var Component = returnFiber.type;
                  invariant(false, "%s(...): Nothing was returned from render. This usually means a " + "return statement is missing. Or, to render nothing, " + "return null.", Component.displayName || Component.name || "Component");
                }
            }
          }

          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }

        return reconcileChildFibers;
      }

      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);

      function cloneChildFibers(current$$1, workInProgress) {
        invariant(current$$1 === null || workInProgress.child === current$$1.child, "Resuming work not yet implemented.");

        if (workInProgress.child === null) {
          return;
        }

        var currentChild = workInProgress.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
        workInProgress.child = newChild;
        newChild.return = workInProgress;

        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
          newChild.return = workInProgress;
        }

        newChild.sibling = null;
      }

      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);

      function requiredContext(c) {
        invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug " + "in React. Please file an issue.");
        return c;
      }

      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }

      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }

      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }

      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }

      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type, rootInstance);

        if (context === nextContext) {
          return;
        }

        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }

      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }

        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }

      var NoEffect$1 = 0;
      var UnmountSnapshot = 2;
      var UnmountMutation = 4;
      var MountMutation = 8;
      var UnmountLayout = 16;
      var MountLayout = 32;
      var MountPassive = 64;
      var UnmountPassive = 128;
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var didWarnAboutMismatchedHooksForComponent = void 0;
      {
        didWarnAboutMismatchedHooksForComponent = new Set();
      }
      var renderExpirationTime = NoWork;
      var currentlyRenderingFiber$1 = null;
      var firstCurrentHook = null;
      var currentHook = null;
      var nextCurrentHook = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var nextWorkInProgressHook = null;
      var remainingExpirationTime = NoWork;
      var componentUpdateQueue = null;
      var sideEffectTag = 0;
      var didScheduleRenderPhaseUpdate = false;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var currentHookNameInDev = null;

      function warnOnHookMismatchInDev() {
        {
          var componentName = getComponentName(currentlyRenderingFiber$1.type);

          if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            var secondColumnStart = 22;
            var table = "";
            var prevHook = firstCurrentHook;
            var nextHook = firstWorkInProgressHook;
            var n = 1;

            while (prevHook !== null && nextHook !== null) {
              var oldHookName = prevHook._debugType;
              var newHookName = nextHook._debugType;
              var row = n + ". " + oldHookName;

              while (row.length < secondColumnStart) {
                row += " ";
              }

              row += newHookName + "\n";
              table += row;
              prevHook = prevHook.next;
              nextHook = nextHook.next;
              n++;
            }

            warning$1(false, "React has detected a change in the order of Hooks called by %s. " + "This will lead to bugs and errors if not fixed. " + "For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n" + "   Previous render    Next render\n" + "   -------------------------------\n" + "%s" + "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
          }
        }
      }

      function throwInvalidHookError() {
        invariant(false, "Hooks can only be called inside the body of a function component. " + "(https://fb.me/react-invalid-hook-call)");
      }

      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            warning$1(false, "%s received a final argument during this render, but not during " + "the previous render. Even though the final argument is optional, " + "its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }

        {
          if (nextDeps.length !== prevDeps.length) {
            warning$1(false, "The final argument passed to %s changed size between renders. The " + "order and size of this array must remain constant.\n\n" + "Previous: %s\n" + "Incoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }

        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (is(nextDeps[i], prevDeps[i])) {
            continue;
          }

          return false;
        }

        return true;
      }

      function renderWithHooks(current, workInProgress, Component, props, refOrContext, nextRenderExpirationTime) {
        renderExpirationTime = nextRenderExpirationTime;
        currentlyRenderingFiber$1 = workInProgress;
        firstCurrentHook = nextCurrentHook = current !== null ? current.memoizedState : null;
        {
          ReactCurrentDispatcher$1.current = nextCurrentHook === null ? HooksDispatcherOnMountInDEV : HooksDispatcherOnUpdateInDEV;
        }
        var children = Component(props, refOrContext);

        if (didScheduleRenderPhaseUpdate) {
          do {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            firstCurrentHook = nextCurrentHook = current !== null ? current.memoizedState : null;
            nextWorkInProgressHook = firstWorkInProgressHook;
            currentHook = null;
            workInProgressHook = null;
            componentUpdateQueue = null;
            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            children = Component(props, refOrContext);
          } while (didScheduleRenderPhaseUpdate);

          renderPhaseUpdates = null;
          numberOfReRenders = 0;
        }

        {
          currentHookNameInDev = null;
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        var renderedWork = currentlyRenderingFiber$1;
        renderedWork.memoizedState = firstWorkInProgressHook;
        renderedWork.expirationTime = remainingExpirationTime;
        renderedWork.updateQueue = componentUpdateQueue;
        renderedWork.effectTag |= sideEffectTag;
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        nextCurrentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        nextWorkInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        sideEffectTag = 0;
        invariant(!didRenderTooFewHooks, "Rendered fewer hooks than expected. This may be caused by an accidental " + "early return statement.");
        return children;
      }

      function bailoutHooks(current, workInProgress, expirationTime) {
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.effectTag &= ~(Passive | Update);

        if (current.expirationTime <= expirationTime) {
          current.expirationTime = NoWork;
        }
      }

      function resetHooks() {
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        nextCurrentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        nextWorkInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        sideEffectTag = 0;
        {
          currentHookNameInDev = null;
        }
        didScheduleRenderPhaseUpdate = false;
        renderPhaseUpdates = null;
        numberOfReRenders = 0;
      }

      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          queue: null,
          baseUpdate: null,
          next: null
        };
        {
          hook._debugType = currentHookNameInDev;
        }

        if (workInProgressHook === null) {
          firstWorkInProgressHook = workInProgressHook = hook;
        } else {
          workInProgressHook = workInProgressHook.next = hook;
        }

        return workInProgressHook;
      }

      function updateWorkInProgressHook() {
        if (nextWorkInProgressHook !== null) {
          workInProgressHook = nextWorkInProgressHook;
          nextWorkInProgressHook = workInProgressHook.next;
          currentHook = nextCurrentHook;
          nextCurrentHook = currentHook !== null ? currentHook.next : null;
        } else {
          invariant(nextCurrentHook !== null, "Rendered more hooks than during the previous render.");
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            queue: currentHook.queue,
            baseUpdate: currentHook.baseUpdate,
            next: null
          };

          if (workInProgressHook === null) {
            workInProgressHook = firstWorkInProgressHook = newHook;
          } else {
            workInProgressHook = workInProgressHook.next = newHook;
          }

          nextCurrentHook = currentHook.next;
          {
            newHook._debugType = currentHookNameInDev;

            if (currentHookNameInDev !== currentHook._debugType) {
              warnOnHookMismatchInDev();
            }
          }
        }

        return workInProgressHook;
      }

      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null
        };
      }

      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }

      function mountContext(context, observedBits) {
        {
          mountWorkInProgressHook();
        }
        return _readContext(context, observedBits);
      }

      function updateContext(context, observedBits) {
        {
          updateWorkInProgressHook();
        }
        return _readContext(context, observedBits);
      }

      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState = void 0;

        if (init !== undefined) {
          initialState = init(initialArg);
        } else {
          initialState = initialArg;
        }

        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
          last: null,
          dispatch: null,
          eagerReducer: reducer,
          eagerState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }

      function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        invariant(queue !== null, "Should have a queue. This is likely a bug in React. Please file an issue.");

        if (numberOfReRenders > 0) {
          var _dispatch = queue.dispatch;

          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue);
              var newState = hook.memoizedState;
              var update = firstRenderPhaseUpdate;

              do {
                var _action = update.action;
                newState = reducer(newState, _action);
                update = update.next;
              } while (update !== null);

              if (!is(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }

              hook.memoizedState = newState;

              if (hook.baseUpdate === queue.last) {
                hook.baseState = newState;
              }

              queue.eagerReducer = reducer;
              queue.eagerState = newState;
              return [newState, _dispatch];
            }
          }

          return [hook.memoizedState, _dispatch];
        }

        var last = queue.last;
        var baseUpdate = hook.baseUpdate;
        var baseState = hook.baseState;
        var first = void 0;

        if (baseUpdate !== null) {
          if (last !== null) {
            last.next = null;
          }

          first = baseUpdate.next;
        } else {
          first = last !== null ? last.next : null;
        }

        if (first !== null) {
          var _newState = baseState;
          var newBaseState = null;
          var newBaseUpdate = null;
          var prevUpdate = baseUpdate;
          var _update = first;
          var didSkip = false;

          do {
            var updateExpirationTime = _update.expirationTime;

            if (updateExpirationTime < renderExpirationTime) {
              if (!didSkip) {
                didSkip = true;
                newBaseUpdate = prevUpdate;
                newBaseState = _newState;
              }

              if (updateExpirationTime > remainingExpirationTime) {
                remainingExpirationTime = updateExpirationTime;
              }
            } else {
              if (_update.eagerReducer === reducer) {
                _newState = _update.eagerState;
              } else {
                var _action2 = _update.action;
                _newState = reducer(_newState, _action2);
              }
            }

            prevUpdate = _update;
            _update = _update.next;
          } while (_update !== null && _update !== first);

          if (!didSkip) {
            newBaseUpdate = prevUpdate;
            newBaseState = _newState;
          }

          if (!is(_newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }

          hook.memoizedState = _newState;
          hook.baseUpdate = newBaseUpdate;
          hook.baseState = newBaseState;
          queue.eagerReducer = reducer;
          queue.eagerState = _newState;
        }

        var dispatch = queue.dispatch;
        return [hook.memoizedState, dispatch];
      }

      function mountState(initialState) {
        var hook = mountWorkInProgressHook();

        if (typeof initialState === "function") {
          initialState = initialState();
        }

        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
          last: null,
          dispatch: null,
          eagerReducer: basicStateReducer,
          eagerState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }

      function updateState(initialState) {
        return updateReducer(basicStateReducer, initialState);
      }

      function pushEffect(tag, create, destroy, deps) {
        var effect = {
          tag: tag,
          create: create,
          destroy: destroy,
          deps: deps,
          next: null
        };

        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var _lastEffect = componentUpdateQueue.lastEffect;

          if (_lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = _lastEffect.next;
            _lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }

        return effect;
      }

      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        var ref = {
          current: initialValue
        };
        {
          Object.seal(ref);
        }
        hook.memoizedState = ref;
        return ref;
      }

      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }

      function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        sideEffectTag |= fiberEffectTag;
        hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);
      }

      function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var destroy = undefined;

        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;

          if (nextDeps !== null) {
            var prevDeps = prevEffect.deps;

            if (areHookInputsEqual(nextDeps, prevDeps)) {
              pushEffect(NoEffect$1, create, destroy, nextDeps);
              return;
            }
          }
        }

        sideEffectTag |= fiberEffectTag;
        hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);
      }

      function mountEffect(create, deps) {
        return mountEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
      }

      function updateEffect(create, deps) {
        return updateEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
      }

      function mountLayoutEffect(create, deps) {
        return mountEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
      }

      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
      }

      function imperativeHandleEffect(create, ref) {
        if (typeof ref === "function") {
          var refCallback = ref;

          var _inst = create();

          refCallback(_inst);
          return function () {
            refCallback(null);
          };
        } else if (ref !== null && ref !== undefined) {
          var refObject = ref;
          {
            !refObject.hasOwnProperty("current") ? warning$1(false, "Expected useImperativeHandle() first argument to either be a " + "ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}") : void 0;
          }

          var _inst2 = create();

          refObject.current = _inst2;
          return function () {
            refObject.current = null;
          };
        }
      }

      function mountImperativeHandle(ref, create, deps) {
        {
          !(typeof create === "function") ? warning$1(false, "Expected useImperativeHandle() second argument to be a function " + "that creates a handle. Instead received: %s.", create !== null ? typeof create : "null") : void 0;
        }
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
        return mountEffectImpl(Update, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }

      function updateImperativeHandle(ref, create, deps) {
        {
          !(typeof create === "function") ? warning$1(false, "Expected useImperativeHandle() second argument to be a function " + "that creates a handle. Instead received: %s.", create !== null ? typeof create : "null") : void 0;
        }
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
        return updateEffectImpl(Update, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }

      function mountDebugValue(value, formatterFn) {}

      var updateDebugValue = mountDebugValue;

      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }

      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;

        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];

            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }

        hook.memoizedState = [callback, nextDeps];
        return callback;
      }

      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }

      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;

        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];

            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }

        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }

      var shouldWarnForUnbatchedSetState = false;
      {
        if ("undefined" !== typeof jest) {
          shouldWarnForUnbatchedSetState = true;
        }
      }

      function dispatchAction(fiber, queue, action) {
        invariant(numberOfReRenders < RE_RENDER_LIMIT, "Too many re-renders. React limits the number of renders to prevent " + "an infinite loop.");
        {
          !(arguments.length <= 3) ? warning$1(false, "State updates from the useState() and useReducer() Hooks don't support the " + "second callback argument. To execute a side effect after " + "rendering, declare it in the component body with useEffect().") : void 0;
        }
        var alternate = fiber.alternate;

        if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            expirationTime: renderExpirationTime,
            action: action,
            eagerReducer: null,
            eagerState: null,
            next: null
          };

          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map();
          }

          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }

            lastRenderPhaseUpdate.next = update;
          }
        } else {
          flushPassiveEffects();
          var currentTime = requestCurrentTime();

          var _expirationTime = computeExpirationForFiber(currentTime, fiber);

          var _update2 = {
            expirationTime: _expirationTime,
            action: action,
            eagerReducer: null,
            eagerState: null,
            next: null
          };
          var _last = queue.last;

          if (_last === null) {
            _update2.next = _update2;
          } else {
            var first = _last.next;

            if (first !== null) {
              _update2.next = first;
            }

            _last.next = _update2;
          }

          queue.last = _update2;

          if (fiber.expirationTime === NoWork && (alternate === null || alternate.expirationTime === NoWork)) {
            var _eagerReducer = queue.eagerReducer;

            if (_eagerReducer !== null) {
              var prevDispatcher = void 0;
              {
                prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              }

              try {
                var currentState = queue.eagerState;

                var _eagerState = _eagerReducer(currentState, action);

                _update2.eagerReducer = _eagerReducer;
                _update2.eagerState = _eagerState;

                if (is(_eagerState, currentState)) {
                  return;
                }
              } catch (error) {} finally {
                {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              }
            }
          }

          {
            if (shouldWarnForUnbatchedSetState === true) {
              warnIfNotCurrentlyBatchingInDev(fiber);
            }
          }
          scheduleWork(fiber, _expirationTime);
        }
      }

      var ContextOnlyDispatcher = {
        readContext: _readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError
      };
      var HooksDispatcherOnMountInDEV = null;
      var HooksDispatcherOnUpdateInDEV = null;
      var InvalidNestedHooksDispatcherOnMountInDEV = null;
      var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
      {
        var warnInvalidContextAccess = function warnInvalidContextAccess() {
          warning$1(false, "Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
        };

        var warnInvalidHookAccess = function warnInvalidHookAccess() {
          warning$1(false, "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " + "You can only call Hooks at the top level of your React function. " + "For more information, see " + "https://fb.me/rules-of-hooks");
        };

        HooksDispatcherOnMountInDEV = {
          readContext: function readContext(context, observedBits) {
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            return mountCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            return mountContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            return mountEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            return mountImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            return mountLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            return mountRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            return mountDebugValue(value, formatterFn);
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function readContext(context, observedBits) {
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            return updateCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            return updateContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            return updateEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            return updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            return updateLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            return updateRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            return updateDebugValue(value, formatterFn);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function readContext(context, observedBits) {
            warnInvalidContextAccess();
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            return mountCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            return mountContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            return mountImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            return mountRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            return mountDebugValue(value, formatterFn);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function readContext(context, observedBits) {
            warnInvalidContextAccess();
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            return updateCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            return updateContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            return updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            return updateRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            return updateDebugValue(value, formatterFn);
          }
        };
      }
      var commitTime = 0;
      var profilerStartTime = -1;

      function getCommitTime() {
        return commitTime;
      }

      function recordCommitTime() {
        if (!enableProfilerTimer) {
          return;
        }

        commitTime = now$$1();
      }

      function startProfilerTimer(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = now$$1();

        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now$$1();
        }
      }

      function stopProfilerTimerIfRunning(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = -1;
      }

      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (!enableProfilerTimer) {
          return;
        }

        if (profilerStartTime >= 0) {
          var elapsedTime = now$$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime;

          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }

          profilerStartTime = -1;
        }
      }

      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;

      function enterHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChild(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        return true;
      }

      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber) {
        if (!supportsHydration) {
          return false;
        }

        var suspenseInstance = fiber.stateNode;
        nextHydratableInstance = getNextHydratableSibling(suspenseInstance);
        popToNextHostParent(fiber);
        isHydrating = true;
        return true;
      }

      function deleteHydratableInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot:
              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
              break;

            case HostComponent:
              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
              break;
          }
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        childToDelete.effectTag = Deletion;

        if (returnFiber.lastEffect !== null) {
          returnFiber.lastEffect.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }
      }

      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.effectTag |= Placement;
        {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;

                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableContainerInstance(parentContainer, type, props);
                    break;

                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableContainerTextInstance(parentContainer, text);
                    break;

                  case SuspenseComponent:
                    didNotFindHydratableContainerSuspenseInstance(parentContainer);
                    break;
                }

                break;
              }

            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;

                switch (fiber.tag) {
                  case HostComponent:
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                    break;

                  case HostText:
                    var _text = fiber.pendingProps;
                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                    break;

                  case SuspenseComponent:
                    didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);
                    break;
                }

                break;
              }

            default:
              return;
          }
        }
      }

      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent:
            {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type, props);

              if (instance !== null) {
                fiber.stateNode = instance;
                return true;
              }

              return false;
            }

          case HostText:
            {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);

              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                return true;
              }

              return false;
            }

          case SuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);

                if (suspenseInstance !== null) {
                  fiber.tag = DehydratedSuspenseComponent;
                  fiber.stateNode = suspenseInstance;
                  return true;
                }
              }

              return false;
            }

          default:
            return false;
        }
      }

      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }

        var nextInstance = nextHydratableInstance;

        if (!nextInstance) {
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }

        var firstAttemptedInstance = nextInstance;

        if (!tryHydrate(fiber, nextInstance)) {
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);

          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }

          deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
        }

        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
      }

      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var instance = fiber.stateNode;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
        fiber.updateQueue = updatePayload;

        if (updatePayload !== null) {
          return true;
        }

        return false;
      }

      function prepareToHydrateHostTextInstance(fiber) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostTextInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        {
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;

            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot:
                  {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                  }

                case HostComponent:
                  {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
                  }
              }
            }
          }
        }
        return shouldUpdate;
      }

      function skipPastDehydratedSuspenseInstance(fiber) {
        if (!supportsHydration) {
          invariant(false, "Expected skipPastDehydratedSuspenseInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var suspenseInstance = fiber.stateNode;
        invariant(suspenseInstance, "Expected to have a hydrated suspense instance. " + "This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }

      function popToNextHostParent(fiber) {
        var parent = fiber.return;

        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== DehydratedSuspenseComponent) {
          parent = parent.return;
        }

        hydrationParentFiber = parent;
      }

      function popHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        if (fiber !== hydrationParentFiber) {
          return false;
        }

        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }

        var type = fiber.type;

        if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
          var nextInstance = nextHydratableInstance;

          while (nextInstance) {
            deleteHydratableInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }

        popToNextHostParent(fiber);
        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
      }

      function resetHydrationState() {
        if (!supportsHydration) {
          return;
        }

        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
      }

      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var didReceiveUpdate = false;
      var didWarnAboutBadClass = void 0;
      var didWarnAboutContextTypeOnFunctionComponent = void 0;
      var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
      var didWarnAboutFunctionRefs = void 0;
      var didWarnAboutReassigningProps = void 0;
      {
        didWarnAboutBadClass = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
        didWarnAboutReassigningProps = false;
      }

      function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        if (current$$1 === null) {
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
        }
      }

      function forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime);
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      }

      function updateForwardRef(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
            }
          }
        }
        var render = Component.render;
        var ref = workInProgress.ref;
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = renderWithHooks(current$$1, workInProgress, render, nextProps, ref, renderExpirationTime);

          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            if (workInProgress.memoizedState !== null) {
              nextChildren = renderWithHooks(current$$1, workInProgress, render, nextProps, ref, renderExpirationTime);
            }
          }

          setCurrentPhase(null);
        }

        if (current$$1 !== null && !didReceiveUpdate) {
          bailoutHooks(current$$1, workInProgress, renderExpirationTime);
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        if (current$$1 === null) {
          var type = Component.type;

          if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === undefined) {
            workInProgress.tag = SimpleMemoComponent;
            workInProgress.type = type;
            {
              validateFunctionComponentInDev(workInProgress, type);
            }
            return updateSimpleMemoComponent(current$$1, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
          }

          {
            var innerPropTypes = type.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(type), getCurrentFiberStackInDev);
            }
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
          child.ref = workInProgress.ref;
          child.return = workInProgress;
          workInProgress.child = child;
          return child;
        }

        {
          var _type = Component.type;
          var _innerPropTypes = _type.propTypes;

          if (_innerPropTypes) {
            checkPropTypes(_innerPropTypes, nextProps, "prop", getComponentName(_type), getCurrentFiberStackInDev);
          }
        }
        var currentChild = current$$1.child;

        if (updateExpirationTime < renderExpirationTime) {
          var prevProps = currentChild.memoizedProps;
          var compare = Component.compare;
          compare = compare !== null ? compare : shallowEqual;

          if (compare(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        workInProgress.effectTag |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps, renderExpirationTime);
        newChild.ref = workInProgress.ref;
        newChild.return = workInProgress;
        workInProgress.child = newChild;
        return newChild;
      }

      function updateSimpleMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerMemoType = workInProgress.elementType;

            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
              outerMemoType = refineResolvedLazyComponent(outerMemoType);
            }

            var outerPropTypes = outerMemoType && outerMemoType.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, nextProps, "prop", getComponentName(outerMemoType), getCurrentFiberStackInDev);
            }
          }
        }

        if (current$$1 !== null) {
          var prevProps = current$$1.memoizedProps;

          if (shallowEqual(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            didReceiveUpdate = false;

            if (updateExpirationTime < renderExpirationTime) {
              return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            }
          }
        }

        return updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
      }

      function updateFragment(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMode(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
        if (enableProfilerTimer) {
          workInProgress.effectTag |= Update;
        }

        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function markRef(current$$1, workInProgress) {
        var ref = workInProgress.ref;

        if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {
          workInProgress.effectTag |= Ref;
        }
      }

      function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
            }
          }
        }
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = renderWithHooks(current$$1, workInProgress, Component, nextProps, context, renderExpirationTime);

          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            if (workInProgress.memoizedState !== null) {
              nextChildren = renderWithHooks(current$$1, workInProgress, Component, nextProps, context, renderExpirationTime);
            }
          }

          setCurrentPhase(null);
        }

        if (current$$1 !== null && !didReceiveUpdate) {
          bailoutHooks(current$$1, workInProgress, renderExpirationTime);
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
            }
          }
        }
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        var instance = workInProgress.stateNode;
        var shouldUpdate = void 0;

        if (instance === null) {
          if (current$$1 !== null) {
            current$$1.alternate = null;
            workInProgress.alternate = null;
            workInProgress.effectTag |= Placement;
          }

          constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          shouldUpdate = true;
        } else if (current$$1 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        } else {
          shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
        }

        var nextUnitOfWork = finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
        {
          var inst = workInProgress.stateNode;

          if (inst.props !== nextProps) {
            !didWarnAboutReassigningProps ? warning$1(false, "It looks like %s is reassigning its own `this.props` while rendering. " + "This is not supported and can lead to confusing bugs.", getComponentName(workInProgress.type) || "a component") : void 0;
            didWarnAboutReassigningProps = true;
          }
        }
        return nextUnitOfWork;
      }

      function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
        markRef(current$$1, workInProgress);
        var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress, Component, false);
          }

          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var instance = workInProgress.stateNode;
        ReactCurrentOwner$3.current = workInProgress;
        var nextChildren = void 0;

        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;

          if (enableProfilerTimer) {
            stopProfilerTimerIfRunning(workInProgress);
          }
        } else {
          {
            setCurrentPhase("render");
            nextChildren = instance.render();

            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              instance.render();
            }

            setCurrentPhase(null);
          }
        }

        workInProgress.effectTag |= PerformedWork;

        if (current$$1 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        workInProgress.memoizedState = instance.state;

        if (hasContext) {
          invalidateContextProvider(workInProgress, Component, true);
        }

        return workInProgress.child;
      }

      function pushHostRootContext(workInProgress) {
        var root = workInProgress.stateNode;

        if (root.pendingContext) {
          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
        } else if (root.context) {
          pushTopLevelContextObject(workInProgress, root.context, false);
        }

        pushHostContainer(workInProgress, root.containerInfo);
      }

      function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
        pushHostRootContext(workInProgress);
        var updateQueue = workInProgress.updateQueue;
        invariant(updateQueue !== null, "If the root does not have an updateQueue, we should have already " + "bailed out. This error is likely caused by a bug in React. Please " + "file an issue.");
        var nextProps = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        var prevChildren = prevState !== null ? prevState.element : null;
        processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
        var nextState = workInProgress.memoizedState;
        var nextChildren = nextState.element;

        if (nextChildren === prevChildren) {
          resetHydrationState();
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var root = workInProgress.stateNode;

        if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
          workInProgress.effectTag |= Placement;
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
          resetHydrationState();
        }

        return workInProgress.child;
      }

      function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContext(workInProgress);

        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        var type = workInProgress.type;
        var nextProps = workInProgress.pendingProps;
        var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);

        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress.effectTag |= ContentReset;
        }

        markRef(current$$1, workInProgress);

        if (renderExpirationTime !== Never && workInProgress.mode & ConcurrentMode && shouldDeprioritizeSubtree(type, nextProps)) {
          workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
          return null;
        }

        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateHostText(current$$1, workInProgress) {
        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        return null;
      }

      function mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        cancelWorkTimer(workInProgress);
        var Component = readLazyComponentType(elementType);
        workInProgress.type = Component;
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
        startWorkTimer(workInProgress);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child = void 0;

        switch (resolvedTag) {
          case FunctionComponent:
            {
              {
                validateFunctionComponentInDev(workInProgress, Component);
              }
              child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ClassComponent:
            {
              child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ForwardRef:
            {
              child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case MemoComponent:
            {
              {
                if (workInProgress.type !== workInProgress.elementType) {
                  var outerPropTypes = Component.propTypes;

                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, resolvedProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
                  }
                }
              }
              child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), updateExpirationTime, renderExpirationTime);
              break;
            }

          default:
            {
              var hint = "";
              {
                if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
                  hint = " Did you wrap a component in React.lazy() more than once?";
                }
              }
              invariant(false, "Element type is invalid. Received a promise that resolves to: %s. " + "Lazy element type must resolve to a class or function.%s", Component, hint);
            }
        }

        return child;
      }

      function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        workInProgress.tag = ClassComponent;
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
      }

      function mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        prepareToReadContext(workInProgress, renderExpirationTime);
        var value = void 0;
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentName(Component) || "Unknown";

            if (!didWarnAboutBadClass[componentName]) {
              warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
          }

          ReactCurrentOwner$3.current = workInProgress;
          value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);
        }
        workInProgress.effectTag |= PerformedWork;

        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          workInProgress.tag = ClassComponent;
          resetHooks();
          var hasContext = false;

          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
          } else {
            hasContext = false;
          }

          workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;

          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
          }

          adoptClassInstance(workInProgress, value);
          mountClassInstance(workInProgress, Component, props, renderExpirationTime);
          return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
        } else {
          workInProgress.tag = FunctionComponent;
          {
            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              if (workInProgress.memoizedState !== null) {
                value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);
              }
            }
          }
          reconcileChildren(null, workInProgress, value, renderExpirationTime);
          {
            validateFunctionComponentInDev(workInProgress, Component);
          }
          return workInProgress.child;
        }
      }

      function validateFunctionComponentInDev(workInProgress, Component) {
        if (Component) {
          !!Component.childContextTypes ? warningWithoutStack$1(false, "%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component") : void 0;
        }

        if (workInProgress.ref !== null) {
          var info = "";
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();

          if (ownerName) {
            info += "\n\nCheck the render method of `" + ownerName + "`.";
          }

          var warningKey = ownerName || workInProgress._debugID || "";
          var debugSource = workInProgress._debugSource;

          if (debugSource) {
            warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
          }

          if (!didWarnAboutFunctionRefs[warningKey]) {
            didWarnAboutFunctionRefs[warningKey] = true;
            warning$1(false, "Function components cannot be given refs. " + "Attempts to access this ref will fail. " + "Did you mean to use React.forwardRef()?%s", info);
          }
        }

        if (typeof Component.getDerivedStateFromProps === "function") {
          var componentName = getComponentName(Component) || "Unknown";

          if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {
            warningWithoutStack$1(false, "%s: Function components do not support getDerivedStateFromProps.", componentName);
            didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;
          }
        }

        if (typeof Component.contextType === "object" && Component.contextType !== null) {
          var _componentName = getComponentName(Component) || "Unknown";

          if (!didWarnAboutContextTypeOnFunctionComponent[_componentName]) {
            warningWithoutStack$1(false, "%s: Function components do not support contextType.", _componentName);
            didWarnAboutContextTypeOnFunctionComponent[_componentName] = true;
          }
        }
      }

      function updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
        var mode = workInProgress.mode;
        var nextProps = workInProgress.pendingProps;
        var nextState = workInProgress.memoizedState;
        var nextDidTimeout = void 0;

        if ((workInProgress.effectTag & DidCapture) === NoEffect) {
          nextState = null;
          nextDidTimeout = false;
        } else {
          nextState = {
            timedOutAt: nextState !== null ? nextState.timedOutAt : NoWork
          };
          nextDidTimeout = true;
          workInProgress.effectTag &= ~DidCapture;
        }

        var child = void 0;
        var next = void 0;

        if (current$$1 === null) {
          if (enableSuspenseServerRenderer) {
            if (nextProps.fallback !== undefined) {
              tryToClaimNextHydratableInstance(workInProgress);

              if (workInProgress.tag === DehydratedSuspenseComponent) {
                return updateDehydratedSuspenseComponent(null, workInProgress, renderExpirationTime);
              }
            }
          }

          if (nextDidTimeout) {
            var nextFallbackChildren = nextProps.fallback;
            var primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);

            if ((workInProgress.mode & ConcurrentMode) === NoContext) {
              var progressedState = workInProgress.memoizedState;
              var progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;
              primaryChildFragment.child = progressedPrimaryChild;
            }

            var fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);
            primaryChildFragment.sibling = fallbackChildFragment;
            child = primaryChildFragment;
            next = fallbackChildFragment;
            child.return = next.return = workInProgress;
          } else {
            var nextPrimaryChildren = nextProps.children;
            child = next = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime);
          }
        } else {
          var prevState = current$$1.memoizedState;
          var prevDidTimeout = prevState !== null;

          if (prevDidTimeout) {
            var currentPrimaryChildFragment = current$$1.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;

            if (nextDidTimeout) {
              var _nextFallbackChildren = nextProps.fallback;

              var _primaryChildFragment = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps, NoWork);

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState = workInProgress.memoizedState;

                var _progressedPrimaryChild = _progressedState !== null ? workInProgress.child.child : workInProgress.child;

                if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
                  _primaryChildFragment.child = _progressedPrimaryChild;
                }
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var treeBaseDuration = 0;
                var hiddenChild = _primaryChildFragment.child;

                while (hiddenChild !== null) {
                  treeBaseDuration += hiddenChild.treeBaseDuration;
                  hiddenChild = hiddenChild.sibling;
                }

                _primaryChildFragment.treeBaseDuration = treeBaseDuration;
              }

              var _fallbackChildFragment = _primaryChildFragment.sibling = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren, currentFallbackChildFragment.expirationTime);

              child = _primaryChildFragment;
              _primaryChildFragment.childExpirationTime = NoWork;
              next = _fallbackChildFragment;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren = nextProps.children;
              var currentPrimaryChild = currentPrimaryChildFragment.child;
              var primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime);
              child = next = primaryChild;
            }
          } else {
            var _currentPrimaryChild = current$$1.child;

            if (nextDidTimeout) {
              var _nextFallbackChildren2 = nextProps.fallback;

              var _primaryChildFragment2 = createFiberFromFragment(null, mode, NoWork, null);

              _primaryChildFragment2.child = _currentPrimaryChild;

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState2 = workInProgress.memoizedState;

                var _progressedPrimaryChild2 = _progressedState2 !== null ? workInProgress.child.child : workInProgress.child;

                _primaryChildFragment2.child = _progressedPrimaryChild2;
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var _treeBaseDuration = 0;
                var _hiddenChild = _primaryChildFragment2.child;

                while (_hiddenChild !== null) {
                  _treeBaseDuration += _hiddenChild.treeBaseDuration;
                  _hiddenChild = _hiddenChild.sibling;
                }

                _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
              }

              var _fallbackChildFragment2 = _primaryChildFragment2.sibling = createFiberFromFragment(_nextFallbackChildren2, mode, renderExpirationTime, null);

              _fallbackChildFragment2.effectTag |= Placement;
              child = _primaryChildFragment2;
              _primaryChildFragment2.childExpirationTime = NoWork;
              next = _fallbackChildFragment2;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              next = child = reconcileChildFibers(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);
            }
          }

          workInProgress.stateNode = current$$1.stateNode;
        }

        workInProgress.memoizedState = nextState;
        workInProgress.child = child;
        return next;
      }

      function updateDehydratedSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
        if (current$$1 === null) {
          workInProgress.expirationTime = Never;
          return null;
        }

        if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
          workInProgress.child = null;
          return null;
        }

        var hasContextChanged$$1 = current$$1.childExpirationTime >= renderExpirationTime;
        var suspenseInstance = current$$1.stateNode;

        if (didReceiveUpdate || hasContextChanged$$1 || isSuspenseInstanceFallback(suspenseInstance)) {
          current$$1.alternate = null;
          workInProgress.alternate = null;
          var returnFiber = workInProgress.return;
          invariant(returnFiber !== null, "Suspense boundaries are never on the root. " + "This is probably a bug in React.");
          var last = returnFiber.lastEffect;

          if (last !== null) {
            last.nextEffect = current$$1;
            returnFiber.lastEffect = current$$1;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = current$$1;
          }

          current$$1.nextEffect = null;
          current$$1.effectTag = Deletion;
          workInProgress.tag = SuspenseComponent;
          workInProgress.stateNode = null;
          workInProgress.memoizedState = null;
          workInProgress.effectTag |= Placement;
          return updateSuspenseComponent(null, workInProgress, renderExpirationTime);
        } else if (isSuspenseInstancePending(suspenseInstance)) {
          workInProgress.effectTag |= DidCapture;
          workInProgress.child = null;
          registerSuspenseInstanceRetry(suspenseInstance, retryTimedOutBoundary.bind(null, current$$1));
          return null;
        } else {
          reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress);
          var nextProps = workInProgress.pendingProps;
          var nextChildren = nextProps.children;
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
          return workInProgress.child;
        }
      }

      function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        var nextChildren = workInProgress.pendingProps;

        if (current$$1 === null) {
          workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        return workInProgress.child;
      }

      function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {
        var providerType = workInProgress.type;
        var context = providerType._context;
        var newProps = workInProgress.pendingProps;
        var oldProps = workInProgress.memoizedProps;
        var newValue = newProps.value;
        {
          var providerPropTypes = workInProgress.type.propTypes;

          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider", getCurrentFiberStackInDev);
          }
        }
        pushProvider(workInProgress, newValue);

        if (oldProps !== null) {
          var oldValue = oldProps.value;
          var changedBits = calculateChangedBits(context, newValue, oldValue);

          if (changedBits === 0) {
            if (oldProps.children === newProps.children && !hasContextChanged()) {
              return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            }
          } else {
            propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
          }
        }

        var newChildren = newProps.children;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      var hasWarnedAboutUsingContextAsConsumer = false;

      function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {
        var context = workInProgress.type;
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                warning$1(false, "Rendering <Context> directly is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress.pendingProps;
        var render = newProps.children;
        {
          !(typeof render === "function") ? warningWithoutStack$1(false, "A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.") : void 0;
        }
        prepareToReadContext(workInProgress, renderExpirationTime);

        var newValue = _readContext(context, newProps.unstable_observedBits);

        var newChildren = void 0;
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          newChildren = render(newValue);
          setCurrentPhase(null);
        }
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
      }

      function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
        cancelWorkTimer(workInProgress);

        if (current$$1 !== null) {
          workInProgress.contextDependencies = current$$1.contextDependencies;
        }

        if (enableProfilerTimer) {
          stopProfilerTimerIfRunning(workInProgress);
        }

        var childExpirationTime = workInProgress.childExpirationTime;

        if (childExpirationTime < renderExpirationTime) {
          return null;
        } else {
          cloneChildFibers(current$$1, workInProgress);
          return workInProgress.child;
        }
      }

      function beginWork(current$$1, workInProgress, renderExpirationTime) {
        var updateExpirationTime = workInProgress.expirationTime;

        if (current$$1 !== null) {
          var oldProps = current$$1.memoizedProps;
          var newProps = workInProgress.pendingProps;

          if (oldProps !== newProps || hasContextChanged()) {
            didReceiveUpdate = true;
          } else if (updateExpirationTime < renderExpirationTime) {
            didReceiveUpdate = false;

            switch (workInProgress.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress);
                resetHydrationState();
                break;

              case HostComponent:
                pushHostContext(workInProgress);
                break;

              case ClassComponent:
                {
                  var Component = workInProgress.type;

                  if (isContextProvider(Component)) {
                    pushContextProvider(workInProgress);
                  }

                  break;
                }

              case HostPortal:
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                break;

              case ContextProvider:
                {
                  var newValue = workInProgress.memoizedProps.value;
                  pushProvider(workInProgress, newValue);
                  break;
                }

              case Profiler:
                if (enableProfilerTimer) {
                  workInProgress.effectTag |= Update;
                }

                break;

              case SuspenseComponent:
                {
                  var state = workInProgress.memoizedState;
                  var didTimeout = state !== null;

                  if (didTimeout) {
                    var primaryChildFragment = workInProgress.child;
                    var primaryChildExpirationTime = primaryChildFragment.childExpirationTime;

                    if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime) {
                      return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
                    } else {
                      var child = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);

                      if (child !== null) {
                        return child.sibling;
                      } else {
                        return null;
                      }
                    }
                  }

                  break;
                }

              case DehydratedSuspenseComponent:
                {
                  if (enableSuspenseServerRenderer) {
                    workInProgress.effectTag |= DidCapture;
                    break;
                  }
                }
            }

            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        } else {
          didReceiveUpdate = false;
        }

        workInProgress.expirationTime = NoWork;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            {
              var elementType = workInProgress.elementType;
              return mountIndeterminateComponent(current$$1, workInProgress, elementType, renderExpirationTime);
            }

          case LazyComponent:
            {
              var _elementType = workInProgress.elementType;
              return mountLazyComponent(current$$1, workInProgress, _elementType, updateExpirationTime, renderExpirationTime);
            }

          case FunctionComponent:
            {
              var _Component = workInProgress.type;
              var unresolvedProps = workInProgress.pendingProps;
              var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
              return updateFunctionComponent(current$$1, workInProgress, _Component, resolvedProps, renderExpirationTime);
            }

          case ClassComponent:
            {
              var _Component2 = workInProgress.type;
              var _unresolvedProps = workInProgress.pendingProps;

              var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

              return updateClassComponent(current$$1, workInProgress, _Component2, _resolvedProps, renderExpirationTime);
            }

          case HostRoot:
            return updateHostRoot(current$$1, workInProgress, renderExpirationTime);

          case HostComponent:
            return updateHostComponent(current$$1, workInProgress, renderExpirationTime);

          case HostText:
            return updateHostText(current$$1, workInProgress);

          case SuspenseComponent:
            return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);

          case HostPortal:
            return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);

          case ForwardRef:
            {
              var type = workInProgress.type;
              var _unresolvedProps2 = workInProgress.pendingProps;

              var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

              return updateForwardRef(current$$1, workInProgress, type, _resolvedProps2, renderExpirationTime);
            }

          case Fragment:
            return updateFragment(current$$1, workInProgress, renderExpirationTime);

          case Mode:
            return updateMode(current$$1, workInProgress, renderExpirationTime);

          case Profiler:
            return updateProfiler(current$$1, workInProgress, renderExpirationTime);

          case ContextProvider:
            return updateContextProvider(current$$1, workInProgress, renderExpirationTime);

          case ContextConsumer:
            return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);

          case MemoComponent:
            {
              var _type2 = workInProgress.type;
              var _unresolvedProps3 = workInProgress.pendingProps;

              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);

              {
                if (workInProgress.type !== workInProgress.elementType) {
                  var outerPropTypes = _type2.propTypes;

                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, _resolvedProps3, "prop", getComponentName(_type2), getCurrentFiberStackInDev);
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current$$1, workInProgress, _type2, _resolvedProps3, updateExpirationTime, renderExpirationTime);
            }

          case SimpleMemoComponent:
            {
              return updateSimpleMemoComponent(current$$1, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
            }

          case IncompleteClassComponent:
            {
              var _Component3 = workInProgress.type;
              var _unresolvedProps4 = workInProgress.pendingProps;

              var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

              return mountIncompleteClassComponent(current$$1, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);
            }

          case DehydratedSuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                return updateDehydratedSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
              }

              break;
            }
        }

        invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
      }

      var valueCursor = createCursor(null);
      var rendererSigil = void 0;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastContextWithAllBitsObserved = null;
      var isDisallowedContextReadInDEV = false;

      function resetContextDependences() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        {
          isDisallowedContextReadInDEV = false;
        }
      }

      function enterDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = true;
        }
      }

      function exitDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = false;
        }
      }

      function pushProvider(providerFiber, nextValue) {
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer = rendererSigil;
          }
        } else {
          push(valueCursor, context._currentValue2, providerFiber);
          context._currentValue2 = nextValue;
          {
            !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer2 = rendererSigil;
          }
        }
      }

      function popProvider(providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          context._currentValue = currentValue;
        } else {
          context._currentValue2 = currentValue;
        }
      }

      function calculateChangedBits(context, newValue, oldValue) {
        if (is(oldValue, newValue)) {
          return 0;
        } else {
          var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;
          {
            !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, "calculateChangedBits: Expected the return value to be a " + "31-bit integer. Instead received: %s", changedBits) : void 0;
          }
          return changedBits | 0;
        }
      }

      function scheduleWorkOnParentPath(parent, renderExpirationTime) {
        var node = parent;

        while (node !== null) {
          var alternate = node.alternate;

          if (node.childExpirationTime < renderExpirationTime) {
            node.childExpirationTime = renderExpirationTime;

            if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
              alternate.childExpirationTime = renderExpirationTime;
            }
          } else if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
            alternate.childExpirationTime = renderExpirationTime;
          } else {
            break;
          }

          node = node.return;
        }
      }

      function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
        var fiber = workInProgress.child;

        if (fiber !== null) {
          fiber.return = workInProgress;
        }

        while (fiber !== null) {
          var nextFiber = void 0;
          var list = fiber.contextDependencies;

          if (list !== null) {
            nextFiber = fiber.child;
            var dependency = list.first;

            while (dependency !== null) {
              if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                if (fiber.tag === ClassComponent) {
                  var update = createUpdate(renderExpirationTime);
                  update.tag = ForceUpdate;
                  enqueueUpdate(fiber, update);
                }

                if (fiber.expirationTime < renderExpirationTime) {
                  fiber.expirationTime = renderExpirationTime;
                }

                var alternate = fiber.alternate;

                if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
                  alternate.expirationTime = renderExpirationTime;
                }

                scheduleWorkOnParentPath(fiber.return, renderExpirationTime);

                if (list.expirationTime < renderExpirationTime) {
                  list.expirationTime = renderExpirationTime;
                }

                break;
              }

              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
          } else if (enableSuspenseServerRenderer && fiber.tag === DehydratedSuspenseComponent) {
            if (fiber.expirationTime < renderExpirationTime) {
              fiber.expirationTime = renderExpirationTime;
            }

            var _alternate = fiber.alternate;

            if (_alternate !== null && _alternate.expirationTime < renderExpirationTime) {
              _alternate.expirationTime = renderExpirationTime;
            }

            scheduleWorkOnParentPath(fiber, renderExpirationTime);
            nextFiber = fiber.sibling;
          } else {
            nextFiber = fiber.child;
          }

          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;

            while (nextFiber !== null) {
              if (nextFiber === workInProgress) {
                nextFiber = null;
                break;
              }

              var sibling = nextFiber.sibling;

              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }

              nextFiber = nextFiber.return;
            }
          }

          fiber = nextFiber;
        }
      }

      function prepareToReadContext(workInProgress, renderExpirationTime) {
        currentlyRenderingFiber = workInProgress;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        var currentDependencies = workInProgress.contextDependencies;

        if (currentDependencies !== null && currentDependencies.expirationTime >= renderExpirationTime) {
          markWorkInProgressReceivedUpdate();
        }

        workInProgress.contextDependencies = null;
      }

      function _readContext(context, observedBits) {
        {
          !!isDisallowedContextReadInDEV ? warning$1(false, "Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().") : void 0;
        }

        if (lastContextWithAllBitsObserved === context) {} else if (observedBits === false || observedBits === 0) {} else {
          var resolvedObservedBits = void 0;

          if (typeof observedBits !== "number" || observedBits === maxSigned31BitInt) {
            lastContextWithAllBitsObserved = context;
            resolvedObservedBits = maxSigned31BitInt;
          } else {
            resolvedObservedBits = observedBits;
          }

          var contextItem = {
            context: context,
            observedBits: resolvedObservedBits,
            next: null
          };

          if (lastContextDependency === null) {
            invariant(currentlyRenderingFiber !== null, "Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
            lastContextDependency = contextItem;
            currentlyRenderingFiber.contextDependencies = {
              first: contextItem,
              expirationTime: NoWork
            };
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }

        return isPrimaryRenderer ? context._currentValue : context._currentValue2;
      }

      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate = void 0;
      var currentlyProcessingQueue = void 0;
      var resetCurrentlyProcessingQueue = void 0;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;

        resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {
          currentlyProcessingQueue = null;
        };
      }

      function createUpdateQueue(baseState) {
        var queue = {
          baseState: baseState,
          firstUpdate: null,
          lastUpdate: null,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function cloneUpdateQueue(currentQueue) {
        var queue = {
          baseState: currentQueue.baseState,
          firstUpdate: currentQueue.firstUpdate,
          lastUpdate: currentQueue.lastUpdate,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function createUpdate(expirationTime) {
        return {
          expirationTime: expirationTime,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null,
          nextEffect: null
        };
      }

      function appendUpdateToQueue(queue, update) {
        if (queue.lastUpdate === null) {
          queue.firstUpdate = queue.lastUpdate = update;
        } else {
          queue.lastUpdate.next = update;
          queue.lastUpdate = update;
        }
      }

      function enqueueUpdate(fiber, update) {
        var alternate = fiber.alternate;
        var queue1 = void 0;
        var queue2 = void 0;

        if (alternate === null) {
          queue1 = fiber.updateQueue;
          queue2 = null;

          if (queue1 === null) {
            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
          }
        } else {
          queue1 = fiber.updateQueue;
          queue2 = alternate.updateQueue;

          if (queue1 === null) {
            if (queue2 === null) {
              queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
              queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
            } else {
              queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
            }
          } else {
            if (queue2 === null) {
              queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
            } else {}
          }
        }

        if (queue2 === null || queue1 === queue2) {
          appendUpdateToQueue(queue1, update);
        } else {
          if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
            appendUpdateToQueue(queue1, update);
            appendUpdateToQueue(queue2, update);
          } else {
            appendUpdateToQueue(queue1, update);
            queue2.lastUpdate = update;
          }
        }

        {
          if (fiber.tag === ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
            warningWithoutStack$1(false, "An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
      }

      function enqueueCapturedUpdate(workInProgress, update) {
        var workInProgressQueue = workInProgress.updateQueue;

        if (workInProgressQueue === null) {
          workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
        } else {
          workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
        }

        if (workInProgressQueue.lastCapturedUpdate === null) {
          workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
        } else {
          workInProgressQueue.lastCapturedUpdate.next = update;
          workInProgressQueue.lastCapturedUpdate = update;
        }
      }

      function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
        var current = workInProgress.alternate;

        if (current !== null) {
          if (queue === current.updateQueue) {
            queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
          }
        }

        return queue;
      }

      function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState:
            {
              var _payload = update.payload;

              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();

                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload.call(instance, prevState, nextProps);
                  }
                }

                var nextState = _payload.call(instance, prevState, nextProps);

                {
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }

              return _payload;
            }

          case CaptureUpdate:
            {
              workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;
            }

          case UpdateState:
            {
              var _payload2 = update.payload;
              var partialState = void 0;

              if (typeof _payload2 === "function") {
                {
                  enterDisallowedContextReadInDEV();

                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload2.call(instance, prevState, nextProps);
                  }
                }
                partialState = _payload2.call(instance, prevState, nextProps);
                {
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload2;
              }

              if (partialState === null || partialState === undefined) {
                return prevState;
              }

              return _extends({}, prevState, partialState);
            }

          case ForceUpdate:
            {
              hasForceUpdate = true;
              return prevState;
            }
        }

        return prevState;
      }

      function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
        hasForceUpdate = false;
        queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);
        {
          currentlyProcessingQueue = queue;
        }
        var newBaseState = queue.baseState;
        var newFirstUpdate = null;
        var newExpirationTime = NoWork;
        var update = queue.firstUpdate;
        var resultState = newBaseState;

        while (update !== null) {
          var updateExpirationTime = update.expirationTime;

          if (updateExpirationTime < renderExpirationTime) {
            if (newFirstUpdate === null) {
              newFirstUpdate = update;
              newBaseState = resultState;
            }

            if (newExpirationTime < updateExpirationTime) {
              newExpirationTime = updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback = update.callback;

            if (_callback !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastEffect === null) {
                queue.firstEffect = queue.lastEffect = update;
              } else {
                queue.lastEffect.nextEffect = update;
                queue.lastEffect = update;
              }
            }
          }

          update = update.next;
        }

        var newFirstCapturedUpdate = null;
        update = queue.firstCapturedUpdate;

        while (update !== null) {
          var _updateExpirationTime = update.expirationTime;

          if (_updateExpirationTime < renderExpirationTime) {
            if (newFirstCapturedUpdate === null) {
              newFirstCapturedUpdate = update;

              if (newFirstUpdate === null) {
                newBaseState = resultState;
              }
            }

            if (newExpirationTime < _updateExpirationTime) {
              newExpirationTime = _updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback2 = update.callback;

            if (_callback2 !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastCapturedEffect === null) {
                queue.firstCapturedEffect = queue.lastCapturedEffect = update;
              } else {
                queue.lastCapturedEffect.nextEffect = update;
                queue.lastCapturedEffect = update;
              }
            }
          }

          update = update.next;
        }

        if (newFirstUpdate === null) {
          queue.lastUpdate = null;
        }

        if (newFirstCapturedUpdate === null) {
          queue.lastCapturedUpdate = null;
        } else {
          workInProgress.effectTag |= Callback;
        }

        if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
          newBaseState = resultState;
        }

        queue.baseState = newBaseState;
        queue.firstUpdate = newFirstUpdate;
        queue.firstCapturedUpdate = newFirstCapturedUpdate;
        workInProgress.expirationTime = newExpirationTime;
        workInProgress.memoizedState = resultState;
        {
          currentlyProcessingQueue = null;
        }
      }

      function callCallback(callback, context) {
        invariant(typeof callback === "function", "Invalid argument passed as callback. Expected a function. Instead " + "received: %s", callback);
        callback.call(context);
      }

      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }

      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }

      function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
        if (finishedQueue.firstCapturedUpdate !== null) {
          if (finishedQueue.lastUpdate !== null) {
            finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
            finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
          }

          finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
        }

        commitUpdateEffects(finishedQueue.firstEffect, instance);
        finishedQueue.firstEffect = finishedQueue.lastEffect = null;
        commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
        finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
      }

      function commitUpdateEffects(effect, instance) {
        while (effect !== null) {
          var _callback3 = effect.callback;

          if (_callback3 !== null) {
            effect.callback = null;
            callCallback(_callback3, instance);
          }

          effect = effect.nextEffect;
        }
      }

      function createCapturedValue(value, source) {
        return {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }

      function markUpdate(workInProgress) {
        workInProgress.effectTag |= Update;
      }

      function markRef$1(workInProgress) {
        workInProgress.effectTag |= Ref;
      }

      var _appendAllChildren = void 0;

      var updateHostContainer = void 0;
      var updateHostComponent$1 = void 0;
      var updateHostText$1 = void 0;

      if (supportsMutation) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal) {} else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var oldProps = current.memoizedProps;

          if (oldProps === newProps) {
            return;
          }

          var instance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress.updateQueue = updatePayload;

          if (updatePayload) {
            markUpdate(workInProgress);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress);
          }
        };
      } else if (supportsPersistence) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendInitialChild(parent, instance);
            } else if (node.tag === HostText) {
              var _instance = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance;
              }

              appendInitialChild(parent, _instance);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    _appendAllChildren(parent, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendChildToContainerChildSet(containerChildSet, instance);
            } else if (node.tag === HostText) {
              var _instance2 = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance2 = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance2 = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance2;
              }

              appendChildToContainerChildSet(containerChildSet, _instance2);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {
          var portalOrRoot = workInProgress.stateNode;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged) {} else {
            var container = portalOrRoot.containerInfo;
            var newChildSet = createContainerChildSet(container);
            appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
            portalOrRoot.pendingChildren = newChildSet;
            markUpdate(workInProgress);
            finalizeContainerChildren(container, newChildSet);
          }
        };

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var currentInstance = current.stateNode;
          var oldProps = current.memoizedProps;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged && oldProps === newProps) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var recyclableInstance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = null;

          if (oldProps !== newProps) {
            updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          }

          if (childrenUnchanged && updatePayload === null) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);

          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
            markUpdate(workInProgress);
          }

          workInProgress.stateNode = newInstance;

          if (childrenUnchanged) {
            markUpdate(workInProgress);
          } else {
            _appendAllChildren(newInstance, workInProgress, false, false);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            var rootContainerInstance = getRootHostContainer();
            var currentHostContext = getHostContext();
            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
            markUpdate(workInProgress);
          }
        };
      } else {
        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {};

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {};
      }

      function completeWork(current, workInProgress, renderExpirationTime) {
        var newProps = workInProgress.pendingProps;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            break;

          case LazyComponent:
            break;

          case SimpleMemoComponent:
          case FunctionComponent:
            break;

          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var fiberRoot = workInProgress.stateNode;

              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }

              if (current === null || current.child === null) {
                popHydrationState(workInProgress);
                workInProgress.effectTag &= ~Placement;
              }

              updateHostContainer(workInProgress);
              break;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress.type;

              if (current !== null && workInProgress.stateNode != null) {
                updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

                if (current.ref !== workInProgress.ref) {
                  markRef$1(workInProgress);
                }
              } else {
                if (!newProps) {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                  break;
                }

                var currentHostContext = getHostContext();
                var wasHydrated = popHydrationState(workInProgress);

                if (wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);

                  _appendAllChildren(instance, workInProgress, false, false);

                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }

                  workInProgress.stateNode = instance;
                }

                if (workInProgress.ref !== null) {
                  markRef$1(workInProgress);
                }
              }

              break;
            }

          case HostText:
            {
              var newText = newProps;

              if (current && workInProgress.stateNode != null) {
                var oldText = current.memoizedProps;
                updateHostText$1(current, workInProgress, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                }

                var _rootContainerInstance = getRootHostContainer();

                var _currentHostContext = getHostContext();

                var _wasHydrated = popHydrationState(workInProgress);

                if (_wasHydrated) {
                  if (prepareToHydrateHostTextInstance(workInProgress)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                }
              }

              break;
            }

          case ForwardRef:
            break;

          case SuspenseComponent:
            {
              var nextState = workInProgress.memoizedState;

              if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
                workInProgress.expirationTime = renderExpirationTime;
                return workInProgress;
              }

              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current !== null && current.memoizedState !== null;

              if (current === null) {
                popHydrationState(workInProgress);
              } else if (!nextDidTimeout && prevDidTimeout) {
                var currentFallbackChild = current.child.sibling;

                if (currentFallbackChild !== null) {
                  var first = workInProgress.firstEffect;

                  if (first !== null) {
                    workInProgress.firstEffect = currentFallbackChild;
                    currentFallbackChild.nextEffect = first;
                  } else {
                    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
                    currentFallbackChild.nextEffect = null;
                  }

                  currentFallbackChild.effectTag = Deletion;
                }
              }

              if (nextDidTimeout || prevDidTimeout) {
                workInProgress.effectTag |= Update;
              }

              break;
            }

          case Fragment:
            break;

          case Mode:
            break;

          case Profiler:
            break;

          case HostPortal:
            popHostContainer(workInProgress);
            updateHostContainer(workInProgress);
            break;

          case ContextProvider:
            popProvider(workInProgress);
            break;

          case ContextConsumer:
            break;

          case MemoComponent:
            break;

          case IncompleteClassComponent:
            {
              var _Component = workInProgress.type;

              if (isContextProvider(_Component)) {
                popContext(workInProgress);
              }

              break;
            }

          case DehydratedSuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                if (current === null) {
                  var _wasHydrated2 = popHydrationState(workInProgress);

                  invariant(_wasHydrated2, "A dehydrated suspense component was completed without a hydrated node. " + "This is probably a bug in React.");
                  skipPastDehydratedSuspenseInstance(workInProgress);
                } else if ((workInProgress.effectTag & DidCapture) === NoEffect) {
                  current.alternate = null;
                  workInProgress.alternate = null;
                  workInProgress.tag = SuspenseComponent;
                  workInProgress.memoizedState = null;
                  workInProgress.stateNode = null;
                }
              }

              break;
            }

          default:
            invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
        }

        return null;
      }

      function shouldCaptureSuspense(workInProgress) {
        if (workInProgress.memoizedProps.fallback === undefined) {
          return false;
        }

        var nextState = workInProgress.memoizedState;
        return nextState === null;
      }

      function showErrorDialog(capturedError) {
        var componentStack = capturedError.componentStack,
            error = capturedError.error;
        var errorToHandle = void 0;

        if (error instanceof Error) {
          var message = error.message,
              name = error.name;
          var summary = message ? name + ": " + message : name;
          errorToHandle = error;

          try {
            errorToHandle.message = summary + "\n\nThis error is located at:" + componentStack;
          } catch (e) {}
        } else if (typeof error === "string") {
          errorToHandle = new Error(error + "\n\nThis error is located at:" + componentStack);
        } else {
          errorToHandle = new Error("Unspecified error at:" + componentStack);
        }

        ExceptionsManager.handleException(errorToHandle, false);
        return false;
      }

      function logCapturedError(capturedError) {
        var logError = showErrorDialog(capturedError);

        if (logError === false) {
          return;
        }

        var error = capturedError.error;
        {
          var componentName = capturedError.componentName,
              componentStack = capturedError.componentStack,
              errorBoundaryName = capturedError.errorBoundaryName,
              errorBoundaryFound = capturedError.errorBoundaryFound,
              willRetry = capturedError.willRetry;

          if (error != null && error._suppressLogging) {
            if (errorBoundaryFound && willRetry) {
              return;
            }

            console.error(error);
          }

          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
          var errorBoundaryMessage = void 0;

          if (errorBoundaryFound && errorBoundaryName) {
            if (willRetry) {
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            } else {
              errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\n" + "Recreating the tree from scratch failed so React will unmount the tree.";
            }
          } else {
            errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n" + "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
          }

          var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);
          console.error(combinedMessage);
        }
      }

      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
      }
      var PossiblyWeakSet$1 = typeof WeakSet === "function" ? WeakSet : Set;

      function logError(boundary, errorInfo) {
        var source = errorInfo.source;
        var stack = errorInfo.stack;

        if (stack === null && source !== null) {
          stack = getStackByFiberInDevAndProd(source);
        }

        var capturedError = {
          componentName: source !== null ? getComponentName(source.type) : null,
          componentStack: stack !== null ? stack : "",
          error: errorInfo.value,
          errorBoundary: null,
          errorBoundaryName: null,
          errorBoundaryFound: false,
          willRetry: false
        };

        if (boundary !== null && boundary.tag === ClassComponent) {
          capturedError.errorBoundary = boundary.stateNode;
          capturedError.errorBoundaryName = getComponentName(boundary.type);
          capturedError.errorBoundaryFound = true;
          capturedError.willRetry = true;
        }

        try {
          logCapturedError(capturedError);
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }

      var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current$$1, instance) {
        startPhaseTimer(current$$1, "componentWillUnmount");
        instance.props = current$$1.memoizedProps;
        instance.state = current$$1.memoizedState;
        instance.componentWillUnmount();
        stopPhaseTimer();
      };

      function safelyCallComponentWillUnmount(current$$1, instance) {
        {
          invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);

          if (hasCaughtError()) {
            var unmountError = clearCaughtError();
            captureCommitPhaseError(current$$1, unmountError);
          }
        }
      }

      function safelyDetachRef(current$$1) {
        var ref = current$$1.ref;

        if (ref !== null) {
          if (typeof ref === "function") {
            {
              invokeGuardedCallback(null, ref, null, null);

              if (hasCaughtError()) {
                var refError = clearCaughtError();
                captureCommitPhaseError(current$$1, refError);
              }
            }
          } else {
            ref.current = null;
          }
        }
      }

      function safelyCallDestroy(current$$1, destroy) {
        {
          invokeGuardedCallback(null, destroy, null);

          if (hasCaughtError()) {
            var error = clearCaughtError();
            captureCommitPhaseError(current$$1, error);
          }
        }
      }

      function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
              return;
            }

          case ClassComponent:
            {
              if (finishedWork.effectTag & Snapshot) {
                if (current$$1 !== null) {
                  var prevProps = current$$1.memoizedProps;
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "getSnapshotBeforeUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "getSnapshotBeforeUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      warningWithoutStack$1(false, "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) " + "must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  stopPhaseTimer();
                }
              }

              return;
            }

          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case IncompleteClassComponent:
            return;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitHookEffectList(unmountTag, mountTag, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;

          do {
            if ((effect.tag & unmountTag) !== NoEffect$1) {
              var destroy = effect.destroy;
              effect.destroy = undefined;

              if (destroy !== undefined) {
                destroy();
              }
            }

            if ((effect.tag & mountTag) !== NoEffect$1) {
              var create = effect.create;
              effect.destroy = create();
              {
                var _destroy = effect.destroy;

                if (_destroy !== undefined && typeof _destroy !== "function") {
                  var addendum = void 0;

                  if (_destroy === null) {
                    addendum = " You returned null. If your effect does not require clean " + "up, return undefined (or nothing).";
                  } else if (typeof _destroy.then === "function") {
                    addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. " + "Instead, you may write an async function separately " + "and then call it from inside the effect:\n\n" + "async function fetchComment(commentId) {\n" + "  // You can await here\n" + "}\n\n" + "useEffect(() => {\n" + "  fetchComment(commentId);\n" + "}, [commentId]);\n\n" + "In the future, React will provide a more idiomatic solution for data fetching " + "that doesn't involve writing effects manually.";
                  } else {
                    addendum = " You returned: " + _destroy;
                  }

                  warningWithoutStack$1(false, "An Effect function must not return anything besides a function, " + "which is used for clean-up.%s%s", addendum, getStackByFiberInDevAndProd(finishedWork));
                }
              }
            }

            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }

      function commitPassiveHookEffects(finishedWork) {
        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
      }

      function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
              break;
            }

          case ClassComponent:
            {
              var instance = finishedWork.stateNode;

              if (finishedWork.effectTag & Update) {
                if (current$$1 === null) {
                  startPhaseTimer(finishedWork, "componentDidMount");
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "componentDidMount. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "componentDidMount. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    }
                  }
                  instance.componentDidMount();
                  stopPhaseTimer();
                } else {
                  var prevProps = finishedWork.elementType === finishedWork.type ? current$$1.memoizedProps : resolveDefaultProps(finishedWork.type, current$$1.memoizedProps);
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "componentDidUpdate");
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "componentDidUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "componentDidUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    }
                  }
                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                  stopPhaseTimer();
                }
              }

              var updateQueue = finishedWork.updateQueue;

              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "processing the update queue. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "processing the update queue. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);
              }

              return;
            }

          case HostRoot:
            {
              var _updateQueue = finishedWork.updateQueue;

              if (_updateQueue !== null) {
                var _instance = null;

                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;

                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }

                commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);
              }

              return;
            }

          case HostComponent:
            {
              var _instance2 = finishedWork.stateNode;

              if (current$$1 === null && finishedWork.effectTag & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
              }

              return;
            }

          case HostText:
            {
              return;
            }

          case HostPortal:
            {
              return;
            }

          case Profiler:
            {
              if (enableProfilerTimer) {
                var onRender = finishedWork.memoizedProps.onRender;

                if (enableSchedulerTracing) {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
                } else {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());
                }
              }

              return;
            }

          case SuspenseComponent:
            break;

          case IncompleteClassComponent:
            break;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        if (supportsMutation) {
          var node = finishedWork;

          while (true) {
            if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (isHidden) {
                hideInstance(instance);
              } else {
                unhideInstance(node.stateNode, node.memoizedProps);
              }
            } else if (node.tag === HostText) {
              var _instance3 = node.stateNode;

              if (isHidden) {
                hideTextInstance(_instance3);
              } else {
                unhideTextInstance(_instance3, node.memoizedProps);
              }
            } else if (node.tag === SuspenseComponent && node.memoizedState !== null) {
              var fallbackChildFragment = node.child.sibling;
              fallbackChildFragment.return = node;
              node = fallbackChildFragment;
              continue;
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === finishedWork) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
      }

      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;

        if (ref !== null) {
          var instance = finishedWork.stateNode;
          var instanceToUse = void 0;

          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;

            default:
              instanceToUse = instance;
          }

          if (typeof ref === "function") {
            ref(instanceToUse);
          } else {
            {
              if (!ref.hasOwnProperty("current")) {
                warningWithoutStack$1(false, "Unexpected ref object provided for %s. " + "Use either a ref-setter function or React.createRef().%s", getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
              }
            }
            ref.current = instanceToUse;
          }
        }
      }

      function commitDetachRef(current$$1) {
        var currentRef = current$$1.ref;

        if (currentRef !== null) {
          if (typeof currentRef === "function") {
            currentRef(null);
          } else {
            currentRef.current = null;
          }
        }
      }

      function commitUnmount(current$$1) {
        onCommitUnmount(current$$1);

        switch (current$$1.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              var updateQueue = current$$1.updateQueue;

              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;

                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;

                  do {
                    var destroy = effect.destroy;

                    if (destroy !== undefined) {
                      safelyCallDestroy(current$$1, destroy);
                    }

                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }

              break;
            }

          case ClassComponent:
            {
              safelyDetachRef(current$$1);
              var instance = current$$1.stateNode;

              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(current$$1, instance);
              }

              return;
            }

          case HostComponent:
            {
              safelyDetachRef(current$$1);
              return;
            }

          case HostPortal:
            {
              if (supportsMutation) {
                unmountHostComponents(current$$1);
              } else if (supportsPersistence) {
                emptyPortalContainer(current$$1);
              }

              return;
            }
        }
      }

      function commitNestedUnmounts(root) {
        var node = root;

        while (true) {
          commitUnmount(node);

          if (node.child !== null && (!supportsMutation || node.tag !== HostPortal)) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === root) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === root) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function detachFiber(current$$1) {
        current$$1.return = null;
        current$$1.child = null;
        current$$1.memoizedState = null;
        current$$1.updateQueue = null;
        var alternate = current$$1.alternate;

        if (alternate !== null) {
          alternate.return = null;
          alternate.child = null;
          alternate.memoizedState = null;
          alternate.updateQueue = null;
        }
      }

      function emptyPortalContainer(current$$1) {
        if (!supportsPersistence) {
          return;
        }

        var portal = current$$1.stateNode;
        var containerInfo = portal.containerInfo;
        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      }

      function commitContainer(finishedWork) {
        if (!supportsPersistence) {
          return;
        }

        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              return;
            }

          case HostText:
            {
              return;
            }

          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;
              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function getHostParentFiber(fiber) {
        var parent = fiber.return;

        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }

          parent = parent.return;
        }

        invariant(false, "Expected to find a host parent. This error is likely caused by a bug " + "in React. Please file an issue.");
      }

      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }

      function getHostSibling(fiber) {
        var node = fiber;

        siblings: while (true) {
          while (node.sibling === null) {
            if (node.return === null || isHostParent(node.return)) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;

          while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedSuspenseComponent) {
            if (node.effectTag & Placement) {
              continue siblings;
            }

            if (node.child === null || node.tag === HostPortal) {
              continue siblings;
            } else {
              node.child.return = node;
              node = node.child;
            }
          }

          if (!(node.effectTag & Placement)) {
            return node.stateNode;
          }
        }
      }

      function commitPlacement(finishedWork) {
        if (!supportsMutation) {
          return;
        }

        var parentFiber = getHostParentFiber(finishedWork);
        var parent = void 0;
        var isContainer = void 0;

        switch (parentFiber.tag) {
          case HostComponent:
            parent = parentFiber.stateNode;
            isContainer = false;
            break;

          case HostRoot:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          case HostPortal:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          default:
            invariant(false, "Invalid host parent fiber. This error is likely caused by a bug " + "in React. Please file an issue.");
        }

        if (parentFiber.effectTag & ContentReset) {
          parentFiber.effectTag &= ~ContentReset;
        }

        var before = getHostSibling(finishedWork);
        var node = finishedWork;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            if (before) {
              if (isContainer) {
                insertInContainerBefore(parent, node.stateNode, before);
              } else {
                insertBefore(parent, node.stateNode, before);
              }
            } else {
              if (isContainer) {
                appendChildToContainer(parent, node.stateNode);
              } else {
                appendChild(parent, node.stateNode);
              }
            }
          } else if (node.tag === HostPortal) {} else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === finishedWork) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === finishedWork) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function unmountHostComponents(current$$1) {
        var node = current$$1;
        var currentParentIsValid = false;
        var currentParent = void 0;
        var currentParentIsContainer = void 0;

        while (true) {
          if (!currentParentIsValid) {
            var parent = node.return;

            findParent: while (true) {
              invariant(parent !== null, "Expected to find a host parent. This error is likely caused by " + "a bug in React. Please file an issue.");

              switch (parent.tag) {
                case HostComponent:
                  currentParent = parent.stateNode;
                  currentParentIsContainer = false;
                  break findParent;

                case HostRoot:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;

                case HostPortal:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;
              }

              parent = parent.return;
            }

            currentParentIsValid = true;
          }

          if (node.tag === HostComponent || node.tag === HostText) {
            commitNestedUnmounts(node);

            if (currentParentIsContainer) {
              removeChildFromContainer(currentParent, node.stateNode);
            } else {
              removeChild(currentParent, node.stateNode);
            }
          } else if (enableSuspenseServerRenderer && node.tag === DehydratedSuspenseComponent) {
            if (currentParentIsContainer) {
              clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);
            } else {
              clearSuspenseBoundary(currentParent, node.stateNode);
            }
          } else if (node.tag === HostPortal) {
            if (node.child !== null) {
              currentParent = node.stateNode.containerInfo;
              currentParentIsContainer = true;
              node.child.return = node;
              node = node.child;
              continue;
            }
          } else {
            commitUnmount(node);

            if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          }

          if (node === current$$1) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === current$$1) {
              return;
            }

            node = node.return;

            if (node.tag === HostPortal) {
              currentParentIsValid = false;
            }
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function commitDeletion(current$$1) {
        if (supportsMutation) {
          unmountHostComponents(current$$1);
        } else {
          commitNestedUnmounts(current$$1);
        }

        detachFiber(current$$1);
      }

      function commitWork(current$$1, finishedWork) {
        if (!supportsMutation) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
              {
                commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
                return;
              }
          }

          commitContainer(finishedWork);
          return;
        }

        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
              return;
            }

          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              var instance = finishedWork.stateNode;

              if (instance != null) {
                var newProps = finishedWork.memoizedProps;
                var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;
                var type = finishedWork.type;
                var updatePayload = finishedWork.updateQueue;
                finishedWork.updateQueue = null;

                if (updatePayload !== null) {
                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                }
              }

              return;
            }

          case HostText:
            {
              invariant(finishedWork.stateNode !== null, "This should have a text node initialized. This error is likely " + "caused by a bug in React. Please file an issue.");
              var textInstance = finishedWork.stateNode;
              var newText = finishedWork.memoizedProps;
              var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
              commitTextUpdate(textInstance, oldText, newText);
              return;
            }

          case HostRoot:
            {
              return;
            }

          case Profiler:
            {
              return;
            }

          case SuspenseComponent:
            {
              var newState = finishedWork.memoizedState;
              var newDidTimeout = void 0;
              var primaryChildParent = finishedWork;

              if (newState === null) {
                newDidTimeout = false;
              } else {
                newDidTimeout = true;
                primaryChildParent = finishedWork.child;

                if (newState.timedOutAt === NoWork) {
                  newState.timedOutAt = requestCurrentTime();
                }
              }

              if (primaryChildParent !== null) {
                hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
              }

              var thenables = finishedWork.updateQueue;

              if (thenables !== null) {
                finishedWork.updateQueue = null;
                var retryCache = finishedWork.stateNode;

                if (retryCache === null) {
                  retryCache = finishedWork.stateNode = new PossiblyWeakSet$1();
                }

                thenables.forEach(function (thenable) {
                  var retry = resolveRetryThenable.bind(null, finishedWork, thenable);

                  if (enableSchedulerTracing) {
                    retry = tracing.unstable_wrap(retry);
                  }

                  if (!retryCache.has(thenable)) {
                    retryCache.add(thenable);
                    thenable.then(retry, retry);
                  }
                });
              }

              return;
            }

          case IncompleteClassComponent:
            {
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitResetTextContent(current$$1) {
        if (!supportsMutation) {
          return;
        }

        resetTextContent(current$$1.stateNode);
      }

      var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
      var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;

      function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error = errorInfo.value;

        update.callback = function () {
          onUncaughtError(error);
          logError(fiber, errorInfo);
        };

        return update;
      }

      function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

        if (typeof getDerivedStateFromError === "function") {
          var error = errorInfo.value;

          update.payload = function () {
            return getDerivedStateFromError(error);
          };
        }

        var inst = fiber.stateNode;

        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }

            var error = errorInfo.value;
            var stack = errorInfo.stack;
            logError(fiber, errorInfo);
            this.componentDidCatch(error, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                !(fiber.expirationTime === Sync) ? warningWithoutStack$1(false, "%s: Error boundaries should implement getDerivedStateFromError(). " + "In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown") : void 0;
              }
            }
          };
        }

        return update;
      }

      function attachPingListener(root, renderExpirationTime, thenable) {
        var pingCache = root.pingCache;
        var threadIDs = void 0;

        if (pingCache === null) {
          pingCache = root.pingCache = new PossiblyWeakMap();
          threadIDs = new Set();
          pingCache.set(thenable, threadIDs);
        } else {
          threadIDs = pingCache.get(thenable);

          if (threadIDs === undefined) {
            threadIDs = new Set();
            pingCache.set(thenable, threadIDs);
          }
        }

        if (!threadIDs.has(renderExpirationTime)) {
          threadIDs.add(renderExpirationTime);
          var ping = pingSuspendedRoot.bind(null, root, thenable, renderExpirationTime);

          if (enableSchedulerTracing) {
            ping = tracing.unstable_wrap(ping);
          }

          thenable.then(ping, ping);
        }
      }

      function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
        sourceFiber.effectTag |= Incomplete;
        sourceFiber.firstEffect = sourceFiber.lastEffect = null;

        if (value !== null && typeof value === "object" && typeof value.then === "function") {
          var thenable = value;
          var _workInProgress = returnFiber;
          var earliestTimeoutMs = -1;
          var startTimeMs = -1;

          do {
            if (_workInProgress.tag === SuspenseComponent) {
              var current$$1 = _workInProgress.alternate;

              if (current$$1 !== null) {
                var currentState = current$$1.memoizedState;

                if (currentState !== null) {
                  var timedOutAt = currentState.timedOutAt;
                  startTimeMs = expirationTimeToMs(timedOutAt);
                  break;
                }
              }

              var timeoutPropMs = _workInProgress.pendingProps.maxDuration;

              if (typeof timeoutPropMs === "number") {
                if (timeoutPropMs <= 0) {
                  earliestTimeoutMs = 0;
                } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
                  earliestTimeoutMs = timeoutPropMs;
                }
              }
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          _workInProgress = returnFiber;

          do {
            if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress)) {
              var thenables = _workInProgress.updateQueue;

              if (thenables === null) {
                var updateQueue = new Set();
                updateQueue.add(thenable);
                _workInProgress.updateQueue = updateQueue;
              } else {
                thenables.add(thenable);
              }

              if ((_workInProgress.mode & ConcurrentMode) === NoEffect) {
                _workInProgress.effectTag |= DidCapture;
                sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);

                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;

                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(Sync);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update);
                  }
                }

                sourceFiber.expirationTime = Sync;
                return;
              }

              attachPingListener(root, renderExpirationTime, thenable);
              var absoluteTimeoutMs = void 0;

              if (earliestTimeoutMs === -1) {
                absoluteTimeoutMs = maxSigned31BitInt;
              } else {
                if (startTimeMs === -1) {
                  var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);
                  var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
                  startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
                }

                absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
              }

              renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            } else if (enableSuspenseServerRenderer && _workInProgress.tag === DehydratedSuspenseComponent) {
              attachPingListener(root, renderExpirationTime, thenable);
              var retryCache = _workInProgress.memoizedState;

              if (retryCache === null) {
                retryCache = _workInProgress.memoizedState = new PossiblyWeakSet();
                var _current = _workInProgress.alternate;
                invariant(_current, "A dehydrated suspense boundary must commit before trying to render. " + "This is probably a bug in React.");
                _current.memoizedState = retryCache;
              }

              if (!retryCache.has(thenable)) {
                retryCache.add(thenable);
                var retry = resolveRetryThenable.bind(null, _workInProgress, thenable);

                if (enableSchedulerTracing) {
                  retry = tracing.unstable_wrap(retry);
                }

                thenable.then(retry, retry);
              }

              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n" + "\n" + "Add a <Suspense fallback=...> component higher in the tree to " + "provide a loading indicator or placeholder to display." + getStackByFiberInDevAndProd(sourceFiber));
        }

        renderDidError();
        value = createCapturedValue(value, sourceFiber);
        var workInProgress = returnFiber;

        do {
          switch (workInProgress.tag) {
            case HostRoot:
              {
                var _errorInfo = value;
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;

                var _update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);

                enqueueCapturedUpdate(workInProgress, _update);
                return;
              }

            case ClassComponent:
              var errorInfo = value;
              var ctor = workInProgress.type;
              var instance = workInProgress.stateNode;

              if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;

                var _update2 = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);

                enqueueCapturedUpdate(workInProgress, _update2);
                return;
              }

              break;

            default:
              break;
          }

          workInProgress = workInProgress.return;
        } while (workInProgress !== null);
      }

      function unwindWork(workInProgress, renderExpirationTime) {
        switch (workInProgress.tag) {
          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag & ShouldCapture) {
                workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var _effectTag = workInProgress.effectTag;
              invariant((_effectTag & DidCapture) === NoEffect, "The root failed to unmount after an error. This is likely a bug in " + "React. Please file an issue.");
              workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              return null;
            }

          case SuspenseComponent:
            {
              var _effectTag2 = workInProgress.effectTag;

              if (_effectTag2 & ShouldCapture) {
                workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case DehydratedSuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                var _effectTag3 = workInProgress.effectTag;

                if (_effectTag3 & ShouldCapture) {
                  workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;
                  return workInProgress;
                }
              }

              return null;
            }

          case HostPortal:
            popHostContainer(workInProgress);
            return null;

          case ContextProvider:
            popProvider(workInProgress);
            return null;

          default:
            return null;
        }
      }

      function unwindInterruptedWork(interruptedWork) {
        switch (interruptedWork.tag) {
          case ClassComponent:
            {
              var childContextTypes = interruptedWork.type.childContextTypes;

              if (childContextTypes !== null && childContextTypes !== undefined) {
                popContext(interruptedWork);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              break;
            }

          case HostComponent:
            {
              popHostContext(interruptedWork);
              break;
            }

          case HostPortal:
            popHostContainer(interruptedWork);
            break;

          case ContextProvider:
            popProvider(interruptedWork);
            break;

          default:
            break;
        }
      }

      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
      var didWarnAboutStateTransition = void 0;
      var didWarnSetStateChildContext = void 0;
      var warnAboutUpdateOnUnmounted = void 0;
      var warnAboutInvalidUpdates = void 0;

      if (enableSchedulerTracing) {
        invariant(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null, "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " + "without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. " + "Your bundler might have a setting for aliasing both modules. " + "Learn more at http://fb.me/react-profiling");
      }

      {
        didWarnAboutStateTransition = false;
        didWarnSetStateChildContext = false;
        var didWarnStateUpdateForUnmountedComponent = {};

        warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber, isClass) {
          var componentName = getComponentName(fiber.type) || "ReactComponent";

          if (didWarnStateUpdateForUnmountedComponent[componentName]) {
            return;
          }

          warningWithoutStack$1(false, "Can't perform a React state update on an unmounted component. This " + "is a no-op, but it indicates a memory leak in your application. To " + "fix, cancel all subscriptions and asynchronous tasks in %s.%s", isClass ? "the componentWillUnmount method" : "a useEffect cleanup function", getStackByFiberInDevAndProd(fiber));
          didWarnStateUpdateForUnmountedComponent[componentName] = true;
        };

        warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
          switch (phase) {
            case "getChildContext":
              if (didWarnSetStateChildContext) {
                return;
              }

              warningWithoutStack$1(false, "setState(...): Cannot call setState() inside getChildContext()");
              didWarnSetStateChildContext = true;
              break;

            case "render":
              if (didWarnAboutStateTransition) {
                return;
              }

              warningWithoutStack$1(false, "Cannot update during an existing state transition (such as within " + "`render`). Render methods should be a pure function of props and state.");
              didWarnAboutStateTransition = true;
              break;
          }
        };
      }
      var isWorking = false;
      var nextUnitOfWork = null;
      var nextRoot = null;
      var nextRenderExpirationTime = NoWork;
      var nextLatestAbsoluteTimeoutMs = -1;
      var nextRenderDidError = false;
      var nextEffect = null;
      var isCommitting$1 = false;
      var rootWithPendingPassiveEffects = null;
      var passiveEffectCallbackHandle = null;
      var passiveEffectCallback = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var interruptedBy = null;
      var stashedWorkInProgressProperties = void 0;
      var replayUnitOfWork = void 0;
      var mayReplayFailedUnitOfWork = void 0;
      var isReplayingFailedUnitOfWork = void 0;
      var originalReplayError = void 0;
      var rethrowOriginalError = void 0;

      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        stashedWorkInProgressProperties = null;
        mayReplayFailedUnitOfWork = true;
        isReplayingFailedUnitOfWork = false;
        originalReplayError = null;

        replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {
          if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
            return;
          }

          if (stashedWorkInProgressProperties === null) {
            warningWithoutStack$1(false, "Could not replay rendering after an error. This is likely a bug in React. " + "Please file an issue.");
            return;
          }

          assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);

          switch (failedUnitOfWork.tag) {
            case HostRoot:
              popHostContainer(failedUnitOfWork);
              popTopLevelContextObject(failedUnitOfWork);
              break;

            case HostComponent:
              popHostContext(failedUnitOfWork);
              break;

            case ClassComponent:
              {
                var Component = failedUnitOfWork.type;

                if (isContextProvider(Component)) {
                  popContext(failedUnitOfWork);
                }

                break;
              }

            case HostPortal:
              popHostContainer(failedUnitOfWork);
              break;

            case ContextProvider:
              popProvider(failedUnitOfWork);
              break;
          }

          isReplayingFailedUnitOfWork = true;
          originalReplayError = thrownValue;
          invokeGuardedCallback(null, workLoop, null, isYieldy);
          isReplayingFailedUnitOfWork = false;
          originalReplayError = null;

          if (hasCaughtError()) {
            var replayError = clearCaughtError();

            if (replayError != null && thrownValue != null) {
              try {
                if (replayError._suppressLogging) {
                  thrownValue._suppressLogging = true;
                }
              } catch (inner) {}
            }
          } else {
            nextUnitOfWork = failedUnitOfWork;
          }
        };

        rethrowOriginalError = function rethrowOriginalError() {
          throw originalReplayError;
        };
      }

      function resetStack() {
        if (nextUnitOfWork !== null) {
          var interruptedWork = nextUnitOfWork.return;

          while (interruptedWork !== null) {
            unwindInterruptedWork(interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }

        {
          ReactStrictModeWarnings.discardPendingWarnings();
          checkThatStackIsEmpty();
        }
        nextRoot = null;
        nextRenderExpirationTime = NoWork;
        nextLatestAbsoluteTimeoutMs = -1;
        nextRenderDidError = false;
        nextUnitOfWork = null;
      }

      function commitAllHostEffects() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          recordEffect();
          var effectTag = nextEffect.effectTag;

          if (effectTag & ContentReset) {
            commitResetTextContent(nextEffect);
          }

          if (effectTag & Ref) {
            var current$$1 = nextEffect.alternate;

            if (current$$1 !== null) {
              commitDetachRef(current$$1);
            }
          }

          var primaryEffectTag = effectTag & (Placement | Update | Deletion);

          switch (primaryEffectTag) {
            case Placement:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                break;
              }

            case PlacementAndUpdate:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                var _current = nextEffect.alternate;
                commitWork(_current, nextEffect);
                break;
              }

            case Update:
              {
                var _current2 = nextEffect.alternate;
                commitWork(_current2, nextEffect);
                break;
              }

            case Deletion:
              {
                commitDeletion(nextEffect);
                break;
              }
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitBeforeMutationLifecycles() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          var effectTag = nextEffect.effectTag;

          if (effectTag & Snapshot) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitBeforeMutationLifeCycles(current$$1, nextEffect);
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
        {
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          ReactStrictModeWarnings.flushLegacyContextWarning();

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.flushPendingDeprecationWarnings();
          }
        }

        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          var effectTag = nextEffect.effectTag;

          if (effectTag & (Update | Callback)) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);
          }

          if (effectTag & Ref) {
            recordEffect();
            commitAttachRef(nextEffect);
          }

          if (effectTag & Passive) {
            rootWithPendingPassiveEffects = finishedRoot;
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitPassiveEffects(root, firstEffect) {
        rootWithPendingPassiveEffects = null;
        passiveEffectCallbackHandle = null;
        passiveEffectCallback = null;
        var previousIsRendering = isRendering;
        isRendering = true;
        var effect = firstEffect;

        do {
          {
            setCurrentFiber(effect);
          }

          if (effect.effectTag & Passive) {
            var didError = false;
            var error = void 0;
            {
              invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);

              if (hasCaughtError()) {
                didError = true;
                error = clearCaughtError();
              }
            }

            if (didError) {
              captureCommitPhaseError(effect, error);
            }
          }

          effect = effect.nextEffect;
        } while (effect !== null);

        {
          resetCurrentFiber();
        }
        isRendering = previousIsRendering;
        var rootExpirationTime = root.expirationTime;

        if (rootExpirationTime !== NoWork) {
          requestWork(root, rootExpirationTime);
        }

        if (!isBatchingUpdates && !isRendering) {
          performSyncWork();
        }
      }

      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }

      function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance);
        }
      }

      function flushPassiveEffects() {
        if (passiveEffectCallbackHandle !== null) {
          cancelPassiveEffects(passiveEffectCallbackHandle);
        }

        if (passiveEffectCallback !== null) {
          passiveEffectCallback();
        }
      }

      function commitRoot(root, finishedWork) {
        isWorking = true;
        isCommitting$1 = true;
        startCommitTimer();
        invariant(root.current !== finishedWork, "Cannot commit the same tree as before. This is probably a bug " + "related to the return field. This error is likely caused by a bug " + "in React. Please file an issue.");
        var committedExpirationTime = root.pendingCommitExpirationTime;
        invariant(committedExpirationTime !== NoWork, "Cannot commit an incomplete root. This error is likely caused by a " + "bug in React. Please file an issue.");
        root.pendingCommitExpirationTime = NoWork;
        var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
        var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeBeforeCommit = childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
        markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);
        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        ReactCurrentOwner$2.current = null;
        var firstEffect = void 0;

        if (finishedWork.effectTag > PerformedWork) {
          if (finishedWork.lastEffect !== null) {
            finishedWork.lastEffect.nextEffect = finishedWork;
            firstEffect = finishedWork.firstEffect;
          } else {
            firstEffect = finishedWork;
          }
        } else {
          firstEffect = finishedWork.firstEffect;
        }

        prepareForCommit(root.containerInfo);
        nextEffect = firstEffect;
        startCommitSnapshotEffectsTimer();

        while (nextEffect !== null) {
          var didError = false;
          var error = void 0;
          {
            invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);

            if (hasCaughtError()) {
              didError = true;
              error = clearCaughtError();
            }
          }

          if (didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitSnapshotEffectsTimer();

        if (enableProfilerTimer) {
          recordCommitTime();
        }

        nextEffect = firstEffect;
        startCommitHostEffectsTimer();

        while (nextEffect !== null) {
          var _didError = false;

          var _error = void 0;

          {
            invokeGuardedCallback(null, commitAllHostEffects, null);

            if (hasCaughtError()) {
              _didError = true;
              _error = clearCaughtError();
            }
          }

          if (_didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitHostEffectsTimer();
        resetAfterCommit(root.containerInfo);
        root.current = finishedWork;
        nextEffect = firstEffect;
        startCommitLifeCyclesTimer();

        while (nextEffect !== null) {
          var _didError2 = false;

          var _error2 = void 0;

          {
            invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);

            if (hasCaughtError()) {
              _didError2 = true;
              _error2 = clearCaughtError();
            }
          }

          if (_didError2) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error2);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        if (firstEffect !== null && rootWithPendingPassiveEffects !== null) {
          var callback = commitPassiveEffects.bind(null, root, firstEffect);

          if (enableSchedulerTracing) {
            callback = tracing.unstable_wrap(callback);
          }

          passiveEffectCallbackHandle = scheduler.unstable_runWithPriority(scheduler.unstable_NormalPriority, function () {
            return schedulePassiveEffects(callback);
          });
          passiveEffectCallback = callback;
        }

        isCommitting$1 = false;
        isWorking = false;
        stopCommitLifeCyclesTimer();
        stopCommitTimer();
        onCommitRoot(finishedWork.stateNode);

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
        }

        var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
        var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeAfterCommit = childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;

        if (earliestRemainingTimeAfterCommit === NoWork) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }

        onCommit(root, earliestRemainingTimeAfterCommit);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
          var subscriber = void 0;

          try {
            subscriber = tracing.__subscriberRef.current;

            if (subscriber !== null && root.memoizedInteractions.size > 0) {
              var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
              subscriber.onWorkStopped(root.memoizedInteractions, threadID);
            }
          } catch (error) {
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          } finally {
            var pendingInteractionMap = root.pendingInteractionMap;
            pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
                pendingInteractionMap.delete(scheduledExpirationTime);
                scheduledInteractions.forEach(function (interaction) {
                  interaction.__count--;

                  if (subscriber !== null && interaction.__count === 0) {
                    try {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    } catch (error) {
                      if (!hasUnhandledError) {
                        hasUnhandledError = true;
                        unhandledError = error;
                      }
                    }
                  }
                });
              }
            });
          }
        }
      }

      function resetChildExpirationTime(workInProgress, renderTime) {
        if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
          return;
        }

        var newChildExpirationTime = NoWork;

        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
          var actualDuration = workInProgress.actualDuration;
          var treeBaseDuration = workInProgress.selfBaseDuration;
          var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;
          var child = workInProgress.child;

          while (child !== null) {
            var childUpdateExpirationTime = child.expirationTime;
            var childChildExpirationTime = child.childExpirationTime;

            if (childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childUpdateExpirationTime;
            }

            if (childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childChildExpirationTime;
            }

            if (shouldBubbleActualDurations) {
              actualDuration += child.actualDuration;
            }

            treeBaseDuration += child.treeBaseDuration;
            child = child.sibling;
          }

          workInProgress.actualDuration = actualDuration;
          workInProgress.treeBaseDuration = treeBaseDuration;
        } else {
          var _child = workInProgress.child;

          while (_child !== null) {
            var _childUpdateExpirationTime = _child.expirationTime;
            var _childChildExpirationTime = _child.childExpirationTime;

            if (_childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childUpdateExpirationTime;
            }

            if (_childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childChildExpirationTime;
            }

            _child = _child.sibling;
          }
        }

        workInProgress.childExpirationTime = newChildExpirationTime;
      }

      function completeUnitOfWork(workInProgress) {
        while (true) {
          var current$$1 = workInProgress.alternate;
          {
            setCurrentFiber(workInProgress);
          }
          var returnFiber = workInProgress.return;
          var siblingFiber = workInProgress.sibling;

          if ((workInProgress.effectTag & Incomplete) === NoEffect) {
            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = false;
            }

            nextUnitOfWork = workInProgress;

            if (enableProfilerTimer) {
              if (workInProgress.mode & ProfileMode) {
                startProfilerTimer(workInProgress);
              }

              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);

              if (workInProgress.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              }
            } else {
              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);
            }

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = true;
            }

            stopWorkTimer(workInProgress);
            resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
            {
              resetCurrentFiber();
            }

            if (nextUnitOfWork !== null) {
              return nextUnitOfWork;
            }

            if (returnFiber !== null && (returnFiber.effectTag & Incomplete) === NoEffect) {
              if (returnFiber.firstEffect === null) {
                returnFiber.firstEffect = workInProgress.firstEffect;
              }

              if (workInProgress.lastEffect !== null) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
                }

                returnFiber.lastEffect = workInProgress.lastEffect;
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag > PerformedWork) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress;
                } else {
                  returnFiber.firstEffect = workInProgress;
                }

                returnFiber.lastEffect = workInProgress;
              }
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          } else {
            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              var actualDuration = workInProgress.actualDuration;
              var child = workInProgress.child;

              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }

              workInProgress.actualDuration = actualDuration;
            }

            var next = unwindWork(workInProgress, nextRenderExpirationTime);

            if (workInProgress.effectTag & DidCapture) {
              stopFailedWorkTimer(workInProgress);
            } else {
              stopWorkTimer(workInProgress);
            }

            {
              resetCurrentFiber();
            }

            if (next !== null) {
              stopWorkTimer(workInProgress);

              if (true && ReactFiberInstrumentation_1.debugTool) {
                ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
              }

              next.effectTag &= HostEffectMask;
              return next;
            }

            if (returnFiber !== null) {
              returnFiber.firstEffect = returnFiber.lastEffect = null;
              returnFiber.effectTag |= Incomplete;
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          }
        }

        return null;
      }

      function performUnitOfWork(workInProgress) {
        var current$$1 = workInProgress.alternate;
        startWorkTimer(workInProgress);
        {
          setCurrentFiber(workInProgress);
        }

        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
          stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);
        }

        var next = void 0;

        if (enableProfilerTimer) {
          if (workInProgress.mode & ProfileMode) {
            startProfilerTimer(workInProgress);
          }

          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;

          if (workInProgress.mode & ProfileMode) {
            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
          }
        } else {
          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;
        }

        {
          resetCurrentFiber();

          if (isReplayingFailedUnitOfWork) {
            rethrowOriginalError();
          }
        }

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
        }

        if (next === null) {
          next = completeUnitOfWork(workInProgress);
        }

        ReactCurrentOwner$2.current = null;
        return next;
      }

      function workLoop(isYieldy) {
        if (!isYieldy) {
          while (nextUnitOfWork !== null) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        } else {
          while (nextUnitOfWork !== null && !shouldYield$$1()) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        }
      }

      function renderRoot(root, isYieldy) {
        invariant(!isWorking, "renderRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        flushPassiveEffects();
        isWorking = true;
        var previousDispatcher = ReactCurrentDispatcher.current;
        ReactCurrentDispatcher.current = ContextOnlyDispatcher;
        var expirationTime = root.nextExpirationTimeToWorkOn;

        if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
          resetStack();
          nextRoot = root;
          nextRenderExpirationTime = expirationTime;
          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);
          root.pendingCommitExpirationTime = NoWork;

          if (enableSchedulerTracing) {
            var interactions = new Set();
            root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime >= expirationTime) {
                scheduledInteractions.forEach(function (interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root.memoizedInteractions = interactions;

            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;

              if (subscriber !== null) {
                var threadID = computeThreadID(expirationTime, root.interactionThreadID);

                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error) {
                  if (!hasUnhandledError) {
                    hasUnhandledError = true;
                    unhandledError = error;
                  }
                }
              }
            }
          }
        }

        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        var didFatal = false;
        startWorkLoopTimer(nextUnitOfWork);

        do {
          try {
            workLoop(isYieldy);
          } catch (thrownValue) {
            resetContextDependences();
            resetHooks();
            var mayReplay = void 0;

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplay = mayReplayFailedUnitOfWork;
              mayReplayFailedUnitOfWork = true;
            }

            if (nextUnitOfWork === null) {
              didFatal = true;
              onUncaughtError(thrownValue);
            } else {
              if (enableProfilerTimer && nextUnitOfWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);
              }

              {
                resetCurrentlyProcessingQueue();
              }

              if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
                if (mayReplay) {
                  var failedUnitOfWork = nextUnitOfWork;
                  replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
                }
              }

              invariant(nextUnitOfWork !== null, "Failed to replay rendering after an error. This " + "is likely caused by a bug in React. Please file an issue " + "with a reproducing case to help us find it.");
              var sourceFiber = nextUnitOfWork;
              var returnFiber = sourceFiber.return;

              if (returnFiber === null) {
                didFatal = true;
                onUncaughtError(thrownValue);
              } else {
                throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
                nextUnitOfWork = completeUnitOfWork(sourceFiber);
                continue;
              }
            }
          }

          break;
        } while (true);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
        }

        isWorking = false;
        ReactCurrentDispatcher.current = previousDispatcher;
        resetContextDependences();
        resetHooks();

        if (didFatal) {
          var _didCompleteRoot = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
          interruptedBy = null;
          {
            resetStackAfterFatalErrorInDev();
          }
          nextRoot = null;
          onFatal(root);
          return;
        }

        if (nextUnitOfWork !== null) {
          var _didCompleteRoot2 = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
          interruptedBy = null;
          onYield(root);
          return;
        }

        var didCompleteRoot = true;
        stopWorkLoopTimer(interruptedBy, didCompleteRoot);
        var rootWorkInProgress = root.current.alternate;
        invariant(rootWorkInProgress !== null, "Finished root should have a work-in-progress. This error is likely " + "caused by a bug in React. Please file an issue.");
        nextRoot = null;
        interruptedBy = null;

        if (nextRenderDidError) {
          if (hasLowerPriorityWork(root, expirationTime)) {
            markSuspendedPriorityLevel(root, expirationTime);
            var suspendedExpirationTime = expirationTime;
            var rootExpirationTime = root.expirationTime;
            onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1);
            return;
          } else if (!root.didError && isYieldy) {
            root.didError = true;

            var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;

            var _rootExpirationTime = root.expirationTime = Sync;

            onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1);
            return;
          }
        }

        if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
          var _suspendedExpirationTime2 = expirationTime;
          markSuspendedPriorityLevel(root, _suspendedExpirationTime2);
          var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);
          var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);

          if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
            nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
          }

          var currentTimeMs = expirationTimeToMs(requestCurrentTime());
          var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
          msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;
          var _rootExpirationTime2 = root.expirationTime;
          onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
          return;
        }

        onComplete(root, rootWorkInProgress, expirationTime);
      }

      function captureCommitPhaseError(sourceFiber, value) {
        var expirationTime = Sync;
        var fiber = sourceFiber.return;

        while (fiber !== null) {
          switch (fiber.tag) {
            case ClassComponent:
              var ctor = fiber.type;
              var instance = fiber.stateNode;

              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValue(value, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
                enqueueUpdate(fiber, update);
                scheduleWork(fiber, expirationTime);
                return;
              }

              break;

            case HostRoot:
              {
                var _errorInfo = createCapturedValue(value, sourceFiber);

                var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);

                enqueueUpdate(fiber, _update);
                scheduleWork(fiber, expirationTime);
                return;
              }
          }

          fiber = fiber.return;
        }

        if (sourceFiber.tag === HostRoot) {
          var rootFiber = sourceFiber;

          var _errorInfo2 = createCapturedValue(value, rootFiber);

          var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);

          enqueueUpdate(rootFiber, _update2);
          scheduleWork(rootFiber, expirationTime);
        }
      }

      function computeThreadID(expirationTime, interactionThreadID) {
        return expirationTime * 1000 + interactionThreadID;
      }

      function computeExpirationForFiber(currentTime, fiber) {
        var priorityLevel = scheduler.unstable_getCurrentPriorityLevel();
        var expirationTime = void 0;

        if ((fiber.mode & ConcurrentMode) === NoContext) {
          expirationTime = Sync;
        } else if (isWorking && !isCommitting$1) {
          expirationTime = nextRenderExpirationTime;
        } else {
          switch (priorityLevel) {
            case scheduler.unstable_ImmediatePriority:
              expirationTime = Sync;
              break;

            case scheduler.unstable_UserBlockingPriority:
              expirationTime = computeInteractiveExpiration(currentTime);
              break;

            case scheduler.unstable_NormalPriority:
              expirationTime = computeAsyncExpiration(currentTime);
              break;

            case scheduler.unstable_LowPriority:
            case scheduler.unstable_IdlePriority:
              expirationTime = Never;
              break;

            default:
              invariant(false, "Unknown priority level. This error is likely caused by a bug in " + "React. Please file an issue.");
          }

          if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
            expirationTime -= 1;
          }
        }

        if (priorityLevel === scheduler.unstable_UserBlockingPriority && (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime < lowestPriorityPendingInteractiveExpirationTime)) {
          lowestPriorityPendingInteractiveExpirationTime = expirationTime;
        }

        return expirationTime;
      }

      function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
        if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
          nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
        }
      }

      function renderDidError() {
        nextRenderDidError = true;
      }

      function pingSuspendedRoot(root, thenable, pingTime) {
        var pingCache = root.pingCache;

        if (pingCache !== null) {
          pingCache.delete(thenable);
        }

        if (nextRoot !== null && nextRenderExpirationTime === pingTime) {
          nextRoot = null;
        } else {
          if (isPriorityLevelSuspended(root, pingTime)) {
            markPingedPriorityLevel(root, pingTime);
            var rootExpirationTime = root.expirationTime;

            if (rootExpirationTime !== NoWork) {
              requestWork(root, rootExpirationTime);
            }
          }
        }
      }

      function retryTimedOutBoundary(boundaryFiber) {
        var currentTime = requestCurrentTime();
        var retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
        var root = scheduleWorkToRoot(boundaryFiber, retryTime);

        if (root !== null) {
          markPendingPriorityLevel(root, retryTime);
          var rootExpirationTime = root.expirationTime;

          if (rootExpirationTime !== NoWork) {
            requestWork(root, rootExpirationTime);
          }
        }
      }

      function resolveRetryThenable(boundaryFiber, thenable) {
        var retryCache = void 0;

        if (enableSuspenseServerRenderer) {
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              break;

            case DehydratedSuspenseComponent:
              retryCache = boundaryFiber.memoizedState;
              break;

            default:
              invariant(false, "Pinged unknown suspense boundary type. " + "This is probably a bug in React.");
          }
        } else {
          retryCache = boundaryFiber.stateNode;
        }

        if (retryCache !== null) {
          retryCache.delete(thenable);
        }

        retryTimedOutBoundary(boundaryFiber);
      }

      function scheduleWorkToRoot(fiber, expirationTime) {
        recordScheduleUpdate();
        {
          if (fiber.tag === ClassComponent) {
            var instance = fiber.stateNode;
            warnAboutInvalidUpdates(instance);
          }
        }

        if (fiber.expirationTime < expirationTime) {
          fiber.expirationTime = expirationTime;
        }

        var alternate = fiber.alternate;

        if (alternate !== null && alternate.expirationTime < expirationTime) {
          alternate.expirationTime = expirationTime;
        }

        var node = fiber.return;
        var root = null;

        if (node === null && fiber.tag === HostRoot) {
          root = fiber.stateNode;
        } else {
          while (node !== null) {
            alternate = node.alternate;

            if (node.childExpirationTime < expirationTime) {
              node.childExpirationTime = expirationTime;

              if (alternate !== null && alternate.childExpirationTime < expirationTime) {
                alternate.childExpirationTime = expirationTime;
              }
            } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {
              alternate.childExpirationTime = expirationTime;
            }

            if (node.return === null && node.tag === HostRoot) {
              root = node.stateNode;
              break;
            }

            node = node.return;
          }
        }

        if (enableSchedulerTracing) {
          if (root !== null) {
            var interactions = tracing.__interactionsRef.current;

            if (interactions.size > 0) {
              var pendingInteractionMap = root.pendingInteractionMap;
              var pendingInteractions = pendingInteractionMap.get(expirationTime);

              if (pendingInteractions != null) {
                interactions.forEach(function (interaction) {
                  if (!pendingInteractions.has(interaction)) {
                    interaction.__count++;
                  }

                  pendingInteractions.add(interaction);
                });
              } else {
                pendingInteractionMap.set(expirationTime, new Set(interactions));
                interactions.forEach(function (interaction) {
                  interaction.__count++;
                });
              }

              var subscriber = tracing.__subscriberRef.current;

              if (subscriber !== null) {
                var threadID = computeThreadID(expirationTime, root.interactionThreadID);
                subscriber.onWorkScheduled(interactions, threadID);
              }
            }
          }
        }

        return root;
      }

      function warnIfNotCurrentlyBatchingInDev(fiber) {
        {
          if (isRendering === false && isBatchingUpdates === false) {
            warningWithoutStack$1(false, "An update to %s inside a test was not wrapped in act(...).\n\n" + "When testing, code that causes React state updates should be wrapped into act(...):\n\n" + "act(() => {\n" + "  /* fire events that update state */\n" + "});\n" + "/* assert on the output */\n\n" + "This ensures that you're testing the behavior the user would see in the browser." + " Learn more at https://fb.me/react-wrap-tests-with-act" + "%s", getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));
          }
        }
      }

      function scheduleWork(fiber, expirationTime) {
        var root = scheduleWorkToRoot(fiber, expirationTime);

        if (root === null) {
          {
            switch (fiber.tag) {
              case ClassComponent:
                warnAboutUpdateOnUnmounted(fiber, true);
                break;

              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
                warnAboutUpdateOnUnmounted(fiber, false);
                break;
            }
          }
          return;
        }

        if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime > nextRenderExpirationTime) {
          interruptedBy = fiber;
          resetStack();
        }

        markPendingPriorityLevel(root, expirationTime);

        if (!isWorking || isCommitting$1 || nextRoot !== root) {
          var rootExpirationTime = root.expirationTime;
          requestWork(root, rootExpirationTime);
        }

        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          invariant(false, "Maximum update depth exceeded. This can happen when a " + "component repeatedly calls setState inside " + "componentWillUpdate or componentDidUpdate. React limits " + "the number of nested updates to prevent infinite loops.");
        }
      }

      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var callbackExpirationTime = NoWork;
      var callbackID = void 0;
      var isRendering = false;
      var nextFlushedRoot = null;
      var nextFlushedExpirationTime = NoWork;
      var lowestPriorityPendingInteractiveExpirationTime = NoWork;
      var hasUnhandledError = false;
      var unhandledError = null;
      var isBatchingUpdates = false;
      var isUnbatchingUpdates = false;
      var completedBatches = null;
      var originalStartTimeMs = now$$1();
      var currentRendererTime = msToExpirationTime(originalStartTimeMs);
      var currentSchedulerTime = currentRendererTime;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var lastCommittedRootDuringThisBatch = null;

      function recomputeCurrentRendererTime() {
        var currentTimeMs = now$$1() - originalStartTimeMs;
        currentRendererTime = msToExpirationTime(currentTimeMs);
      }

      function scheduleCallbackWithExpirationTime(root, expirationTime) {
        if (callbackExpirationTime !== NoWork) {
          if (expirationTime < callbackExpirationTime) {
            return;
          } else {
            if (callbackID !== null) {
              cancelDeferredCallback$$1(callbackID);
            }
          }
        } else {
          startRequestCallbackTimer();
        }

        callbackExpirationTime = expirationTime;
        var currentMs = now$$1() - originalStartTimeMs;
        var expirationTimeMs = expirationTimeToMs(expirationTime);
        var timeout = expirationTimeMs - currentMs;
        callbackID = scheduleDeferredCallback$$1(performAsyncWork, {
          timeout: timeout
        });
      }

      function onFatal(root) {
        root.finishedWork = null;
      }

      function onComplete(root, finishedWork, expirationTime) {
        root.pendingCommitExpirationTime = expirationTime;
        root.finishedWork = finishedWork;
      }

      function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
        root.expirationTime = rootExpirationTime;

        if (msUntilTimeout === 0 && !shouldYield$$1()) {
          root.pendingCommitExpirationTime = suspendedExpirationTime;
          root.finishedWork = finishedWork;
        } else if (msUntilTimeout > 0) {
          root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
        }
      }

      function onYield(root) {
        root.finishedWork = null;
      }

      function onTimeout(root, finishedWork, suspendedExpirationTime) {
        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;
        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;
        flushRoot(root, suspendedExpirationTime);
      }

      function onCommit(root, expirationTime) {
        root.expirationTime = expirationTime;
        root.finishedWork = null;
      }

      function requestCurrentTime() {
        if (isRendering) {
          return currentSchedulerTime;
        }

        findHighestPriorityRoot();

        if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;
          return currentSchedulerTime;
        }

        return currentSchedulerTime;
      }

      function requestWork(root, expirationTime) {
        addRootToSchedule(root, expirationTime);

        if (isRendering) {
          return;
        }

        if (isBatchingUpdates) {
          if (isUnbatchingUpdates) {
            nextFlushedRoot = root;
            nextFlushedExpirationTime = Sync;
            performWorkOnRoot(root, Sync, false);
          }

          return;
        }

        if (expirationTime === Sync) {
          performSyncWork();
        } else {
          scheduleCallbackWithExpirationTime(root, expirationTime);
        }
      }

      function addRootToSchedule(root, expirationTime) {
        if (root.nextScheduledRoot === null) {
          root.expirationTime = expirationTime;

          if (lastScheduledRoot === null) {
            firstScheduledRoot = lastScheduledRoot = root;
            root.nextScheduledRoot = root;
          } else {
            lastScheduledRoot.nextScheduledRoot = root;
            lastScheduledRoot = root;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          }
        } else {
          var remainingExpirationTime = root.expirationTime;

          if (expirationTime > remainingExpirationTime) {
            root.expirationTime = expirationTime;
          }
        }
      }

      function findHighestPriorityRoot() {
        var highestPriorityWork = NoWork;
        var highestPriorityRoot = null;

        if (lastScheduledRoot !== null) {
          var previousScheduledRoot = lastScheduledRoot;
          var root = firstScheduledRoot;

          while (root !== null) {
            var remainingExpirationTime = root.expirationTime;

            if (remainingExpirationTime === NoWork) {
              invariant(previousScheduledRoot !== null && lastScheduledRoot !== null, "Should have a previous and last root. This error is likely " + "caused by a bug in React. Please file an issue.");

              if (root === root.nextScheduledRoot) {
                root.nextScheduledRoot = null;
                firstScheduledRoot = lastScheduledRoot = null;
                break;
              } else if (root === firstScheduledRoot) {
                var next = root.nextScheduledRoot;
                firstScheduledRoot = next;
                lastScheduledRoot.nextScheduledRoot = next;
                root.nextScheduledRoot = null;
              } else if (root === lastScheduledRoot) {
                lastScheduledRoot = previousScheduledRoot;
                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                root.nextScheduledRoot = null;
                break;
              } else {
                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
                root.nextScheduledRoot = null;
              }

              root = previousScheduledRoot.nextScheduledRoot;
            } else {
              if (remainingExpirationTime > highestPriorityWork) {
                highestPriorityWork = remainingExpirationTime;
                highestPriorityRoot = root;
              }

              if (root === lastScheduledRoot) {
                break;
              }

              if (highestPriorityWork === Sync) {
                break;
              }

              previousScheduledRoot = root;
              root = root.nextScheduledRoot;
            }
          }
        }

        nextFlushedRoot = highestPriorityRoot;
        nextFlushedExpirationTime = highestPriorityWork;
      }

      function performAsyncWork(didTimeout) {
        if (didTimeout) {
          if (firstScheduledRoot !== null) {
            recomputeCurrentRendererTime();
            var root = firstScheduledRoot;

            do {
              didExpireAtExpirationTime(root, currentRendererTime);
              root = root.nextScheduledRoot;
            } while (root !== firstScheduledRoot);
          }
        }

        performWork(NoWork, true);
      }

      function performSyncWork() {
        performWork(Sync, false);
      }

      function performWork(minExpirationTime, isYieldy) {
        findHighestPriorityRoot();

        if (isYieldy) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;

          if (enableUserTimingAPI) {
            var didExpire = nextFlushedExpirationTime > currentRendererTime;
            var timeout = expirationTimeToMs(nextFlushedExpirationTime);
            stopRequestCallbackTimer(didExpire, timeout);
          }

          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime && !(shouldYield$$1() && currentRendererTime > nextFlushedExpirationTime)) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime);
            findHighestPriorityRoot();
            recomputeCurrentRendererTime();
            currentSchedulerTime = currentRendererTime;
          }
        } else {
          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
            findHighestPriorityRoot();
          }
        }

        if (isYieldy) {
          callbackExpirationTime = NoWork;
          callbackID = null;
        }

        if (nextFlushedExpirationTime !== NoWork) {
          scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
        }

        finishRendering();
      }

      function flushRoot(root, expirationTime) {
        invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely " + "means you attempted to commit from inside a lifecycle method.");
        nextFlushedRoot = root;
        nextFlushedExpirationTime = expirationTime;
        performWorkOnRoot(root, expirationTime, false);
        performSyncWork();
      }

      function finishRendering() {
        nestedUpdateCount = 0;
        lastCommittedRootDuringThisBatch = null;

        if (completedBatches !== null) {
          var batches = completedBatches;
          completedBatches = null;

          for (var i = 0; i < batches.length; i++) {
            var batch = batches[i];

            try {
              batch._onComplete();
            } catch (error) {
              if (!hasUnhandledError) {
                hasUnhandledError = true;
                unhandledError = error;
              }
            }
          }
        }

        if (hasUnhandledError) {
          var error = unhandledError;
          unhandledError = null;
          hasUnhandledError = false;
          throw error;
        }
      }

      function performWorkOnRoot(root, expirationTime, isYieldy) {
        invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        isRendering = true;

        if (!isYieldy) {
          var finishedWork = root.finishedWork;

          if (finishedWork !== null) {
            completeRoot(root, finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var timeoutHandle = root.timeoutHandle;

            if (timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }

            renderRoot(root, isYieldy);
            finishedWork = root.finishedWork;

            if (finishedWork !== null) {
              completeRoot(root, finishedWork, expirationTime);
            }
          }
        } else {
          var _finishedWork = root.finishedWork;

          if (_finishedWork !== null) {
            completeRoot(root, _finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var _timeoutHandle = root.timeoutHandle;

            if (_timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(_timeoutHandle);
            }

            renderRoot(root, isYieldy);
            _finishedWork = root.finishedWork;

            if (_finishedWork !== null) {
              if (!shouldYield$$1()) {
                completeRoot(root, _finishedWork, expirationTime);
              } else {
                root.finishedWork = _finishedWork;
              }
            }
          }
        }

        isRendering = false;
      }

      function completeRoot(root, finishedWork, expirationTime) {
        var firstBatch = root.firstBatch;

        if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
          if (completedBatches === null) {
            completedBatches = [firstBatch];
          } else {
            completedBatches.push(firstBatch);
          }

          if (firstBatch._defer) {
            root.finishedWork = finishedWork;
            root.expirationTime = NoWork;
            return;
          }
        }

        root.finishedWork = null;

        if (root === lastCommittedRootDuringThisBatch) {
          nestedUpdateCount++;
        } else {
          lastCommittedRootDuringThisBatch = root;
          nestedUpdateCount = 0;
        }

        scheduler.unstable_runWithPriority(scheduler.unstable_ImmediatePriority, function () {
          commitRoot(root, finishedWork);
        });
      }

      function onUncaughtError(error) {
        invariant(nextFlushedRoot !== null, "Should be working on a root. This error is likely caused by a bug in " + "React. Please file an issue.");
        nextFlushedRoot.expirationTime = NoWork;

        if (!hasUnhandledError) {
          hasUnhandledError = true;
          unhandledError = error;
        }
      }

      function batchedUpdates$1(fn, a) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return fn(a);
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function interactiveUpdates$1(fn, a, b) {
        if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }

        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return scheduler.unstable_runWithPriority(scheduler.unstable_UserBlockingPriority, function () {
            return fn(a, b);
          });
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function flushInteractiveUpdates$1() {
        if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }
      }

      var didWarnAboutNestedUpdates = void 0;
      var didWarnAboutFindNodeInStrictMode = void 0;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }

      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }

        var fiber = get$1(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);

        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;

          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }

        return parentContext;
      }

      function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
        {
          if (phase === "render" && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            warningWithoutStack$1(false, "Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + "If necessary, trigger nested updates in componentDidUpdate.\n\n" + "Check the render method of %s.", getComponentName(current.type) || "Unknown");
          }
        }
        var update = createUpdate(expirationTime);
        update.payload = {
          element: element
        };
        callback = callback === undefined ? null : callback;

        if (callback !== null) {
          !(typeof callback === "function") ? warningWithoutStack$1(false, "render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback) : void 0;
          update.callback = callback;
        }

        flushPassiveEffects();
        enqueueUpdate(current$$1, update);
        scheduleWork(current$$1, expirationTime);
        return expirationTime;
      }

      function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
        var current$$1 = container.current;
        {
          if (ReactFiberInstrumentation_1.debugTool) {
            if (current$$1.alternate === null) {
              ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
            } else if (element === null) {
              ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
            } else {
              ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
            }
          }
        }
        var context = getContextForSubtree(parentComponent);

        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }

        return scheduleRootUpdate(current$$1, element, expirationTime, callback);
      }

      function findHostInstance(component) {
        var fiber = get$1(component);

        if (fiber === undefined) {
          if (typeof component.render === "function") {
            invariant(false, "Unable to find node on an unmounted component.");
          } else {
            invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
          }
        }

        var hostFiber = findCurrentHostFiber(fiber);

        if (hostFiber === null) {
          return null;
        }

        return hostFiber.stateNode;
      }

      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get$1(component);

          if (fiber === undefined) {
            if (typeof component.render === "function") {
              invariant(false, "Unable to find node on an unmounted component.");
            } else {
              invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
            }
          }

          var hostFiber = findCurrentHostFiber(fiber);

          if (hostFiber === null) {
            return null;
          }

          if (hostFiber.mode & StrictMode) {
            var componentName = getComponentName(fiber.type) || "Component";

            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;

              if (fiber.mode & StrictMode) {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which is inside StrictMode. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              } else {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which renders StrictMode children. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              }
            }
          }

          return hostFiber.stateNode;
        }
        return findHostInstance(component);
      }

      function createContainer(containerInfo, isConcurrent, hydrate) {
        return createFiberRoot(containerInfo, isConcurrent, hydrate);
      }

      function updateContainer(element, container, parentComponent, callback) {
        var current$$1 = container.current;
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, current$$1);
        return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
      }

      function getPublicRootInstance(container) {
        var containerFiber = container.current;

        if (!containerFiber.child) {
          return null;
        }

        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);

          default:
            return containerFiber.child.stateNode;
        }
      }

      var overrideProps = null;
      {
        var copyWithSetImpl = function copyWithSetImpl(obj, path, idx, value) {
          if (idx >= path.length) {
            return value;
          }

          var key = path[idx];
          var updated = Array.isArray(obj) ? obj.slice() : _extends({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
          return updated;
        };

        var copyWithSet = function copyWithSet(obj, path, value) {
          return copyWithSetImpl(obj, path, 0, value);
        };

        overrideProps = function overrideProps(fiber, path, value) {
          flushPassiveEffects();
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);

          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }

          scheduleWork(fiber, Sync);
        };
      }

      function injectIntoDevTools(devToolsConfig) {
        var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals(_extends({}, devToolsConfig, {
          overrideProps: overrideProps,
          currentDispatcherRef: ReactCurrentDispatcher,
          findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);

            if (hostFiber === null) {
              return null;
            }

            return hostFiber.stateNode;
          },
          findFiberByHostInstance: function findFiberByHostInstance(instance) {
            if (!_findFiberByHostInstance) {
              return null;
            }

            return _findFiberByHostInstance(instance);
          }
        }));
      }

      function _createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children: children,
          containerInfo: containerInfo,
          implementation: implementation
        };
      }

      var ReactVersion = "16.8.3";

      var NativeMethodsMixin = function NativeMethodsMixin(findNodeHandle, findHostInstance) {
        var NativeMethodsMixin = {
          measure: function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureInWindow: function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          },
          setNativeProps: function setNativeProps(nativeProps) {
            {
              if (warnAboutDeprecatedSetNativeProps) {
                warningWithoutStack$1(false, "Warning: Calling ref.setNativeProps(nativeProps) " + "is deprecated and will be removed in a future release. " + "Use the setNativeProps export from the react-native package instead." + "\n\timport {setNativeProps} from 'react-native';\n\tsetNativeProps(ref, nativeProps);\n");
              }
            }
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var nativeTag = maybeInstance._nativeTag || maybeInstance.canonical._nativeTag;
            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            {
              warnForStyleProps(nativeProps, viewConfig.validAttributes);
            }
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          },
          focus: function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          },
          blur: function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          }
        };
        {
          var NativeMethodsMixin_DEV = NativeMethodsMixin;
          invariant(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps && !NativeMethodsMixin_DEV.UNSAFE_componentWillMount && !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps, "Do not override existing functions.");

          NativeMethodsMixin_DEV.componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;
          NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;
        }
        return NativeMethodsMixin;
      };

      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var ReactNativeComponent = function ReactNativeComponent(findNodeHandle, findHostInstance) {
        var ReactNativeComponent = function (_React$Component) {
          _inherits(ReactNativeComponent, _React$Component);

          function ReactNativeComponent() {
            _classCallCheck$1(this, ReactNativeComponent);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
          }

          ReactNativeComponent.prototype.blur = function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.focus = function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.measure = function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureInWindow = function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          };

          ReactNativeComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
            {
              if (warnAboutDeprecatedSetNativeProps) {
                warningWithoutStack$1(false, "Warning: Calling ref.setNativeProps(nativeProps) " + "is deprecated and will be removed in a future release. " + "Use the setNativeProps export from the react-native package instead." + "\n\timport {setNativeProps} from 'react-native';\n\tsetNativeProps(ref, nativeProps);\n");
              }
            }
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var nativeTag = maybeInstance._nativeTag || maybeInstance.canonical._nativeTag;
            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          };

          return ReactNativeComponent;
        }(React.Component);

        return ReactNativeComponent;
      };

      var emptyObject$1 = {};
      {
        Object.freeze(emptyObject$1);
      }
      var getInspectorDataForViewTag = void 0;
      {
        var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {
          if (instance) {
            hierarchy.unshift(instance);
            traverseOwnerTreeUp(hierarchy, instance._debugOwner);
          }
        };

        var getOwnerHierarchy = function getOwnerHierarchy(instance) {
          var hierarchy = [];
          traverseOwnerTreeUp(hierarchy, instance);
          return hierarchy;
        };

        var lastNonHostInstance = function lastNonHostInstance(hierarchy) {
          for (var i = hierarchy.length - 1; i > 1; i--) {
            var instance = hierarchy[i];

            if (instance.tag !== HostComponent) {
              return instance;
            }
          }

          return hierarchy[0];
        };

        var getHostProps = function getHostProps(fiber) {
          var host = findCurrentHostFiber(fiber);

          if (host) {
            return host.memoizedProps || emptyObject$1;
          }

          return emptyObject$1;
        };

        var getHostNode = function getHostNode(fiber, findNodeHandle) {
          var hostNode = void 0;

          while (fiber) {
            if (fiber.stateNode !== null && fiber.tag === HostComponent) {
              hostNode = findNodeHandle(fiber.stateNode);
            }

            if (hostNode) {
              return hostNode;
            }

            fiber = fiber.child;
          }

          return null;
        };

        var createHierarchy = function createHierarchy(fiberHierarchy) {
          return fiberHierarchy.map(function (fiber) {
            return {
              name: getComponentName(fiber.type),
              getInspectorData: function getInspectorData(findNodeHandle) {
                return {
                  measure: function measure(callback) {
                    return UIManager.measure(getHostNode(fiber, findNodeHandle), callback);
                  },
                  props: getHostProps(fiber),
                  source: fiber._debugSource
                };
              }
            };
          });
        };

        getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {
          var closestInstance = getInstanceFromTag(viewTag);

          if (!closestInstance) {
            return {
              hierarchy: [],
              props: emptyObject$1,
              selection: null,
              source: null
            };
          }

          var fiber = findCurrentFiberUsingSlowPath(closestInstance);
          var fiberHierarchy = getOwnerHierarchy(fiber);
          var instance = lastNonHostInstance(fiberHierarchy);
          var hierarchy = createHierarchy(fiberHierarchy);
          var props = getHostProps(instance);
          var source = instance._debugSource;
          var selection = fiberHierarchy.indexOf(instance);
          return {
            hierarchy: hierarchy,
            props: props,
            selection: selection,
            source: source
          };
        };
      }

      function setNativeProps(handle, nativeProps) {
        if (handle._nativeTag == null) {
          !(handle._nativeTag != null) ? warningWithoutStack$1(false, "setNativeProps was called with a ref that isn't a " + "native component. Use React.forwardRef to get access to the underlying native component") : void 0;
          return;
        }

        {
          warnForStyleProps(nativeProps, handle.viewConfig.validAttributes);
        }
        var updatePayload = create(nativeProps, handle.viewConfig.validAttributes);

        if (updatePayload != null) {
          UIManager.updateView(handle._nativeTag, handle.viewConfig.uiViewClassName, updatePayload);
        }
      }

      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;

      function findNodeHandle(componentOrHandle) {
        {
          var owner = ReactCurrentOwner.current;

          if (owner !== null && owner.stateNode !== null) {
            !owner.stateNode._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing findNodeHandle inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(owner.type) || "A component") : void 0;
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }

        if (componentOrHandle == null) {
          return null;
        }

        if (typeof componentOrHandle === "number") {
          return componentOrHandle;
        }

        if (componentOrHandle._nativeTag) {
          return componentOrHandle._nativeTag;
        }

        if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
          return componentOrHandle.canonical._nativeTag;
        }

        var hostInstance = void 0;
        {
          hostInstance = findHostInstanceWithWarning(componentOrHandle, "findNodeHandle");
        }

        if (hostInstance == null) {
          return hostInstance;
        }

        if (hostInstance.canonical) {
          return hostInstance.canonical._nativeTag;
        }

        return hostInstance._nativeTag;
      }

      setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);

      function computeComponentStackForErrorReporting(reactTag) {
        var fiber = getInstanceFromTag(reactTag);

        if (!fiber) {
          return "";
        }

        return getStackByFiberInDevAndProd(fiber);
      }

      var roots = new Map();
      var ReactNativeRenderer = {
        NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),
        findNodeHandle: findNodeHandle,
        setNativeProps: setNativeProps,
        render: function render(element, containerTag, callback) {
          var root = roots.get(containerTag);

          if (!root) {
            root = createContainer(containerTag, false, false);
            roots.set(containerTag, root);
          }

          updateContainer(element, root, null, callback);
          return getPublicRootInstance(root);
        },
        unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
          var root = roots.get(containerTag);

          if (root) {
            updateContainer(null, root, null, function () {
              roots.delete(containerTag);
            });
          }
        },
        unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {
          ReactNativeRenderer.unmountComponentAtNode(containerTag);
          UIManager.removeRootView(containerTag);
        },
        createPortal: function createPortal(children, containerTag) {
          var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return _createPortal(children, containerTag, null, key);
        },
        unstable_batchedUpdates: batchedUpdates,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
          NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),
          computeComponentStackForErrorReporting: computeComponentStackForErrorReporting
        }
      };
      injectIntoDevTools({
        findFiberByHostInstance: getInstanceFromTag,
        getInspectorDataForViewTag: getInspectorDataForViewTag,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-native-renderer"
      });
      var ReactNativeRenderer$2 = Object.freeze({
        default: ReactNativeRenderer
      });
      var ReactNativeRenderer$3 = ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;
      var reactNativeRenderer = ReactNativeRenderer$3.default || ReactNativeRenderer$3;
      module.exports = reactNativeRenderer;
    })();
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Renderer_oss_ReactNativeRenderer-dev.js",["node_modules_@babel_runtime_helpers_extends.js","node_modules_react-native_Libraries_Core_InitializeCore.js","node_modules_react-native_Libraries_Renderer_shims_ReactNativeViewConfigRegistry.js","node_modules_react-native_Libraries_ReactNative_UIManager.js","node_modules_react-native_Libraries_EventEmitter_RCTEventEmitter.js","node_modules_react_index.js","node_modules_react-native_Libraries_Utilities_deepFreezeAndThrowOnMutationInDev.js","node_modules_react-native_Libraries_Utilities_differ_deepDiffer.js","node_modules_react-native_Libraries_StyleSheet_flattenStyle.js","node_modules_react-native_Libraries_Components_TextInput_TextInputState.js","system_2d01160272669884793b18983a46dcd0_node_modules_prop-types_checkPropTypes.js","system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_tracing.js","node_modules_scheduler_index.js","node_modules_react-native_Libraries_Core_ExceptionsManager.js"],"node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _regeneratorRuntime = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/regenerator");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var getDevServer = _$$_REQUIRE(_dependencyMap[2], "getDevServer");

  var _require = _$$_REQUIRE(_dependencyMap[3], "NativeModules"),
      SourceCode = _require.SourceCode;

  var fetch;

  function isSourcedFromDisk(sourcePath) {
    return !/^http/.test(sourcePath) && /[\\/]/.test(sourcePath);
  }

  function symbolicateStackTrace(stack) {
    var devServer, stackCopy, foundInternalSource, response, json;
    return _regeneratorRuntime.async(function symbolicateStackTrace$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!fetch) {
              fetch = global.fetch || _$$_REQUIRE(_dependencyMap[4], "fetch").fetch;
            }

            devServer = getDevServer();

            if (devServer.bundleLoadedFromServer) {
              _context.next = 4;
              break;
            }

            throw new Error('Bundle was not loaded from the packager');

          case 4:
            stackCopy = stack;

            if (SourceCode.scriptURL) {
              foundInternalSource = false;
              stackCopy = stack.map(function (frame) {
                if (!foundInternalSource && isSourcedFromDisk(frame.file)) {
                  return _extends({}, frame, {
                    file: SourceCode.scriptURL
                  });
                }

                foundInternalSource = true;
                return frame;
              });
            }

            _context.next = 8;
            return _regeneratorRuntime.awrap(fetch(devServer.url + 'symbolicate', {
              method: 'POST',
              body: JSON.stringify({
                stack: stackCopy
              })
            }));

          case 8:
            response = _context.sent;
            _context.next = 11;
            return _regeneratorRuntime.awrap(response.json());

          case 11:
            json = _context.sent;
            return _context.abrupt("return", json.stack);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, null, null, null, Promise);
  }

  module.exports = symbolicateStackTrace;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_symbolicateStackTrace.js",["node_modules_@babel_runtime_regenerator_index.js","node_modules_@babel_runtime_helpers_extends.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_getDevServer.js","node_modules_react-native_Libraries_BatchedBridge_NativeModules.js","node_modules_react-native_Libraries_Network_fetch.js"],"node_modules/react-native/Libraries/Core/Devtools/symbolicateStackTrace.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _require = _$$_REQUIRE(_dependencyMap[0], "NativeModules"),
      SourceCode = _require.SourceCode;

  var _cachedDevServerURL;

  var FALLBACK = 'http://localhost:8081/';

  function getDevServer() {
    if (_cachedDevServerURL === undefined) {
      var match = SourceCode && SourceCode.scriptURL && SourceCode.scriptURL.match(/^https?:\/\/.*?\//);
      _cachedDevServerURL = match ? match[0] : null;
    }

    return {
      url: _cachedDevServerURL || FALLBACK,
      bundleLoadedFromServer: _cachedDevServerURL !== null
    };
  }

  module.exports = getDevServer;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_getDevServer.js",["node_modules_react-native_Libraries_BatchedBridge_NativeModules.js"],"node_modules/react-native/Libraries/Core/Devtools/getDevServer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Promise = _$$_REQUIRE(_dependencyMap[0], "./core");

  var DEFAULT_WHITELIST = [ReferenceError, TypeError, RangeError];
  var enabled = false;
  exports.disable = disable;

  function disable() {
    enabled = false;
    Promise._37 = null;
    Promise._87 = null;
  }

  exports.enable = enable;

  function enable(options) {
    options = options || {};
    if (enabled) disable();
    enabled = true;
    var id = 0;
    var displayId = 0;
    var rejections = {};

    Promise._37 = function (promise) {
      if (promise._65 === 2 && rejections[promise._51]) {
        if (rejections[promise._51].logged) {
          onHandled(promise._51);
        } else {
          clearTimeout(rejections[promise._51].timeout);
        }

        delete rejections[promise._51];
      }
    };

    Promise._87 = function (promise, err) {
      if (promise._40 === 0) {
        promise._51 = id++;
        rejections[promise._51] = {
          displayId: null,
          error: err,
          timeout: setTimeout(onUnhandled.bind(null, promise._51), matchWhitelist(err, DEFAULT_WHITELIST) ? 100 : 2000),
          logged: false
        };
      }
    };

    function onUnhandled(id) {
      if (options.allRejections || matchWhitelist(rejections[id].error, options.whitelist || DEFAULT_WHITELIST)) {
        rejections[id].displayId = displayId++;

        if (options.onUnhandled) {
          rejections[id].logged = true;
          options.onUnhandled(rejections[id].displayId, rejections[id].error);
        } else {
          rejections[id].logged = true;
          logError(rejections[id].displayId, rejections[id].error);
        }
      }
    }

    function onHandled(id) {
      if (rejections[id].logged) {
        if (options.onHandled) {
          options.onHandled(rejections[id].displayId, rejections[id].error);
        } else if (!rejections[id].onUnhandled) {
          console.warn('Promise Rejection Handled (id: ' + rejections[id].displayId + '):');
          console.warn('  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id ' + rejections[id].displayId + '.');
        }
      }
    }
  }

  function logError(id, error) {
    console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');
    var errStr = (error && (error.stack || error)) + '';
    errStr.split('\n').forEach(function (line) {
      console.warn('  ' + line);
    });
  }

  function matchWhitelist(error, list) {
    return list.some(function (cls) {
      return error instanceof cls;
    });
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_promise_setimmediate_rejection-tracking.js",["node_modules_promise_setimmediate_core.js"],"node_modules/promise/setimmediate/rejection-tracking.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory() : typeof define === 'function' && define.amd ? define(factory) : factory();
  })(this, function () {
    'use strict';

    function createCommonjsModule(fn, module) {
      return module = {
        exports: {}
      }, fn(module, module.exports), module.exports;
    }

    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    var conversions = createCommonjsModule(function (module) {
      var reverseKeywords = {};

      for (var key in colorName) {
        if (colorName.hasOwnProperty(key)) {
          reverseKeywords[colorName[key]] = key;
        }
      }

      var convert = module.exports = {
        rgb: {
          channels: 3,
          labels: 'rgb'
        },
        hsl: {
          channels: 3,
          labels: 'hsl'
        },
        hsv: {
          channels: 3,
          labels: 'hsv'
        },
        hwb: {
          channels: 3,
          labels: 'hwb'
        },
        cmyk: {
          channels: 4,
          labels: 'cmyk'
        },
        xyz: {
          channels: 3,
          labels: 'xyz'
        },
        lab: {
          channels: 3,
          labels: 'lab'
        },
        lch: {
          channels: 3,
          labels: 'lch'
        },
        hex: {
          channels: 1,
          labels: ['hex']
        },
        keyword: {
          channels: 1,
          labels: ['keyword']
        },
        ansi16: {
          channels: 1,
          labels: ['ansi16']
        },
        ansi256: {
          channels: 1,
          labels: ['ansi256']
        },
        hcg: {
          channels: 3,
          labels: ['h', 'c', 'g']
        },
        apple: {
          channels: 3,
          labels: ['r16', 'g16', 'b16']
        },
        gray: {
          channels: 1,
          labels: ['gray']
        }
      };

      for (var model in convert) {
        if (convert.hasOwnProperty(model)) {
          if (!('channels' in convert[model])) {
            throw new Error('missing channels property: ' + model);
          }

          if (!('labels' in convert[model])) {
            throw new Error('missing channel labels property: ' + model);
          }

          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error('channel and label counts mismatch: ' + model);
          }

          var channels = convert[model].channels;
          var labels = convert[model].labels;
          delete convert[model].channels;
          delete convert[model].labels;
          Object.defineProperty(convert[model], 'channels', {
            value: channels
          });
          Object.defineProperty(convert[model], 'labels', {
            value: labels
          });
        }
      }

      convert.rgb.hsl = function (rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var h;
        var s;
        var l;

        if (max === min) {
          h = 0;
        } else if (r === max) {
          h = (g - b) / delta;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else if (b === max) {
          h = 4 + (r - g) / delta;
        }

        h = Math.min(h * 60, 360);

        if (h < 0) {
          h += 360;
        }

        l = (min + max) / 2;

        if (max === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }

        return [h, s * 100, l * 100];
      };

      convert.rgb.hsv = function (rgb) {
        var rdif;
        var gdif;
        var bdif;
        var h;
        var s;
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var v = Math.max(r, g, b);
        var diff = v - Math.min(r, g, b);

        var diffc = function diffc(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };

        if (diff === 0) {
          h = s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);

          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }

          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }

        return [h * 360, s * 100, v * 100];
      };

      convert.rgb.hwb = function (rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];
        var h = convert.rgb.hsl(rgb)[0];
        var w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };

      convert.rgb.cmyk = function (rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var c;
        var m;
        var y;
        var k;
        k = Math.min(1 - r, 1 - g, 1 - b);
        c = (1 - r - k) / (1 - k) || 0;
        m = (1 - g - k) / (1 - k) || 0;
        y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };

      function comparativeDistance(x, y) {
        return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
      }

      convert.rgb.keyword = function (rgb) {
        var reversed = reverseKeywords[rgb];

        if (reversed) {
          return reversed;
        }

        var currentClosestDistance = Infinity;
        var currentClosestKeyword;

        for (var keyword in colorName) {
          if (colorName.hasOwnProperty(keyword)) {
            var value = colorName[keyword];
            var distance = comparativeDistance(rgb, value);

            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword;
            }
          }
        }

        return currentClosestKeyword;
      };

      convert.keyword.rgb = function (keyword) {
        return colorName[keyword];
      };

      convert.rgb.xyz = function (rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };

      convert.rgb.lab = function (rgb) {
        var xyz = convert.rgb.xyz(rgb);
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };

      convert.hsl.rgb = function (hsl) {
        var h = hsl[0] / 360;
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var t1;
        var t2;
        var t3;
        var rgb;
        var val;

        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }

        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }

        t1 = 2 * l - t2;
        rgb = [0, 0, 0];

        for (var i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);

          if (t3 < 0) {
            t3++;
          }

          if (t3 > 1) {
            t3--;
          }

          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }

          rgb[i] = val * 255;
        }

        return rgb;
      };

      convert.hsl.hsv = function (hsl) {
        var h = hsl[0];
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var smin = s;
        var lmin = Math.max(l, 0.01);
        var sv;
        var v;
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        v = (l + s) / 2;
        sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };

      convert.hsv.rgb = function (hsv) {
        var h = hsv[0] / 60;
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var hi = Math.floor(h) % 6;
        var f = h - Math.floor(h);
        var p = 255 * v * (1 - s);
        var q = 255 * v * (1 - s * f);
        var t = 255 * v * (1 - s * (1 - f));
        v *= 255;

        switch (hi) {
          case 0:
            return [v, t, p];

          case 1:
            return [q, v, p];

          case 2:
            return [p, v, t];

          case 3:
            return [p, q, v];

          case 4:
            return [t, p, v];

          case 5:
            return [v, p, q];
        }
      };

      convert.hsv.hsl = function (hsv) {
        var h = hsv[0];
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var vmin = Math.max(v, 0.01);
        var lmin;
        var sl;
        var l;
        l = (2 - s) * v;
        lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };

      convert.hwb.rgb = function (hwb) {
        var h = hwb[0] / 360;
        var wh = hwb[1] / 100;
        var bl = hwb[2] / 100;
        var ratio = wh + bl;
        var i;
        var v;
        var f;
        var n;

        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }

        i = Math.floor(6 * h);
        v = 1 - bl;
        f = 6 * h - i;

        if ((i & 0x01) !== 0) {
          f = 1 - f;
        }

        n = wh + f * (v - wh);
        var r;
        var g;
        var b;

        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;

          case 1:
            r = n;
            g = v;
            b = wh;
            break;

          case 2:
            r = wh;
            g = v;
            b = n;
            break;

          case 3:
            r = wh;
            g = n;
            b = v;
            break;

          case 4:
            r = n;
            g = wh;
            b = v;
            break;

          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }

        return [r * 255, g * 255, b * 255];
      };

      convert.cmyk.rgb = function (cmyk) {
        var c = cmyk[0] / 100;
        var m = cmyk[1] / 100;
        var y = cmyk[2] / 100;
        var k = cmyk[3] / 100;
        var r;
        var g;
        var b;
        r = 1 - Math.min(1, c * (1 - k) + k);
        g = 1 - Math.min(1, m * (1 - k) + k);
        b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };

      convert.xyz.rgb = function (xyz) {
        var x = xyz[0] / 100;
        var y = xyz[1] / 100;
        var z = xyz[2] / 100;
        var r;
        var g;
        var b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.2040 + z * 1.0570;
        r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
        g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
        b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };

      convert.xyz.lab = function (xyz) {
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };

      convert.lab.xyz = function (lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var x;
        var y;
        var z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        var y2 = Math.pow(y, 3);
        var x2 = Math.pow(x, 3);
        var z2 = Math.pow(z, 3);
        y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };

      convert.lab.lch = function (lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var hr;
        var h;
        var c;
        hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;

        if (h < 0) {
          h += 360;
        }

        c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };

      convert.lch.lab = function (lch) {
        var l = lch[0];
        var c = lch[1];
        var h = lch[2];
        var a;
        var b;
        var hr;
        hr = h / 360 * 2 * Math.PI;
        a = c * Math.cos(hr);
        b = c * Math.sin(hr);
        return [l, a, b];
      };

      convert.rgb.ansi16 = function (args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
        value = Math.round(value / 50);

        if (value === 0) {
          return 30;
        }

        var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

        if (value === 2) {
          ansi += 60;
        }

        return ansi;
      };

      convert.hsv.ansi16 = function (args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };

      convert.rgb.ansi256 = function (args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];

        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }

          if (r > 248) {
            return 231;
          }

          return Math.round((r - 8) / 247 * 24) + 232;
        }

        var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };

      convert.ansi16.rgb = function (args) {
        var color = args % 10;

        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }

          color = color / 10.5 * 255;
          return [color, color, color];
        }

        var mult = (~~(args > 50) + 1) * 0.5;
        var r = (color & 1) * mult * 255;
        var g = (color >> 1 & 1) * mult * 255;
        var b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };

      convert.ansi256.rgb = function (args) {
        if (args >= 232) {
          var c = (args - 232) * 10 + 8;
          return [c, c, c];
        }

        args -= 16;
        var rem;
        var r = Math.floor(args / 36) / 5 * 255;
        var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        var b = rem % 6 / 5 * 255;
        return [r, g, b];
      };

      convert.rgb.hex = function (args) {
        var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
        var string = integer.toString(16).toUpperCase();
        return '000000'.substring(string.length) + string;
      };

      convert.hex.rgb = function (args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

        if (!match) {
          return [0, 0, 0];
        }

        var colorString = match[0];

        if (match[0].length === 3) {
          colorString = colorString.split('').map(function (char) {
            return char + char;
          }).join('');
        }

        var integer = parseInt(colorString, 16);
        var r = integer >> 16 & 0xFF;
        var g = integer >> 8 & 0xFF;
        var b = integer & 0xFF;
        return [r, g, b];
      };

      convert.rgb.hcg = function (rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var max = Math.max(Math.max(r, g), b);
        var min = Math.min(Math.min(r, g), b);
        var chroma = max - min;
        var grayscale;
        var hue;

        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }

        if (chroma <= 0) {
          hue = 0;
        } else if (max === r) {
          hue = (g - b) / chroma % 6;
        } else if (max === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma + 4;
        }

        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };

      convert.hsl.hcg = function (hsl) {
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var c = 1;
        var f = 0;

        if (l < 0.5) {
          c = 2.0 * s * l;
        } else {
          c = 2.0 * s * (1.0 - l);
        }

        if (c < 1.0) {
          f = (l - 0.5 * c) / (1.0 - c);
        }

        return [hsl[0], c * 100, f * 100];
      };

      convert.hsv.hcg = function (hsv) {
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var c = s * v;
        var f = 0;

        if (c < 1.0) {
          f = (v - c) / (1 - c);
        }

        return [hsv[0], c * 100, f * 100];
      };

      convert.hcg.rgb = function (hcg) {
        var h = hcg[0] / 360;
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;

        if (c === 0.0) {
          return [g * 255, g * 255, g * 255];
        }

        var pure = [0, 0, 0];
        var hi = h % 1 * 6;
        var v = hi % 1;
        var w = 1 - v;
        var mg = 0;

        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;

          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;

          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;

          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;

          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;

          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }

        mg = (1.0 - c) * g;
        return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
      };

      convert.hcg.hsv = function (hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1.0 - c);
        var f = 0;

        if (v > 0.0) {
          f = c / v;
        }

        return [hcg[0], f * 100, v * 100];
      };

      convert.hcg.hsl = function (hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var l = g * (1.0 - c) + 0.5 * c;
        var s = 0;

        if (l > 0.0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1.0) {
          s = c / (2 * (1 - l));
        }

        return [hcg[0], s * 100, l * 100];
      };

      convert.hcg.hwb = function (hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1.0 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };

      convert.hwb.hcg = function (hwb) {
        var w = hwb[1] / 100;
        var b = hwb[2] / 100;
        var v = 1 - b;
        var c = v - w;
        var g = 0;

        if (c < 1) {
          g = (v - c) / (1 - c);
        }

        return [hwb[0], c * 100, g * 100];
      };

      convert.apple.rgb = function (apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };

      convert.rgb.apple = function (rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };

      convert.gray.rgb = function (args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };

      convert.gray.hsl = convert.gray.hsv = function (args) {
        return [0, 0, args[0]];
      };

      convert.gray.hwb = function (gray) {
        return [0, 100, gray[0]];
      };

      convert.gray.cmyk = function (gray) {
        return [0, 0, 0, gray[0]];
      };

      convert.gray.lab = function (gray) {
        return [gray[0], 0, 0];
      };

      convert.gray.hex = function (gray) {
        var val = Math.round(gray[0] / 100 * 255) & 0xFF;
        var integer = (val << 16) + (val << 8) + val;
        var string = integer.toString(16).toUpperCase();
        return '000000'.substring(string.length) + string;
      };

      convert.rgb.gray = function (rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    });
    var conversions_1 = conversions.rgb;
    var conversions_2 = conversions.hsl;
    var conversions_3 = conversions.hsv;
    var conversions_4 = conversions.hwb;
    var conversions_5 = conversions.cmyk;
    var conversions_6 = conversions.xyz;
    var conversions_7 = conversions.lab;
    var conversions_8 = conversions.lch;
    var conversions_9 = conversions.hex;
    var conversions_10 = conversions.keyword;
    var conversions_11 = conversions.ansi16;
    var conversions_12 = conversions.ansi256;
    var conversions_13 = conversions.hcg;
    var conversions_14 = conversions.apple;
    var conversions_15 = conversions.gray;

    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);

      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }

      return graph;
    }

    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;

      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);

        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];

          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }

      return graph;
    }

    function link(from, to) {
      return function (args) {
        return to(from(args));
      };
    }

    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;

      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }

      fn.conversion = path;
      return fn;
    }

    var route = function route(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);

      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];

        if (node.parent === null) {
          continue;
        }

        conversion[toModel] = wrapConversion(toModel, graph);
      }

      return conversion;
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var classCallCheck = function classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var inherits = function inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };

    var possibleConstructorReturn = function possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };

    var convert = {};
    var models = Object.keys(conversions);

    function wrapRaw(fn) {
      var wrappedFn = function wrappedFn(args) {
        if (args === undefined || args === null) {
          return args;
        }

        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }

        return fn(args);
      };

      if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
      }

      return wrappedFn;
    }

    function wrapRounded(fn) {
      var wrappedFn = function wrappedFn(args) {
        if (args === undefined || args === null) {
          return args;
        }

        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }

        var result = fn(args);

        if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }

        return result;
      };

      if ('conversion' in fn) {
        wrappedFn.conversion = fn.conversion;
      }

      return wrappedFn;
    }

    models.forEach(function (fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], 'channels', {
        value: conversions[fromModel].channels
      });
      Object.defineProperty(convert[fromModel], 'labels', {
        value: conversions[fromModel].labels
      });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function (toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    var colorConvert = convert;
    var ansiStyles = createCommonjsModule(function (module) {
      var wrapAnsi16 = function wrapAnsi16(fn, offset) {
        return function () {
          var code = fn.apply(colorConvert, arguments);
          return '\x1B[' + (code + offset) + 'm';
        };
      };

      var wrapAnsi256 = function wrapAnsi256(fn, offset) {
        return function () {
          var code = fn.apply(colorConvert, arguments);
          return '\x1B[' + (38 + offset) + ';5;' + code + 'm';
        };
      };

      var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
        return function () {
          var rgb = fn.apply(colorConvert, arguments);
          return '\x1B[' + (38 + offset) + ';2;' + rgb[0] + ';' + rgb[1] + ';' + rgb[2] + 'm';
        };
      };

      function assembleStyles() {
        var codes = new Map();
        var styles = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.grey = styles.color.gray;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.keys(styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var groupName = _step.value;
            var group = styles[groupName];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = Object.keys(group)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var styleName = _step3.value;
                var style = group[styleName];
                styles[styleName] = {
                  open: '\x1B[' + style[0] + 'm',
                  close: '\x1B[' + style[1] + 'm'
                };
                group[styleName] = styles[styleName];
                codes.set(style[0], style[1]);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            Object.defineProperty(styles, groupName, {
              value: group,
              enumerable: false
            });
            Object.defineProperty(styles, 'codes', {
              value: codes,
              enumerable: false
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var ansi2ansi = function ansi2ansi(n) {
          return n;
        };

        var rgb2rgb = function rgb2rgb(r, g, b) {
          return [r, g, b];
        };

        styles.color.close = '\x1B[39m';
        styles.bgColor.close = '\x1B[49m';
        styles.color.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 0)
        };
        styles.color.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 0)
        };
        styles.color.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 0)
        };
        styles.bgColor.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 10)
        };
        styles.bgColor.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 10)
        };
        styles.bgColor.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 10)
        };
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = Object.keys(colorConvert)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var key = _step2.value;

            if (_typeof(colorConvert[key]) !== 'object') {
              continue;
            }

            var suite = colorConvert[key];

            if (key === 'ansi16') {
              key = 'ansi';
            }

            if ('ansi16' in suite) {
              styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
              styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
            }

            if ('ansi256' in suite) {
              styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
              styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
            }

            if ('rgb' in suite) {
              styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
              styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return styles;
      }

      Object.defineProperty(module, 'exports', {
        enumerable: true,
        get: assembleStyles
      });
    });

    var getSymbols = Object.getOwnPropertySymbols || function (obj) {
      return [];
    };

    var isSymbol = function isSymbol(key) {
      return (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'symbol' || toString.call(key) === '[object Symbol]';
    };

    function printIteratorEntries(iterator, config, indentation, depth, refs, printer) {
      var separator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ': ';
      var result = '';
      var current = iterator.next();

      if (!current.done) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;

        while (!current.done) {
          var name = printer(current.value[0], config, indentationNext, depth, refs);
          var value = printer(current.value[1], config, indentationNext, depth, refs);
          result += indentationNext + name + separator + value;
          current = iterator.next();

          if (!current.done) {
            result += ',' + config.spacingInner;
          } else if (!config.min) {
            result += ',';
          }
        }

        result += config.spacingOuter + indentation;
      }

      return result;
    }

    function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
      var result = '';
      var current = iterator.next();

      if (!current.done) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;

        while (!current.done) {
          result += indentationNext + printer(current.value, config, indentationNext, depth, refs);
          current = iterator.next();

          if (!current.done) {
            result += ',' + config.spacingInner;
          } else if (!config.min) {
            result += ',';
          }
        }

        result += config.spacingOuter + indentation;
      }

      return result;
    }

    function printListItems(list, config, indentation, depth, refs, printer) {
      var result = '';

      if (list.length) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;

        for (var i = 0; i < list.length; i++) {
          result += indentationNext + printer(list[i], config, indentationNext, depth, refs);

          if (i < list.length - 1) {
            result += ',' + config.spacingInner;
          } else if (!config.min) {
            result += ',';
          }
        }

        result += config.spacingOuter + indentation;
      }

      return result;
    }

    function printObjectProperties(val, config, indentation, depth, refs, printer) {
      var result = '';
      var keys = Object.keys(val).sort();
      var symbols = getSymbols(val);

      if (symbols.length) {
        keys = keys.filter(function (key) {
          return !isSymbol(key);
        }).concat(symbols);
      }

      if (keys.length) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var name = printer(key, config, indentationNext, depth, refs);
          var value = printer(val[key], config, indentationNext, depth, refs);
          result += indentationNext + name + ': ' + value;

          if (i < keys.length - 1) {
            result += ',' + config.spacingInner;
          } else if (!config.min) {
            result += ',';
          }
        }

        result += config.spacingOuter + indentation;
      }

      return result;
    }

    var asymmetricMatcher = Symbol.for('jest.asymmetricMatcher');
    var SPACE = ' ';

    var serialize = function serialize(val, config, indentation, depth, refs, printer) {
      var stringedValue = val.toString();

      if (stringedValue === 'ArrayContaining' || stringedValue === 'ArrayNotContaining') {
        if (++depth > config.maxDepth) {
          return '[' + stringedValue + ']';
        }

        return stringedValue + SPACE + '[' + printListItems(val.sample, config, indentation, depth, refs, printer) + ']';
      }

      if (stringedValue === 'ObjectContaining' || stringedValue === 'ObjectNotContaining') {
        if (++depth > config.maxDepth) {
          return '[' + stringedValue + ']';
        }

        return stringedValue + SPACE + '{' + printObjectProperties(val.sample, config, indentation, depth, refs, printer) + '}';
      }

      if (stringedValue === 'StringMatching' || stringedValue === 'StringNotMatching') {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }

      if (stringedValue === 'StringContaining' || stringedValue === 'StringNotContaining') {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }

      return val.toAsymmetricMatcher();
    };

    var test = function test(val) {
      return val && val.$$typeof === asymmetricMatcher;
    };

    var AsymmetricMatcher = {
      serialize: serialize,
      test: test
    };

    var ansiRegex = function ansiRegex(options) {
      options = _extends({
        onlyFirst: false
      }, options);
      var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
      return new RegExp(pattern, options.onlyFirst ? undefined : 'g');
    };

    var toHumanReadableAnsi = function toHumanReadableAnsi(text) {
      return text.replace(ansiRegex(), function (match, offset, string) {
        switch (match) {
          case ansiStyles.red.close:
          case ansiStyles.green.close:
          case ansiStyles.cyan.close:
          case ansiStyles.gray.close:
          case ansiStyles.white.close:
          case ansiStyles.yellow.close:
          case ansiStyles.bgRed.close:
          case ansiStyles.bgGreen.close:
          case ansiStyles.bgYellow.close:
          case ansiStyles.inverse.close:
          case ansiStyles.dim.close:
          case ansiStyles.bold.close:
          case ansiStyles.reset.open:
          case ansiStyles.reset.close:
            return '</>';

          case ansiStyles.red.open:
            return '<red>';

          case ansiStyles.green.open:
            return '<green>';

          case ansiStyles.cyan.open:
            return '<cyan>';

          case ansiStyles.gray.open:
            return '<gray>';

          case ansiStyles.white.open:
            return '<white>';

          case ansiStyles.yellow.open:
            return '<yellow>';

          case ansiStyles.bgRed.open:
            return '<bgRed>';

          case ansiStyles.bgGreen.open:
            return '<bgGreen>';

          case ansiStyles.bgYellow.open:
            return '<bgYellow>';

          case ansiStyles.inverse.open:
            return '<inverse>';

          case ansiStyles.dim.open:
            return '<dim>';

          case ansiStyles.bold.open:
            return '<bold>';

          default:
            return '';
        }
      });
    };

    var test$1 = function test(val) {
      return typeof val === 'string' && val.match(ansiRegex());
    };

    var serialize$1 = function serialize(val, config, indentation, depth, refs, printer) {
      return printer(toHumanReadableAnsi(val), config, indentation, depth, refs);
    };

    var ConvertAnsi = {
      serialize: serialize$1,
      test: test$1
    };
    var SPACE$1 = ' ';
    var OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];
    var ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;

    var testName = function testName(name) {
      return OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
    };

    var test$2 = function test(val) {
      return val && val.constructor && val.constructor.name && testName(val.constructor.name);
    };

    var propsReducer = function propsReducer(props, attribute) {
      props[attribute.name] = attribute.value;
      return props;
    };

    var serialize$2 = function serialize(collection, config, indentation, depth, refs, printer) {
      var name = collection.constructor.name;

      if (++depth > config.maxDepth) {
        return '[' + name + ']';
      }

      return (config.min ? '' : name + SPACE$1) + (OBJECT_NAMES.indexOf(name) !== -1 ? '{' + printObjectProperties(name === 'NamedNodeMap' ? Array.prototype.reduce.call(collection, propsReducer, {}) : _extends({}, collection), config, indentation, depth, refs, printer) + '}' : '[' + printListItems(Array.from(collection), config, indentation, depth, refs, printer) + ']');
    };

    var DOMCollection = {
      serialize: serialize$2,
      test: test$2
    };

    function escapeHTML(str) {
      return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    var printProps = function printProps(keys, props, config, indentation, depth, refs, printer) {
      var indentationNext = indentation + config.indent;
      var colors = config.colors;
      return keys.map(function (key) {
        var value = props[key];
        var printed = printer(value, config, indentationNext, depth, refs);

        if (typeof value !== 'string') {
          if (printed.indexOf('\n') !== -1) {
            printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
          }

          printed = '{' + printed + '}';
        }

        return config.spacingInner + indentation + colors.prop.open + key + colors.prop.close + '=' + colors.value.open + printed + colors.value.close;
      }).join('');
    };

    var printChildren = function printChildren(children, config, indentation, depth, refs, printer) {
      return children.map(function (child) {
        return config.spacingOuter + indentation + (typeof child === 'string' ? printText(child, config) : printer(child, config, indentation, depth, refs));
      }).join('');
    };

    var printText = function printText(text, config) {
      var contentColor = config.colors.content;
      return contentColor.open + escapeHTML(text) + contentColor.close;
    };

    var printComment = function printComment(comment, config) {
      var commentColor = config.colors.comment;
      return commentColor.open + '<!--' + escapeHTML(comment) + '-->' + commentColor.close;
    };

    var printElement = function printElement(type, printedProps, printedChildren, config, indentation) {
      var tagColor = config.colors.tag;
      return tagColor.open + '<' + type + (printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open) + (printedChildren ? '>' + tagColor.close + printedChildren + config.spacingOuter + indentation + tagColor.open + '</' + type : (printedProps && !config.min ? '' : ' ') + '/') + '>' + tagColor.close;
    };

    var printElementAsLeaf = function printElementAsLeaf(type, config) {
      var tagColor = config.colors.tag;
      return tagColor.open + '<' + type + tagColor.close + ' …' + tagColor.open + ' />' + tagColor.close;
    };

    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var FRAGMENT_NODE = 11;
    var ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;

    var testNode = function testNode(nodeType, name) {
      return nodeType === ELEMENT_NODE && ELEMENT_REGEXP.test(name) || nodeType === TEXT_NODE && name === 'Text' || nodeType === COMMENT_NODE && name === 'Comment' || nodeType === FRAGMENT_NODE && name === 'DocumentFragment';
    };

    var test$3 = function test(val) {
      return val && val.constructor && val.constructor.name && testNode(val.nodeType, val.constructor.name);
    };

    var keysMapper = function keysMapper(attribute) {
      return attribute.name;
    };

    var propsReducer$1 = function propsReducer(props, attribute) {
      props[attribute.name] = attribute.value;
      return props;
    };

    var serialize$3 = function serialize(node, config, indentation, depth, refs, printer) {
      if (node.nodeType === TEXT_NODE) {
        return printText(node.data, config);
      }

      if (node.nodeType === COMMENT_NODE) {
        return printComment(node.data, config);
      }

      var type = node.nodeType === FRAGMENT_NODE ? 'DocumentFragment' : node.tagName.toLowerCase();

      if (++depth > config.maxDepth) {
        return printElementAsLeaf(type, config);
      }

      return printElement(type, printProps(Array.prototype.map.call(node.attributes || [], keysMapper).sort(), Array.prototype.reduce.call(node.attributes || [], propsReducer$1, {}), config, indentation + config.indent, depth, refs, printer), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
    };

    var DOMElement = {
      serialize: serialize$3,
      test: test$3
    };
    var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
    var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
    var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
    var IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';
    var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
    var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
    var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

    var getImmutableName = function getImmutableName(name) {
      return 'Immutable.' + name;
    };

    var printAsLeaf = function printAsLeaf(name) {
      return '[' + name + ']';
    };

    var SPACE$2 = ' ';
    var LAZY = '…';

    var printImmutableEntries = function printImmutableEntries(val, config, indentation, depth, refs, printer, type) {
      return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : getImmutableName(type) + SPACE$2 + '{' + printIteratorEntries(val.entries(), config, indentation, depth, refs, printer) + '}';
    };

    var getRecordEntries = function getRecordEntries(val) {
      var i = 0;
      return {
        next: function next() {
          if (i < val._keys.length) {
            var key = val._keys[i++];
            return {
              done: false,
              value: [key, val.get(key)]
            };
          }

          return {
            done: true
          };
        }
      };
    };

    var printImmutableRecord = function printImmutableRecord(val, config, indentation, depth, refs, printer) {
      var name = getImmutableName(val._name || 'Record');
      return ++depth > config.maxDepth ? printAsLeaf(name) : name + SPACE$2 + '{' + printIteratorEntries(getRecordEntries(val), config, indentation, depth, refs, printer) + '}';
    };

    var printImmutableSeq = function printImmutableSeq(val, config, indentation, depth, refs, printer) {
      var name = getImmutableName('Seq');

      if (++depth > config.maxDepth) {
        return printAsLeaf(name);
      }

      if (val[IS_KEYED_SENTINEL]) {
        return name + SPACE$2 + '{' + (val._iter || val._object ? printIteratorEntries(val.entries(), config, indentation, depth, refs, printer) : LAZY) + '}';
      }

      return name + SPACE$2 + '[' + (val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config, indentation, depth, refs, printer) : LAZY) + ']';
    };

    var printImmutableValues = function printImmutableValues(val, config, indentation, depth, refs, printer, type) {
      return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : getImmutableName(type) + SPACE$2 + '[' + printIteratorValues(val.values(), config, indentation, depth, refs, printer) + ']';
    };

    var serialize$4 = function serialize(val, config, indentation, depth, refs, printer) {
      if (val[IS_MAP_SENTINEL]) {
        return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map');
      }

      if (val[IS_LIST_SENTINEL]) {
        return printImmutableValues(val, config, indentation, depth, refs, printer, 'List');
      }

      if (val[IS_SET_SENTINEL]) {
        return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set');
      }

      if (val[IS_STACK_SENTINEL]) {
        return printImmutableValues(val, config, indentation, depth, refs, printer, 'Stack');
      }

      if (val[IS_SEQ_SENTINEL]) {
        return printImmutableSeq(val, config, indentation, depth, refs, printer);
      }

      return printImmutableRecord(val, config, indentation, depth, refs, printer);
    };

    var test$4 = function test(val) {
      return val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
    };

    var Immutable = {
      serialize: serialize$4,
      test: test$4
    };
    var elementSymbol = Symbol.for('react.element');
    var fragmentSymbol = Symbol.for('react.fragment');
    var forwardRefSymbol = Symbol.for('react.forward_ref');
    var providerSymbol = Symbol.for('react.provider');
    var contextSymbol = Symbol.for('react.context');

    var getChildren = function getChildren(arg) {
      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (Array.isArray(arg)) {
        arg.forEach(function (item) {
          getChildren(item, children);
        });
      } else if (arg != null && arg !== false) {
        children.push(arg);
      }

      return children;
    };

    var getType = function getType(element) {
      var type = element.type;

      if (typeof type === 'string') {
        return type;
      }

      if (typeof type === 'function') {
        return type.displayName || type.name || 'Unknown';
      }

      if (type === fragmentSymbol) {
        return 'React.Fragment';
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null) {
        if (type.$$typeof === providerSymbol) {
          return 'Context.Provider';
        }

        if (type.$$typeof === contextSymbol) {
          return 'Context.Consumer';
        }

        if (type.$$typeof === forwardRefSymbol) {
          var functionName = type.render.displayName || type.render.name || '';
          return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
        }
      }

      return 'UNDEFINED';
    };

    var getPropKeys = function getPropKeys(element) {
      var props = element.props;
      return Object.keys(props).filter(function (key) {
        return key !== 'children' && props[key] !== undefined;
      }).sort();
    };

    var serialize$5 = function serialize(element, config, indentation, depth, refs, printer) {
      return ++depth > config.maxDepth ? printElementAsLeaf(getType(element), config) : printElement(getType(element), printProps(getPropKeys(element), element.props, config, indentation + config.indent, depth, refs, printer), printChildren(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
    };

    var test$5 = function test(val) {
      return val && val.$$typeof === elementSymbol;
    };

    var ReactElement = {
      serialize: serialize$5,
      test: test$5
    };
    var testSymbol = Symbol.for('react.test.json');

    var getPropKeys$1 = function getPropKeys(object) {
      var props = object.props;
      return props ? Object.keys(props).filter(function (key) {
        return props[key] !== undefined;
      }).sort() : [];
    };

    var serialize$6 = function serialize(object, config, indentation, depth, refs, printer) {
      return ++depth > config.maxDepth ? printElementAsLeaf(object.type, config) : printElement(object.type, object.props ? printProps(getPropKeys$1(object), object.props, config, indentation + config.indent, depth, refs, printer) : '', object.children ? printChildren(object.children, config, indentation + config.indent, depth, refs, printer) : '', config, indentation);
    };

    var test$6 = function test(val) {
      return val && val.$$typeof === testSymbol;
    };

    var ReactTestComponent = {
      serialize: serialize$6,
      test: test$6
    };
    var toString$1 = Object.prototype.toString;
    var toISOString = Date.prototype.toISOString;
    var errorToString = Error.prototype.toString;
    var regExpToString = RegExp.prototype.toString;
    var symbolToString = Symbol.prototype.toString;

    var getConstructorName = function getConstructorName(val) {
      return typeof val.constructor === 'function' && val.constructor.name || 'Object';
    };

    var isWindow = function isWindow(val) {
      return typeof window !== 'undefined' && val === window;
    };

    var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    var NEWLINE_REGEXP = /\n/gi;

    var PrettyFormatPluginError = function (_Error) {
      inherits(PrettyFormatPluginError, _Error);

      function PrettyFormatPluginError(message, stack) {
        classCallCheck(this, PrettyFormatPluginError);

        var _this = possibleConstructorReturn(this, (PrettyFormatPluginError.__proto__ || Object.getPrototypeOf(PrettyFormatPluginError)).call(this, message));

        _this.stack = stack;
        _this.name = _this.constructor.name;
        return _this;
      }

      return PrettyFormatPluginError;
    }(Error);

    function isToStringedArrayType(toStringed) {
      return toStringed === '[object Array]' || toStringed === '[object ArrayBuffer]' || toStringed === '[object DataView]' || toStringed === '[object Float32Array]' || toStringed === '[object Float64Array]' || toStringed === '[object Int8Array]' || toStringed === '[object Int16Array]' || toStringed === '[object Int32Array]' || toStringed === '[object Uint8Array]' || toStringed === '[object Uint8ClampedArray]' || toStringed === '[object Uint16Array]' || toStringed === '[object Uint32Array]';
    }

    function printNumber(val) {
      return Object.is(val, -0) ? '-0' : String(val);
    }

    function printFunction(val, printFunctionName) {
      if (!printFunctionName) {
        return '[Function]';
      }

      return '[Function ' + (val.name || 'anonymous') + ']';
    }

    function printSymbol(val) {
      return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
    }

    function printError(val) {
      return '[' + errorToString.call(val) + ']';
    }

    function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
      if (val === true || val === false) {
        return '' + val;
      }

      if (val === undefined) {
        return 'undefined';
      }

      if (val === null) {
        return 'null';
      }

      var typeOf = typeof val === 'undefined' ? 'undefined' : _typeof(val);

      if (typeOf === 'number') {
        return printNumber(val);
      }

      if (typeOf === 'string') {
        if (escapeString) {
          return '"' + val.replace(/"|\\/g, '\\$&') + '"';
        }

        return '"' + val + '"';
      }

      if (typeOf === 'function') {
        return printFunction(val, printFunctionName);
      }

      if (typeOf === 'symbol') {
        return printSymbol(val);
      }

      var toStringed = toString$1.call(val);

      if (toStringed === '[object WeakMap]') {
        return 'WeakMap {}';
      }

      if (toStringed === '[object WeakSet]') {
        return 'WeakSet {}';
      }

      if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') {
        return printFunction(val, printFunctionName);
      }

      if (toStringed === '[object Symbol]') {
        return printSymbol(val);
      }

      if (toStringed === '[object Date]') {
        return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);
      }

      if (toStringed === '[object Error]') {
        return printError(val);
      }

      if (toStringed === '[object RegExp]') {
        if (escapeRegex) {
          return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        return regExpToString.call(val);
      }

      if (val instanceof Error) {
        return printError(val);
      }

      return null;
    }

    function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
      if (refs.indexOf(val) !== -1) {
        return '[Circular]';
      }

      refs = refs.slice();
      refs.push(val);
      var hitMaxDepth = ++depth > config.maxDepth;
      var min = config.min;

      if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function' && !hasCalledToJSON) {
        return printer(val.toJSON(), config, indentation, depth, refs, true);
      }

      var toStringed = toString$1.call(val);

      if (toStringed === '[object Arguments]') {
        return hitMaxDepth ? '[Arguments]' : (min ? '' : 'Arguments ') + '[' + printListItems(val, config, indentation, depth, refs, printer) + ']';
      }

      if (isToStringedArrayType(toStringed)) {
        return hitMaxDepth ? '[' + val.constructor.name + ']' : (min ? '' : val.constructor.name + ' ') + '[' + printListItems(val, config, indentation, depth, refs, printer) + ']';
      }

      if (toStringed === '[object Map]') {
        return hitMaxDepth ? '[Map]' : 'Map {' + printIteratorEntries(val.entries(), config, indentation, depth, refs, printer, ' => ') + '}';
      }

      if (toStringed === '[object Set]') {
        return hitMaxDepth ? '[Set]' : 'Set {' + printIteratorValues(val.values(), config, indentation, depth, refs, printer) + '}';
      }

      return hitMaxDepth || isWindow(val) ? '[' + getConstructorName(val) + ']' : (min ? '' : getConstructorName(val) + ' ') + '{' + printObjectProperties(val, config, indentation, depth, refs, printer) + '}';
    }

    function printPlugin(plugin, val, config, indentation, depth, refs) {
      var printed = void 0;

      try {
        printed = plugin.serialize ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(val, function (valChild) {
          return printer(valChild, config, indentation, depth, refs);
        }, function (str) {
          var indentationNext = indentation + config.indent;
          return indentationNext + str.replace(NEWLINE_REGEXP, '\n' + indentationNext);
        }, {
          edgeSpacing: config.spacingOuter,
          min: config.min,
          spacing: config.spacingInner
        }, config.colors);
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }

      if (typeof printed !== 'string') {
        throw new Error('pretty-format: Plugin must return type "string" but instead returned "' + (typeof printed === 'undefined' ? 'undefined' : _typeof(printed)) + '".');
      }

      return printed;
    }

    function findPlugin(plugins, val) {
      for (var p = 0; p < plugins.length; p++) {
        try {
          if (plugins[p].test(val)) {
            return plugins[p];
          }
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }
      }

      return null;
    }

    function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
      var plugin = findPlugin(config.plugins, val);

      if (plugin !== null) {
        return printPlugin(plugin, val, config, indentation, depth, refs);
      }

      var basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);

      if (basicResult !== null) {
        return basicResult;
      }

      return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
    }

    var DEFAULT_THEME = {
      comment: 'gray',
      content: 'reset',
      prop: 'yellow',
      tag: 'cyan',
      value: 'green'
    };
    var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
    var DEFAULT_OPTIONS = {
      callToJSON: true,
      escapeRegex: false,
      escapeString: true,
      highlight: false,
      indent: 2,
      maxDepth: Infinity,
      min: false,
      plugins: [],
      printFunctionName: true,
      theme: DEFAULT_THEME
    };

    function validateOptions(options) {
      Object.keys(options).forEach(function (key) {
        if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
          throw new Error('pretty-format: Unknown option "' + key + '".');
        }
      });

      if (options.min && options.indent !== undefined && options.indent !== 0) {
        throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
      }

      if (options.theme !== undefined) {
        if (options.theme === null) {
          throw new Error('pretty-format: Option "theme" must not be null.');
        }

        if (_typeof(options.theme) !== 'object') {
          throw new Error('pretty-format: Option "theme" must be of type "object" but instead received "' + _typeof(options.theme) + '".');
        }
      }
    }

    var getColorsHighlight = function getColorsHighlight(options) {
      return DEFAULT_THEME_KEYS.reduce(function (colors, key) {
        var value = options.theme && options.theme[key] !== undefined ? options.theme[key] : DEFAULT_THEME[key];
        var color = ansiStyles[value];

        if (color && typeof color.close === 'string' && typeof color.open === 'string') {
          colors[key] = color;
        } else {
          throw new Error('pretty-format: Option "theme" has a key "' + key + '" whose value "' + value + '" is undefined in ansi-styles.');
        }

        return colors;
      }, Object.create(null));
    };

    var getColorsEmpty = function getColorsEmpty() {
      return DEFAULT_THEME_KEYS.reduce(function (colors, key) {
        colors[key] = {
          close: '',
          open: ''
        };
        return colors;
      }, Object.create(null));
    };

    var getPrintFunctionName = function getPrintFunctionName(options) {
      return options && options.printFunctionName !== undefined ? options.printFunctionName : DEFAULT_OPTIONS.printFunctionName;
    };

    var getEscapeRegex = function getEscapeRegex(options) {
      return options && options.escapeRegex !== undefined ? options.escapeRegex : DEFAULT_OPTIONS.escapeRegex;
    };

    var getEscapeString = function getEscapeString(options) {
      return options && options.escapeString !== undefined ? options.escapeString : DEFAULT_OPTIONS.escapeString;
    };

    var getConfig = function getConfig(options) {
      return {
        callToJSON: options && options.callToJSON !== undefined ? options.callToJSON : DEFAULT_OPTIONS.callToJSON,
        colors: options && options.highlight ? getColorsHighlight(options) : getColorsEmpty(),
        escapeRegex: getEscapeRegex(options),
        escapeString: getEscapeString(options),
        indent: options && options.min ? '' : createIndent(options && options.indent !== undefined ? options.indent : DEFAULT_OPTIONS.indent),
        maxDepth: options && options.maxDepth !== undefined ? options.maxDepth : DEFAULT_OPTIONS.maxDepth,
        min: options && options.min !== undefined ? options.min : DEFAULT_OPTIONS.min,
        plugins: options && options.plugins !== undefined ? options.plugins : DEFAULT_OPTIONS.plugins,
        printFunctionName: getPrintFunctionName(options),
        spacingInner: options && options.min ? ' ' : '\n',
        spacingOuter: options && options.min ? '' : '\n'
      };
    };

    function createIndent(indent) {
      return new Array(indent + 1).join(' ');
    }

    function prettyFormat(val, options) {
      if (options) {
        validateOptions(options);

        if (options.plugins) {
          var plugin = findPlugin(options.plugins, val);

          if (plugin !== null) {
            return printPlugin(plugin, val, getConfig(options), '', 0, []);
          }
        }
      }

      var basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));

      if (basicResult !== null) {
        return basicResult;
      }

      return printComplexValue(val, getConfig(options), '', 0, []);
    }

    prettyFormat.plugins = {
      AsymmetricMatcher: AsymmetricMatcher,
      ConvertAnsi: ConvertAnsi,
      DOMCollection: DOMCollection,
      DOMElement: DOMElement,
      Immutable: Immutable,
      ReactElement: ReactElement,
      ReactTestComponent: ReactTestComponent
    };
    module.exports = prettyFormat;
  });
},"system_2d01160272669884793b18983a46dcd0_node_modules_pretty-format_build-es5_index.js",["node_modules_@babel_runtime_helpers_extends.js"],"node_modules/pretty-format/build-es5/index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var invariant = _$$_REQUIRE(_dependencyMap[1], "invariant");

  var MetroHMRClient = _$$_REQUIRE(_dependencyMap[2], "metro/src/lib/bundle-modules/HMRClient");

  var HMRClient = {
    enable: function enable(platform, bundleEntry, host, port) {
      invariant(platform, 'Missing required parameter `platform`');
      invariant(bundleEntry, 'Missing required paramenter `bundleEntry`');
      invariant(host, 'Missing required paramenter `host`');

      var HMRLoadingView = _$$_REQUIRE(_dependencyMap[3], "HMRLoadingView");

      var wsHostPort = port !== null && port !== '' ? host + ":" + port : host;
      bundleEntry = bundleEntry.replace(/\.(bundle|delta)/, '.js');
      var wsUrl = "ws://" + wsHostPort + "/hot?" + ("platform=" + platform + "&") + ("bundleEntry=" + bundleEntry);
      var hmrClient = new MetroHMRClient(wsUrl);
      hmrClient.on('connection-error', function (e) {
        var error = "Hot loading isn't working because it cannot connect to the development server.\n\nTry the following to fix the issue:\n- Ensure that the packager server is running and available on the same network";

        if (Platform.OS === 'ios') {
          error += "\n- Ensure that the Packager server URL is correctly set in AppDelegate";
        } else {
          error += "\n- Ensure that your device/emulator is connected to your machine and has USB debugging enabled - run 'adb devices' to see a list of connected devices\n- If you're on a physical device connected to the same machine, run 'adb reverse tcp:8081 tcp:8081' to forward requests from your device\n- If your device is on the same Wi-Fi network, set 'Debug server host & port for device' in 'Dev settings' to your machine's IP address and the port of the local dev server - e.g. 10.0.1.1:8081";
        }

        error += "\n\nURL: " + host + ":" + port + "\n\nError: " + e.message;
        throw new Error(error);
      });
      hmrClient.on('update-start', function () {
        HMRLoadingView.showMessage('Hot Loading...');
      });
      hmrClient.on('update', function () {
        if (Platform.OS === 'ios') {
          var RCTRedBox = _$$_REQUIRE(_dependencyMap[4], "NativeModules").RedBox;

          RCTRedBox && RCTRedBox.dismiss && RCTRedBox.dismiss();
        } else {
          var RCTExceptionsManager = _$$_REQUIRE(_dependencyMap[4], "NativeModules").ExceptionsManager;

          RCTExceptionsManager && RCTExceptionsManager.dismissRedbox && RCTExceptionsManager.dismissRedbox();
        }
      });
      hmrClient.on('update-done', function () {
        HMRLoadingView.hide();
      });
      hmrClient.on('error', function (data) {
        HMRLoadingView.hide();

        if (data.type === 'GraphNotFoundError') {
          hmrClient.disable();
          throw new Error('The packager server has restarted since the last Hot update. Hot Reloading will be disabled until you reload the application.');
        } else if (data.type === 'RevisionNotFoundError') {
          hmrClient.disable();
          throw new Error('The packager server and the client are out of sync. Hot Reloading will be disabled until you reload the application.');
        } else {
          throw new Error(data.type + " " + data.message);
        }
      });
      hmrClient.on('close', function (data) {
        HMRLoadingView.hide();
        throw new Error('Disconnected from the packager server. Hot Reloading will be disabled until you reload the application.');
      });
      hmrClient.enable();
    }
  };
  module.exports = HMRClient;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Utilities_HMRClient.js",["node_modules_react-native_Libraries_Utilities_Platform.android.js","node_modules_invariant_browser.js","system_2d01160272669884793b18983a46dcd0_node_modules_metro_src_lib_bundle-modules_HMRClient.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Utilities_HMRLoadingView.android.js","node_modules_react-native_Libraries_BatchedBridge_NativeModules.js"],"node_modules/react-native/Libraries/Utilities/HMRClient.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _createClass = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/createClass");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var WebSocketHMRClient = _$$_REQUIRE(_dependencyMap[5], "./WebSocketHMRClient");

  var injectUpdate = _$$_REQUIRE(_dependencyMap[6], "./injectUpdate");

  var HMRClient = function (_WebSocketHMRClient) {
    _inherits(HMRClient, _WebSocketHMRClient);

    var _super = _createSuper(HMRClient);

    function HMRClient(url) {
      var _this;

      _classCallCheck(this, HMRClient);

      _this = _super.call(this, url);

      _this.on("update", function (update) {
        injectUpdate(update);
      });

      return _this;
    }

    return _createClass(HMRClient);
  }(WebSocketHMRClient);

  module.exports = HMRClient;
},"system_2d01160272669884793b18983a46dcd0_node_modules_metro_src_lib_bundle-modules_HMRClient.js",["node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_metro_src_lib_bundle-modules_WebSocketHMRClient.js","system_2d01160272669884793b18983a46dcd0_node_modules_metro_src_lib_bundle-modules_injectUpdate.js"],"node_modules/metro/src/lib/bundle-modules/HMRClient.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var EventEmitter = _$$_REQUIRE(_dependencyMap[5], "eventemitter3");

  var WebSocketHMRClient = function (_EventEmitter) {
    _inherits(WebSocketHMRClient, _EventEmitter);

    var _super = _createSuper(WebSocketHMRClient);

    function WebSocketHMRClient(url) {
      var _this;

      _classCallCheck(this, WebSocketHMRClient);

      _this = _super.call(this);
      _this._url = url;
      return _this;
    }

    _createClass(WebSocketHMRClient, [{
      key: "enable",
      value: function enable() {
        var _this2 = this;

        if (this._ws) {
          this.disable();
        }

        this._ws = new global.WebSocket(this._url);

        this._ws.onopen = function () {
          _this2.emit("open");
        };

        this._ws.onerror = function (error) {
          _this2.emit("connection-error", error);
        };

        this._ws.onclose = function () {
          _this2.emit("close");
        };

        this._ws.onmessage = function (message) {
          var data = JSON.parse(message.data);

          switch (data.type) {
            case "update-start":
              _this2.emit("update-start");

              break;

            case "update":
              _this2.emit("update", data.body);

              break;

            case "update-done":
              _this2.emit("update-done");

              break;

            case "error":
              _this2.emit("error", data.body);

              break;

            default:
              _this2.emit("error", {
                type: "unknown-message",
                message: data
              });

          }
        };
      }
    }, {
      key: "disable",
      value: function disable() {
        if (this._ws) {
          this._ws.close();

          this._ws = undefined;
        }
      }
    }]);

    return WebSocketHMRClient;
  }(EventEmitter);

  module.exports = WebSocketHMRClient;
},"system_2d01160272669884793b18983a46dcd0_node_modules_metro_src_lib_bundle-modules_WebSocketHMRClient.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_metro_node_modules_eventemitter3_index.js"],"node_modules/metro/src/lib/bundle-modules/WebSocketHMRClient.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var has = Object.prototype.hasOwnProperty,
      prefix = '~';

  function Events() {}

  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }

  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }

  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }

  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
        events,
        name;
    if (this._eventsCount === 0) return names;

    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;

        case 2:
          return listeners.fn.call(listeners.context, a1), true;

        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;

        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;

        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
          j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;

          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;

          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;

          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;

          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;

    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }

      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;

  if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_metro_node_modules_eventemitter3_index.js",[],"node_modules/metro/node_modules/eventemitter3/index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function injectModules(modules, sourceMappingURLs, sourceURLs) {
    modules.forEach(function (_ref, i) {
      var _ref2 = _slicedToArray(_ref, 2),
          id = _ref2[0],
          code = _ref2[1];

      var injectFunction = typeof global.nativeInjectHMRUpdate === "function" ? global.nativeInjectHMRUpdate : eval;
      var pragma = "sourceMappingURL";
      injectFunction(code + ("\n//# " + pragma + "=" + sourceMappingURLs[i]), sourceURLs[i]);
    });
  }

  function injectUpdate(update) {
    injectModules(update.added, update.addedSourceMappingURLs, update.addedSourceURLs);
    injectModules(update.modified, update.modifiedSourceMappingURLs, update.modifiedSourceURLs);
  }

  module.exports = injectUpdate;
},"system_2d01160272669884793b18983a46dcd0_node_modules_metro_src_lib_bundle-modules_injectUpdate.js",[],"node_modules/metro/src/lib/bundle-modules/injectUpdate.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var ToastAndroid = _$$_REQUIRE(_dependencyMap[2], "ToastAndroid");

  var TOAST_SHORT_DELAY = 2000;

  var HMRLoadingView = function () {
    function HMRLoadingView() {
      _classCallCheck(this, HMRLoadingView);
    }

    _createClass(HMRLoadingView, null, [{
      key: "showMessage",
      value: function showMessage(message) {
        if (HMRLoadingView._showing) {
          return;
        }

        ToastAndroid.show(message, ToastAndroid.SHORT);
        HMRLoadingView._showing = true;
        setTimeout(function () {
          HMRLoadingView._showing = false;
        }, TOAST_SHORT_DELAY);
      }
    }, {
      key: "hide",
      value: function hide() {}
    }]);

    return HMRLoadingView;
  }();

  module.exports = HMRLoadingView;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Utilities_HMRLoadingView.android.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_react-native_Libraries_Components_ToastAndroid_ToastAndroid.android.js"],"node_modules/react-native/Libraries/Utilities/HMRLoadingView.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (__DEV__) {
    if (!global.__RCTProfileIsProfiling) {
      if (!window.document) {
        _$$_REQUIRE(_dependencyMap[0], "setupDevtools");
      }

      var JSInspector = _$$_REQUIRE(_dependencyMap[1], "JSInspector");

      JSInspector.registerAgent(_$$_REQUIRE(_dependencyMap[2], "NetworkAgent"));
    }
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_setUpDeveloperTools.js",["system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_setupDevtools.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_JSInspector_JSInspector.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_JSInspector_NetworkAgent.js"],"node_modules/react-native/Libraries/Core/setUpDeveloperTools.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var register = function register() {};

  if (__DEV__) {
    var AppState = _$$_REQUIRE(_dependencyMap[0], "AppState");

    var WebSocket = _$$_REQUIRE(_dependencyMap[1], "WebSocket");

    var reactDevTools = _$$_REQUIRE(_dependencyMap[2], "react-devtools-core");

    var getDevServer = _$$_REQUIRE(_dependencyMap[3], "getDevServer");

    if (WebSocket.isAvailable) {
      var isAppActive = function isAppActive() {
        return AppState.currentState !== 'background';
      };

      var devServer = getDevServer();
      var host = devServer.bundleLoadedFromServer ? devServer.url.replace(/https?:\/\//, '').split(':')[0] : 'localhost';
      reactDevTools.connectToDevTools({
        isAppActive: isAppActive,
        host: host,
        port: window.__REACT_DEVTOOLS_PORT__,
        resolveRNStyle: _$$_REQUIRE(_dependencyMap[4], "flattenStyle")
      });
    }
  }

  module.exports = {
    register: register
  };
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_setupDevtools.js",["node_modules_react-native_Libraries_AppState_AppState.js","node_modules_react-native_Libraries_WebSocket_WebSocket.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-devtools-core_build_backend.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_getDevServer.js","node_modules_react-native_Libraries_StyleSheet_flattenStyle.js"],"node_modules/react-native/Libraries/Core/Devtools/setupDevtools.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  !function (e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.ReactDevToolsBackend = t() : e.ReactDevToolsBackend = t();
  }(window, function () {
    return function (e) {
      var t = {};

      function n(r) {
        if (t[r]) return t[r].exports;
        var o = t[r] = {
          i: r,
          l: !1,
          exports: {}
        };
        return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
      }

      return n.m = e, n.c = t, n.d = function (e, t, r) {
        n.o(e, t) || Object.defineProperty(e, t, {
          enumerable: !0,
          get: r
        });
      }, n.r = function (e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
          value: "Module"
        }), Object.defineProperty(e, "__esModule", {
          value: !0
        });
      }, n.t = function (e, t) {
        if (1 & t && (e = n(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var r = Object.create(null);
        if (n.r(r), Object.defineProperty(r, "default", {
          enumerable: !0,
          value: e
        }), 2 & t && "string" != typeof e) for (var o in e) {
          n.d(r, o, function (t) {
            return e[t];
          }.bind(null, o));
        }
        return r;
      }, n.n = function (e) {
        var t = e && e.__esModule ? function () {
          return e.default;
        } : function () {
          return e;
        };
        return n.d(t, "a", t), t;
      }, n.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }, n.p = "", n(n.s = 8);
    }([function (e, t, n) {
      var r, o, i;
      !function (a, s) {
        "use strict";

        o = [n(54)], void 0 === (i = "function" == typeof (r = function r(e) {
          var t = /(^|@)\S+\:\d+/,
              n = /^\s*at .*(\S+\:\d+|\(native\))/m,
              r = /^(eval@)?(\[native code\])?$/;
          return {
            parse: function parse(e) {
              if (void 0 !== e.stacktrace || void 0 !== e["opera#sourceloc"]) return this.parseOpera(e);
              if (e.stack && e.stack.match(n)) return this.parseV8OrIE(e);
              if (e.stack) return this.parseFFOrSafari(e);
              throw new Error("Cannot parse given Error object");
            },
            extractLocation: function extractLocation(e) {
              if (-1 === e.indexOf(":")) return [e];
              var t = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/.exec(e.replace(/[\(\)]/g, ""));
              return [t[1], t[2] || void 0, t[3] || void 0];
            },
            parseV8OrIE: function parseV8OrIE(t) {
              var r = t.stack.split("\n").filter(function (e) {
                return !!e.match(n);
              }, this);
              return r.map(function (t) {
                t.indexOf("(eval ") > -1 && (t = t.replace(/eval code/g, "eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, ""));
                var n = t.replace(/^\s+/, "").replace(/\(eval code/g, "(").split(/\s+/).slice(1),
                    r = this.extractLocation(n.pop()),
                    o = n.join(" ") || void 0,
                    i = ["eval", "<anonymous>"].indexOf(r[0]) > -1 ? void 0 : r[0];
                return new e({
                  functionName: o,
                  fileName: i,
                  lineNumber: r[1],
                  columnNumber: r[2],
                  source: t
                });
              }, this);
            },
            parseFFOrSafari: function parseFFOrSafari(t) {
              var n = t.stack.split("\n").filter(function (e) {
                return !e.match(r);
              }, this);
              return n.map(function (t) {
                if (t.indexOf(" > eval") > -1 && (t = t.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ":$1")), -1 === t.indexOf("@") && -1 === t.indexOf(":")) return new e({
                  functionName: t
                });
                var n = /((.*".+"[^@]*)?[^@]*)(?:@)/,
                    r = t.match(n),
                    o = r && r[1] ? r[1] : void 0,
                    i = this.extractLocation(t.replace(n, ""));
                return new e({
                  functionName: o,
                  fileName: i[0],
                  lineNumber: i[1],
                  columnNumber: i[2],
                  source: t
                });
              }, this);
            },
            parseOpera: function parseOpera(e) {
              return !e.stacktrace || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length ? this.parseOpera9(e) : e.stack ? this.parseOpera11(e) : this.parseOpera10(e);
            },
            parseOpera9: function parseOpera9(t) {
              for (var n = /Line (\d+).*script (?:in )?(\S+)/i, r = t.message.split("\n"), o = [], i = 2, a = r.length; i < a; i += 2) {
                var s = n.exec(r[i]);
                s && o.push(new e({
                  fileName: s[2],
                  lineNumber: s[1],
                  source: r[i]
                }));
              }

              return o;
            },
            parseOpera10: function parseOpera10(t) {
              for (var n = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i, r = t.stacktrace.split("\n"), o = [], i = 0, a = r.length; i < a; i += 2) {
                var s = n.exec(r[i]);
                s && o.push(new e({
                  functionName: s[3] || void 0,
                  fileName: s[2],
                  lineNumber: s[1],
                  source: r[i]
                }));
              }

              return o;
            },
            parseOpera11: function parseOpera11(n) {
              var r = n.stack.split("\n").filter(function (e) {
                return !!e.match(t) && !e.match(/^Error created at/);
              }, this);
              return r.map(function (t) {
                var n,
                    r = t.split("@"),
                    o = this.extractLocation(r.pop()),
                    i = r.shift() || "",
                    a = i.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^\)]*\)/g, "") || void 0;
                i.match(/\(([^\)]*)\)/) && (n = i.replace(/^[^\(]+\(([^\)]*)\)$/, "$1"));
                var s = void 0 === n || "[arguments not available]" === n ? void 0 : n.split(",");
                return new e({
                  functionName: a,
                  args: s,
                  fileName: o[0],
                  lineNumber: o[1],
                  columnNumber: o[2],
                  source: t
                });
              }, this);
            }
          };
        }) ? r.apply(t, o) : r) || (e.exports = i);
      }();
    }, function (e, t, n) {
      "use strict";

      var r = Object.prototype.hasOwnProperty,
          o = Object.prototype.propertyIsEnumerable;

      e.exports = Object.assign || function (e, t) {
        for (var n, i, a = function (e) {
          if (null == e) throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(e);
        }(e), s = 1; s < arguments.length; s++) {
          for (var u in n = Object(arguments[s])) {
            r.call(n, u) && (a[u] = n[u]);
          }

          if (Object.getOwnPropertySymbols) {
            i = Object.getOwnPropertySymbols(n);

            for (var c = 0; c < i.length; c++) {
              o.call(n, i[c]) && (a[i[c]] = n[i[c]]);
            }
          }
        }

        return a;
      };
    }, function (e, t, n) {
      "use strict";

      function r(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = n, e;
      }

      function o(e, t, n, i) {
        if (n >= t.length) return i;
        var a = t[n],
            s = Array.isArray(e) ? e.slice() : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {},
                o = Object.keys(n);
            "function" == typeof Object.getOwnPropertySymbols && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function (e) {
              return Object.getOwnPropertyDescriptor(n, e).enumerable;
            }))), o.forEach(function (t) {
              r(e, t, n[t]);
            });
          }

          return e;
        }({}, e);
        return s[a] = o(e[a], t, n + 1, i), s;
      }

      e.exports = function (e, t, n) {
        return o(e, t, 0, n);
      };
    }, function (e, t) {
      function n(e) {
        return function (e) {
          if (Array.isArray(e)) {
            for (var t = 0, n = new Array(e.length); t < e.length; t++) {
              n[t] = e[t];
            }

            return n;
          }
        }(e) || function (e) {
          if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e);
        }(e) || function () {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
      }

      var r = Object.prototype.hasOwnProperty;

      e.exports = function (e, t) {
        return t.reduce(function (e, t) {
          if (e) {
            if (r.call(e, t)) return e[t];
            if ("function" == typeof e[Symbol.iterator]) return n(e)[t];
          }

          return null;
        }, e);
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(14);
      e.exports = {
        name: r("name"),
        type: r("type"),
        inspected: r("inspected"),
        meta: r("meta"),
        proto: r("proto")
      };
    }, function (e, t, n) {
      "use strict";

      var r = /^(.*) \[from (.*)\]$/,
          o = new WeakMap();

      e.exports = function (e) {
        var t,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Unknown",
            i = o.get(e);
        if (null != i) return i;
        "string" == typeof e.displayName && (t = e.displayName), t || (t = e.name || n);
        var a = t.match(r);

        if (a) {
          var s = a[1],
              u = a[2];
          s && u && (u === s || u.startsWith(s + ".")) && (t = s);
        }

        return o.set(e, t), t;
      };
    }, function (e, t) {
      var n,
          r,
          o = e.exports = {};

      function i() {
        throw new Error("setTimeout has not been defined");
      }

      function a() {
        throw new Error("clearTimeout has not been defined");
      }

      function s(e) {
        if (n === setTimeout) return setTimeout(e, 0);
        if ((n === i || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);

        try {
          return n(e, 0);
        } catch (t) {
          try {
            return n.call(null, e, 0);
          } catch (t) {
            return n.call(this, e, 0);
          }
        }
      }

      !function () {
        try {
          n = "function" == typeof setTimeout ? setTimeout : i;
        } catch (e) {
          n = i;
        }

        try {
          r = "function" == typeof clearTimeout ? clearTimeout : a;
        } catch (e) {
          r = a;
        }
      }();
      var u,
          c = [],
          l = !1,
          f = -1;

      function p() {
        l && u && (l = !1, u.length ? c = u.concat(c) : f = -1, c.length && d());
      }

      function d() {
        if (!l) {
          var e = s(p);
          l = !0;

          for (var t = c.length; t;) {
            for (u = c, c = []; ++f < t;) {
              u && u[f].run();
            }

            f = -1, t = c.length;
          }

          u = null, l = !1, function (e) {
            if (r === clearTimeout) return clearTimeout(e);
            if ((r === a || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e);

            try {
              r(e);
            } catch (t) {
              try {
                return r.call(null, e);
              } catch (t) {
                return r.call(this, e);
              }
            }
          }(e);
        }
      }

      function h(e, t) {
        this.fun = e, this.array = t;
      }

      function m() {}

      o.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) {
          t[n - 1] = arguments[n];
        }
        c.push(new h(e, t)), 1 !== c.length || l || s(d);
      }, h.prototype.run = function () {
        this.fun.apply(null, this.array);
      }, o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = m, o.addListener = m, o.once = m, o.off = m, o.removeListener = m, o.removeAllListeners = m, o.emit = m, o.prependListener = m, o.prependOnceListener = m, o.listeners = function (e) {
        return [];
      }, o.binding = function (e) {
        throw new Error("process.binding is not supported");
      }, o.cwd = function () {
        return "/";
      }, o.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }, o.umask = function () {
        return 0;
      };
    }, function (e, t) {
      function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var r;

      r = function () {
        return this;
      }();

      try {
        r = r || Function("return this")() || (0, eval)("this");
      } catch (e) {
        "object" === ("undefined" == typeof window ? "undefined" : n(window)) && (r = window);
      }

      e.exports = r;
    }, function (e, t, n) {
      "use strict";

      var r = n(9),
          o = n(13),
          i = n(37),
          a = n(38),
          s = n(39),
          u = n(48),
          c = n(52),
          l = n(61).default,
          f = n(55);
      a(window), window.document && window.__REACT_DEVTOOLS_GLOBAL_HOOK__.on("react-devtools", function (e) {
        n(56)(e);
      }), e.exports = {
        connectToDevTools: function e(t) {
          var n = t || {},
              a = n.host,
              p = void 0 === a ? "localhost" : a,
              d = n.port,
              h = void 0 === d ? 8097 : d,
              m = n.websocket,
              y = n.resolveRNStyle,
              v = void 0 === y ? null : y,
              g = n.isAppActive;

          function b() {
            setTimeout(function () {
              return e(t);
            }, 2e3);
          }

          if ((void 0 === g ? function () {
            return !0;
          } : g)()) {
            var _ = [],
                w = [],
                S = "ws://" + p + ":" + h,
                E = m || new window.WebSocket(S);
            E.onclose = function () {
              O || (O = !0, b(), w.forEach(function (e) {
                return e();
              }));
            }, E.onerror = function () {
              O || (O = !0, w.forEach(function (e) {
                return e();
              }));
            }, E.onmessage = function (e) {
              var t;

              try {
                u("string" == typeof e.data), t = JSON.parse(e.data);
              } catch (t) {
                return void console.error("failed to parse json: " + String(e.data));
              }

              _.forEach(function (e) {
                try {
                  e(t);
                } catch (e) {
                  throw console.log(t), e;
                }
              });
            }, E.onopen = function () {
              !function (e, t) {
                e.onClose(function () {
                  a && a.emit("shutdown"), window.__REACT_DEVTOOLS_GLOBAL_HOOK__.emit("shutdown"), n = null, a = null, console.log("closing devtools");
                });
                var n = new o(e),
                    a = new r(window, {
                  rnStyle: !!t,
                  rnStyleMeasure: !!t
                });
                a.addBridge(n), t && c(n, a, t), f(n, a, window.__REACT_DEVTOOLS_GLOBAL_HOOK__), l(n, a);
                var u = setTimeout(function () {
                  console.warn("react-devtools agent got no connection");
                }, 2e4);
                a.once("connected", function () {
                  a && (s(window.__REACT_DEVTOOLS_GLOBAL_HOOK__, a), clearTimeout(u));
                }), i.init(a);
              }({
                listen: function listen(e) {
                  _.push(e);
                },
                onClose: function onClose(e) {
                  w.push(e);
                },
                send: function send(e) {
                  E.send(JSON.stringify(e));
                }
              }, v);
            };
            var O = !1;
          } else b();
        }
      };
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function o(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
      }

      function i(e) {
        return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
      }

      function a(e, t) {
        return (a = Object.setPrototypeOf || function (e, t) {
          return e.__proto__ = t, e;
        })(e, t);
      }

      function s(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }

      var u = n(10).EventEmitter,
          c = n(1),
          l = n(11).default,
          f = n(12),
          p = n(3),
          d = function (e) {
        function t(e, n) {
          var o, a, u, l;
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, t), a = this, u = i(t).call(this), (o = !u || "object" !== r(u) && "function" != typeof u ? s(a) : u).global = e, o.internalInstancesById = new Map(), o.idsByInternalInstances = new WeakMap(), o.renderers = new Map(), o.elementData = new Map(), o.roots = new Set(), o.reactInternals = {}, o.on("selected", function (e) {
            var t = o.elementData.get(e);
            t && t.publicInstance && o.global.$r === l && (o.global.$r = t.publicInstance, l = t.publicInstance);
          }), o._prevSelected = null, o._scrollUpdate = !1;
          var f = window.document && "function" == typeof window.document.createElement;
          return o.capabilities = c({
            scroll: f && "function" == typeof window.document.body.scrollIntoView,
            dom: f,
            editTextContent: !1
          }, n), f && (o._updateScroll = o._updateScroll.bind(s(s(o))), window.addEventListener("scroll", o._onScroll.bind(s(s(o))), !0), window.addEventListener("click", o._onClick.bind(s(s(o))), !0), window.addEventListener("mouseover", o._onMouseOver.bind(s(s(o))), !0), window.addEventListener("resize", o._onResize.bind(s(s(o))), !0)), o;
        }

        var n, d, h;
        return function (e, t) {
          if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
          e.prototype = Object.create(t && t.prototype, {
            constructor: {
              value: e,
              writable: !0,
              configurable: !0
            }
          }), t && a(e, t);
        }(t, u), n = t, (d = [{
          key: "sub",
          value: function value(e, t) {
            var n = this;
            return this.on(e, t), function () {
              n.removeListener(e, t);
            };
          }
        }, {
          key: "setReactInternals",
          value: function value(e, t) {
            this.reactInternals[e] = t;
          }
        }, {
          key: "addBridge",
          value: function value(e) {
            var t = this;
            e.on("requestCapabilities", function () {
              e.send("capabilities", t.capabilities), t.emit("connected");
            }), e.on("setState", this._setState.bind(this)), e.on("setProps", this._setProps.bind(this)), e.on("setContext", this._setContext.bind(this)), e.on("makeGlobal", this._makeGlobal.bind(this)), e.on("highlight", function (e) {
              return t.highlight(e);
            }), e.on("highlightMany", function (e) {
              return t.highlightMany(e);
            }), e.on("hideHighlight", function () {
              return t.emit("hideHighlight");
            }), e.on("startInspecting", function () {
              return t.emit("startInspecting");
            }), e.on("stopInspecting", function () {
              return t.emit("stopInspecting");
            }), e.on("selected", function (e) {
              return t.emit("selected", e);
            }), e.on("isRecording", function (e) {
              return t.emit("isRecording", e);
            }), e.on("setInspectEnabled", function (e) {
              t._inspectEnabled = e, t.emit("stopInspecting");
            }), e.on("shutdown", function () {
              return t.emit("shutdown");
            }), e.on("changeTextContent", function (e) {
              var n = e.id,
                  r = e.text,
                  o = t.getNodeForID(n);
              o && (o.textContent = r);
            }), e.on("putSelectedNode", function (e) {
              window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node = t.getNodeForID(e);
            }), e.on("putSelectedInstance", function (e) {
              var n = t.elementData.get(e);
              window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$type = n ? n.type : null, n && n.publicInstance ? window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = n.publicInstance : window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = null;
            }), e.on("checkSelection", function () {
              var e = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;
              e !== t._prevSelected && (t._prevSelected = e, e !== window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node && t.selectFromDOMNode(e, !0));
            }), e.on("scrollToNode", function (e) {
              return t.scrollToNode(e);
            }), e.on("traceupdatesstatechange", function (e) {
              return t.emit("traceupdatesstatechange", e);
            }), e.on("colorizerchange", function (e) {
              return t.emit("colorizerchange", e);
            }), this.on("root", function (t) {
              return e.send("root", t);
            }), this.on("mount", function (t) {
              return e.send("mount", t);
            }), this.on("update", function (t) {
              return e.send("update", t);
            }), this.on("updateProfileTimes", function (t) {
              return e.send("updateProfileTimes", t);
            }), this.on("unmount", function (t) {
              e.send("unmount", t), e.forget(t);
            }), this.on("setSelection", function (t) {
              return e.send("select", t);
            }), this.on("setInspectEnabled", function (t) {
              return e.send("setInspectEnabled", t);
            }), this.on("isRecording", function (t) {
              return e.send("isRecording", t);
            }), this.on("storeSnapshot", function (t) {
              return e.send("storeSnapshot", t);
            }), this.on("clearSnapshots", function () {
              return e.send("clearSnapshots");
            });
          }
        }, {
          key: "scrollToNode",
          value: function value(e) {
            var t = this.getNodeForID(e);

            if (t) {
              var n = t.nodeType === Node.ELEMENT_NODE ? t : t.parentElement;
              n ? ("function" == typeof n.scrollIntoViewIfNeeded ? n.scrollIntoViewIfNeeded() : "function" == typeof n.scrollIntoView && n.scrollIntoView(), this.highlight(e)) : console.warn("unable to get the domElement for scrolling");
            } else console.warn("unable to get the node for scrolling");
          }
        }, {
          key: "highlight",
          value: function value(e) {
            var t = this.elementData.get(e),
                n = this.getNodeForID(e);
            t && n && this.emit("highlight", {
              node: n,
              name: t.name,
              props: t.props
            });
          }
        }, {
          key: "highlightMany",
          value: function value(e) {
            var t = this,
                n = [];
            e.forEach(function (e) {
              var r = t.getNodeForID(e);
              r && n.push(r);
            }), n.length && this.emit("highlightMany", n);
          }
        }, {
          key: "getNodeForID",
          value: function value(e) {
            var t = this.internalInstancesById.get(e);
            if (!t) return null;
            var n = this.renderers.get(e);
            return n && this.reactInternals[n].getNativeFromReactElement ? this.reactInternals[n].getNativeFromReactElement(t) : null;
          }
        }, {
          key: "selectFromDOMNode",
          value: function value(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                r = this.getIDForNode(e);
            r && this.emit("setSelection", {
              id: r,
              quiet: t,
              offsetFromLeaf: n
            });
          }
        }, {
          key: "selectFromReactInstance",
          value: function value(e, t) {
            var n = this.getId(e);
            n ? this.emit("setSelection", {
              id: n,
              quiet: t
            }) : console.log("no instance id", e);
          }
        }, {
          key: "getIDForNode",
          value: function value(e) {
            if (!this.reactInternals) return null;
            var t;

            for (var n in this.reactInternals) {
              try {
                t = this.reactInternals[n].getReactElementFromNative(e);
              } catch (e) {}

              if (t) return this.getId(t);
            }

            return null;
          }
        }, {
          key: "_setProps",
          value: function value(e) {
            var t = e.id,
                n = e.path,
                r = e.value,
                o = this.elementData.get(t);
            o && o.updater && "function" == typeof o.updater.setInProps ? o.updater.setInProps(n, r) : console.warn("trying to set props on a component that doesn't support it");
          }
        }, {
          key: "_setState",
          value: function value(e) {
            var t = e.id,
                n = e.path,
                r = e.value,
                o = this.elementData.get(t);
            o && o.updater && "function" == typeof o.updater.setInState ? o.updater.setInState(n, r) : console.warn("trying to set state on a component that doesn't support it");
          }
        }, {
          key: "_setContext",
          value: function value(e) {
            var t = e.id,
                n = e.path,
                r = e.value,
                o = this.elementData.get(t);
            o && o.updater && "function" == typeof o.updater.setInContext ? o.updater.setInContext(n, r) : console.warn("trying to set context on a component that doesn't support it");
          }
        }, {
          key: "_makeGlobal",
          value: function value(e) {
            var t,
                n = e.id,
                r = e.path,
                o = this.elementData.get(n);
            o && (t = "instance" === r ? o.publicInstance : p(o, r), this.global.$tmp = t, console.log("$tmp =", t));
          }
        }, {
          key: "getId",
          value: function value(e) {
            return "object" === r(e) && e ? (this.idsByInternalInstances.has(e) || (this.idsByInternalInstances.set(e, f()), this.internalInstancesById.set(l(this.idsByInternalInstances.get(e)), e)), l(this.idsByInternalInstances.get(e))) : e;
          }
        }, {
          key: "addRoot",
          value: function value(e, t) {
            var n = this.getId(t);
            this.roots.add(n), this.emit("root", n);
          }
        }, {
          key: "rootCommitted",
          value: function value(e, t, n) {
            var r = this.getId(t);
            this.emit("rootCommitted", r, t, n);
          }
        }, {
          key: "onMounted",
          value: function value(e, t, n) {
            var r = this,
                o = this.getId(t);
            this.renderers.set(o, e), this.elementData.set(o, n);
            var i = c({}, n);
            i.children && i.children.map && (i.children = i.children.map(function (e) {
              return r.getId(e);
            })), i.id = o, i.canUpdate = i.updater && i.updater.canUpdate, delete i.type, delete i.updater, this.emit("mount", i);
          }
        }, {
          key: "onUpdated",
          value: function value(e, t) {
            var n = this,
                r = this.getId(e);
            this.elementData.set(r, t);
            var o = c({}, t);
            o.children && o.children.map && (o.children = o.children.map(function (e) {
              return n.getId(e);
            })), o.id = r, o.canUpdate = o.updater && o.updater.canUpdate, delete o.type, delete o.updater, this.emit("update", o);
          }
        }, {
          key: "onUpdatedProfileTimes",
          value: function value(e, t) {
            var n = this,
                r = this.getId(e);
            this.elementData.set(r, t);
            var o = c({}, t);
            o.children && o.children.map && (o.children = o.children.map(function (e) {
              return n.getId(e);
            })), o.id = r, o.canUpdate = o.updater && o.updater.canUpdate, delete o.type, delete o.updater, this.emit("updateProfileTimes", o);
          }
        }, {
          key: "onUnmounted",
          value: function value(e) {
            var t = this.getId(e);
            this.elementData.delete(t), this.roots.has(t) && (this.roots.delete(t), this.emit("rootUnmounted", t)), this.renderers.delete(t), this.emit("unmount", t), this.idsByInternalInstances.delete(e);
          }
        }, {
          key: "_onScroll",
          value: function value() {
            this._scrollUpdate || (this._scrollUpdate = !0, window.requestAnimationFrame(this._updateScroll));
          }
        }, {
          key: "_updateScroll",
          value: function value() {
            this.emit("refreshMultiOverlay"), this.emit("stopInspecting"), this._scrollUpdate = !1;
          }
        }, {
          key: "_onClick",
          value: function value(e) {
            if (this._inspectEnabled) {
              var t = this.getIDForNode(e.target);
              t && (e.stopPropagation(), e.preventDefault(), this.emit("setSelection", {
                id: t
              }), this.emit("setInspectEnabled", !1));
            }
          }
        }, {
          key: "_onMouseOver",
          value: function value(e) {
            if (this._inspectEnabled) {
              var t = this.getIDForNode(e.target);
              if (!t) return;
              this.highlight(t);
            }
          }
        }, {
          key: "_onResize",
          value: function value(e) {
            this.emit("stopInspecting");
          }
        }]) && o(n.prototype, d), h && o(n, h), t;
      }();

      e.exports = d;
    }, function (e, t) {
      function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function r() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
      }

      function o(e) {
        return "function" == typeof e;
      }

      function i(e) {
        return "object" === n(e) && null !== e;
      }

      function a(e) {
        return void 0 === e;
      }

      e.exports = r, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._maxListeners = void 0, r.defaultMaxListeners = 10, r.prototype.setMaxListeners = function (e) {
        if ("number" != typeof e || e < 0 || isNaN(e)) throw TypeError("n must be a positive number");
        return this._maxListeners = e, this;
      }, r.prototype.emit = function (e) {
        var t, n, r, s, u, c;

        if (this._events || (this._events = {}), "error" === e && (!this._events.error || i(this._events.error) && !this._events.error.length)) {
          if ((t = arguments[1]) instanceof Error) throw t;
          var l = new Error('Uncaught, unspecified "error" event. (' + t + ")");
          throw l.context = t, l;
        }

        if (a(n = this._events[e])) return !1;
        if (o(n)) switch (arguments.length) {
          case 1:
            n.call(this);
            break;

          case 2:
            n.call(this, arguments[1]);
            break;

          case 3:
            n.call(this, arguments[1], arguments[2]);
            break;

          default:
            s = Array.prototype.slice.call(arguments, 1), n.apply(this, s);
        } else if (i(n)) for (s = Array.prototype.slice.call(arguments, 1), r = (c = n.slice()).length, u = 0; u < r; u++) {
          c[u].apply(this, s);
        }
        return !0;
      }, r.prototype.addListener = function (e, t) {
        var n;
        if (!o(t)) throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", e, o(t.listener) ? t.listener : t), this._events[e] ? i(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, i(this._events[e]) && !this._events[e].warned && (n = a(this._maxListeners) ? r.defaultMaxListeners : this._maxListeners) && n > 0 && this._events[e].length > n && (this._events[e].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length), "function" == typeof console.trace && console.trace()), this;
      }, r.prototype.on = r.prototype.addListener, r.prototype.once = function (e, t) {
        if (!o(t)) throw TypeError("listener must be a function");
        var n = !1;

        function r() {
          this.removeListener(e, r), n || (n = !0, t.apply(this, arguments));
        }

        return r.listener = t, this.on(e, r), this;
      }, r.prototype.removeListener = function (e, t) {
        var n, r, a, s;
        if (!o(t)) throw TypeError("listener must be a function");
        if (!this._events || !this._events[e]) return this;
        if (a = (n = this._events[e]).length, r = -1, n === t || o(n.listener) && n.listener === t) delete this._events[e], this._events.removeListener && this.emit("removeListener", e, t);else if (i(n)) {
          for (s = a; s-- > 0;) {
            if (n[s] === t || n[s].listener && n[s].listener === t) {
              r = s;
              break;
            }
          }

          if (r < 0) return this;
          1 === n.length ? (n.length = 0, delete this._events[e]) : n.splice(r, 1), this._events.removeListener && this.emit("removeListener", e, t);
        }
        return this;
      }, r.prototype.removeAllListeners = function (e) {
        var t, n;
        if (!this._events) return this;
        if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[e] && delete this._events[e], this;

        if (0 === arguments.length) {
          for (t in this._events) {
            "removeListener" !== t && this.removeAllListeners(t);
          }

          return this.removeAllListeners("removeListener"), this._events = {}, this;
        }

        if (o(n = this._events[e])) this.removeListener(e, n);else if (n) for (; n.length;) {
          this.removeListener(e, n[n.length - 1]);
        }
        return delete this._events[e], this;
      }, r.prototype.listeners = function (e) {
        return this._events && this._events[e] ? o(this._events[e]) ? [this._events[e]] : this._events[e].slice() : [];
      }, r.prototype.listenerCount = function (e) {
        if (this._events) {
          var t = this._events[e];
          if (o(t)) return 1;
          if (t) return t.length;
        }

        return 0;
      }, r.listenerCount = function (e, t) {
        return e.listenerCount(t);
      };
    }, function (e, t, n) {
      "use strict";

      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.default = function (e) {
        if (null != e) return e;
        throw new Error("Got unexpected null or undefined");
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = function () {
        return "g" + Math.random().toString(16).substr(2);
      };
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return function (e) {
          if (Array.isArray(e)) {
            for (var t = 0, n = new Array(e.length); t < e.length; t++) {
              n[t] = e[t];
            }

            return n;
          }
        }(e) || function (e) {
          if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e);
        }(e) || function () {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
      }

      function o(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = n, e;
      }

      function i(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
      }

      var a = n(4),
          s = n(32),
          u = n(33),
          c = n(3),
          l = n(34);

      function f(e, t) {
        return -1 === String(window[e]).indexOf("[native code]") ? t : window[e];
      }

      var p = 5,
          d = f("cancelIdleCallback", clearTimeout),
          h = f("requestIdleCallback", function (e, t) {
        var n = 3e3 * p;
        return n > 500 && (n = 500), setTimeout(function () {
          var t = l();
          e({
            didTimeout: !1,
            timeRemaining: function timeRemaining() {
              return 1 / 0;
            }
          });
          var n = l();
          p = (n - t) / 1e3;
        }, n);
      }),
          m = function () {
        function e(t) {
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, e), this._cbs = new Map(), this._inspectables = new Map(), this._cid = 0, this._listeners = {}, this._buffer = [], this._flushHandle = null, this._callers = {}, this._paused = !1, this._wall = t, t.listen(this._handleMessage.bind(this));
        }

        var t, n, l;
        return t = e, (n = [{
          key: "inspect",
          value: function value(e, t, n) {
            var r = this._cid++;
            this._cbs.set(r, function (e, t, r, o) {
              t.length && s(e, t), r && o.length && s(r, o), r && (e[a.proto] = r), n(e);
            }), this._wall.send({
              type: "inspect",
              callback: r,
              path: t,
              id: e
            });
          }
        }, {
          key: "call",
          value: function value(e, t, n) {
            var r = this._cid++;
            this._cbs.set(r, n), this._wall.send({
              type: "call",
              callback: r,
              args: t,
              name: e
            });
          }
        }, {
          key: "onCall",
          value: function value(e, t) {
            if (this._callers[e]) throw new Error("only one call handler per call name allowed");
            this._callers[e] = t;
          }
        }, {
          key: "pause",
          value: function value() {
            this._wall.send({
              type: "pause"
            });
          }
        }, {
          key: "resume",
          value: function value() {
            this._wall.send({
              type: "resume"
            });
          }
        }, {
          key: "setInspectable",
          value: function value(e, t) {
            var n = this._inspectables.get(e);

            n ? this._inspectables.set(e, function (e) {
              for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? arguments[t] : {},
                    r = Object.keys(n);
                "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (e) {
                  return Object.getOwnPropertyDescriptor(n, e).enumerable;
                }))), r.forEach(function (t) {
                  o(e, t, n[t]);
                });
              }

              return e;
            }({}, n, t)) : this._inspectables.set(e, t);
          }
        }, {
          key: "send",
          value: function value(e, t) {
            this._buffer.push({
              evt: e,
              data: t
            }), this.scheduleFlush();
          }
        }, {
          key: "scheduleFlush",
          value: function value() {
            if (!this._flushHandle && this._buffer.length) {
              var e = this._paused ? 5e3 : 500;
              this._flushHandle = h(this.flushBufferWhileIdle.bind(this), {
                timeout: e
              });
            }
          }
        }, {
          key: "cancelFlush",
          value: function value() {
            this._flushHandle && (d(this._flushHandle), this._flushHandle = null);
          }
        }, {
          key: "flushBufferWhileIdle",
          value: function value(e) {
            this._flushHandle = null;

            for (var t = this._paused ? 20 : 10, n = Math.round(this._buffer.length / t), r = this._paused ? 50 : 100; this._buffer.length && (e.timeRemaining() > 0 || e.didTimeout);) {
              var o = Math.min(this._buffer.length, Math.max(r, n)),
                  i = this._buffer.splice(0, o);

              this.flushBufferSlice(i);
            }

            this._buffer.length && this.scheduleFlush();
          }
        }, {
          key: "flushBufferSlice",
          value: function value(e) {
            var t = this,
                n = e.map(function (e) {
              var n = e.evt,
                  r = e.data,
                  o = [],
                  i = u(r, o);
              return o.length && t.setInspectable(r.id, r), {
                type: "event",
                evt: n,
                data: i,
                cleaned: o
              };
            });

            this._wall.send({
              type: "many-events",
              events: n
            });
          }
        }, {
          key: "forget",
          value: function value(e) {
            this._inspectables.delete(e);
          }
        }, {
          key: "on",
          value: function value(e, t) {
            this._listeners[e] ? this._listeners[e].push(t) : this._listeners[e] = [t];
          }
        }, {
          key: "off",
          value: function value(e, t) {
            if (this._listeners[e]) {
              var n = this._listeners[e].indexOf(t);

              -1 !== n && this._listeners[e].splice(n, 1);
            }
          }
        }, {
          key: "once",
          value: function value(e, t) {
            var n = this;
            this.on(e, function r() {
              t.apply(this, arguments), n.off(e, r);
            });
          }
        }, {
          key: "_handleMessage",
          value: function value(e) {
            var t = this;
            if ("resume" === e.type) return this._paused = !1, void this.scheduleFlush();
            if ("pause" === e.type) return this._paused = !0, void this.cancelFlush();
            if ("callback" !== e.type) {
              if ("call" !== e.type) {
                if ("inspect" !== e.type) {
                  if ("event" === e.type) {
                    e.cleaned && s(e.data, e.cleaned);
                    var n = this._listeners[e.evt],
                        o = e.data;
                    n && n.forEach(function (e) {
                      return e(o);
                    });
                  }

                  "many-events" === e.type && e.events.forEach(function (e) {
                    e.cleaned && s(e.data, e.cleaned);
                    var n = t._listeners[e.evt];
                    n && n.forEach(function (t) {
                      return t(e.data);
                    });
                  });
                } else this._inspectResponse(e.id, e.path, e.callback);
              } else this._handleCall(e.name, e.args, e.callback);
            } else {
              var i = this._cbs.get(e.id);

              i && (i.apply(void 0, r(e.args)), this._cbs.delete(e.id));
            }
          }
        }, {
          key: "_handleCall",
          value: function value(e, t, n) {
            if (this._callers[e]) {
              var r;
              t = Array.isArray(t) ? t : [t];

              try {
                r = this._callers[e].apply(null, t);
              } catch (e) {
                return void console.error("Failed to call", e);
              }

              this._wall.send({
                type: "callback",
                id: n,
                args: [r]
              });
            } else console.warn('unknown call: "' + e + '"');
          }
        }, {
          key: "_inspectResponse",
          value: function value(e, t, n) {
            var r = this._inspectables.get(e),
                o = {},
                i = [],
                a = null,
                s = [];

            if (r) {
              var l = c(r, t),
                  f = !1,
                  p = "function" == typeof l;

              if (l && "function" == typeof l[Symbol.iterator]) {
                var d = Object.create({}),
                    h = 0,
                    m = !0,
                    y = !1,
                    v = void 0;

                try {
                  for (var g, b = l[Symbol.iterator](); !(m = (g = b.next()).done); m = !0) {
                    var _ = g.value;
                    if (h > 100) break;
                    d[h] = _, h++;
                  }
                } catch (e) {
                  y = !0, v = e;
                } finally {
                  try {
                    m || null == b.return || b.return();
                  } finally {
                    if (y) throw v;
                  }
                }

                l = d;
              }

              if (Object.getOwnPropertyNames(l).forEach(function (e) {
                "__proto__" === e && (f = !0), (!p || "arguments" !== e && "callee" !== e && "caller" !== e) && (o[e] = u(l[e], i, [e]));
              }), !f && l.__proto__ && "Object" !== l.constructor.name) {
                var w = {},
                    S = "function" == typeof l.__proto__;
                Object.getOwnPropertyNames(l.__proto__).forEach(function (e) {
                  (!S || "arguments" !== e && "callee" !== e && "caller" !== e) && (w[e] = u(l.__proto__[e], s, [e]));
                }), a = w;
              }
            }

            this._wall.send({
              type: "callback",
              id: n,
              args: [o, i, a, s]
            });
          }
        }, {
          key: "wall",
          get: function get() {
            return this._wall;
          }
        }]) && i(t.prototype, n), l && i(t, l), e;
      }();

      e.exports = m;
    }, function (e, t, n) {
      "use strict";

      e.exports = n(15)() ? Symbol : n(16);
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      e.exports = function () {
        var e;
        if ("function" != typeof Symbol) return !1;
        e = Symbol("test symbol");

        try {
          String(e);
        } catch (e) {
          return !1;
        }

        return "symbol" === r(Symbol.iterator) || "object" === r(Symbol.isConcatSpreadable) && "object" === r(Symbol.iterator) && "object" === r(Symbol.toPrimitive) && "object" === r(Symbol.toStringTag) && "object" === r(Symbol.unscopables);
      };
    }, function (e, t, n) {
      "use strict";

      var r,
          o,
          _i,
          a = n(17),
          s = n(30),
          u = Object.create,
          c = Object.defineProperties,
          l = Object.defineProperty,
          f = Object.prototype,
          p = u(null);

      "function" == typeof Symbol && (r = Symbol);
      var d,
          h = (d = u(null), function (e) {
        for (var t, n, r = 0; d[e + (r || "")];) {
          ++r;
        }

        return d[e += r || ""] = !0, l(f, t = "@@" + e, a.gs(null, function (e) {
          n || (n = !0, l(this, t, a(e)), n = !1);
        })), t;
      });
      _i = function i(e) {
        if (this instanceof _i) throw new TypeError("TypeError: Symbol is not a constructor");
        return o(e);
      }, e.exports = o = function e(t) {
        var n;
        if (this instanceof e) throw new TypeError("TypeError: Symbol is not a constructor");
        return n = u(_i.prototype), t = void 0 === t ? "" : String(t), c(n, {
          __description__: a("", t),
          __name__: a("", h(t))
        });
      }, c(o, {
        for: a(function (e) {
          return p[e] ? p[e] : p[e] = o(String(e));
        }),
        keyFor: a(function (e) {
          var t;

          for (t in s(e), p) {
            if (p[t] === e) return t;
          }
        }),
        hasInstance: a("", r && r.hasInstance || o("hasInstance")),
        isConcatSpreadable: a("", r && r.isConcatSpreadable || o("isConcatSpreadable")),
        iterator: a("", r && r.iterator || o("iterator")),
        match: a("", r && r.match || o("match")),
        replace: a("", r && r.replace || o("replace")),
        search: a("", r && r.search || o("search")),
        species: a("", r && r.species || o("species")),
        split: a("", r && r.split || o("split")),
        toPrimitive: a("", r && r.toPrimitive || o("toPrimitive")),
        toStringTag: a("", r && r.toStringTag || o("toStringTag")),
        unscopables: a("", r && r.unscopables || o("unscopables"))
      }), c(_i.prototype, {
        constructor: a(o),
        toString: a("", function () {
          return this.__name__;
        })
      }), c(o.prototype, {
        toString: a(function () {
          return "Symbol (" + s(this).__description__ + ")";
        }),
        valueOf: a(function () {
          return s(this);
        })
      }), l(o.prototype, o.toPrimitive, a("", function () {
        return s(this);
      })), l(o.prototype, o.toStringTag, a("c", "Symbol")), l(_i.prototype, o.toStringTag, a("c", o.prototype[o.toStringTag])), l(_i.prototype, o.toPrimitive, a("c", o.prototype[o.toPrimitive]));
    }, function (e, t, n) {
      "use strict";

      var r = n(18),
          o = n(25),
          i = n(26),
          a = n(27);

      (e.exports = function (e, t) {
        var n, i, s, u, c;
        return arguments.length < 2 || "string" != typeof e ? (u = t, t = e, e = null) : u = arguments[2], null == e ? (n = s = !0, i = !1) : (n = a.call(e, "c"), i = a.call(e, "e"), s = a.call(e, "w")), c = {
          value: t,
          configurable: n,
          enumerable: i,
          writable: s
        }, u ? r(o(u), c) : c;
      }).gs = function (e, t, n) {
        var s, u, c, l;
        return "string" != typeof e ? (c = n, n = t, t = e, e = null) : c = arguments[3], null == t ? t = void 0 : i(t) ? null == n ? n = void 0 : i(n) || (c = n, n = void 0) : (c = t, t = n = void 0), null == e ? (s = !0, u = !1) : (s = a.call(e, "c"), u = a.call(e, "e")), l = {
          get: t,
          set: n,
          configurable: s,
          enumerable: u
        }, c ? r(o(c), l) : l;
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = n(19)() ? Object.assign : n(20);
    }, function (e, t, n) {
      "use strict";

      e.exports = function () {
        var e,
            t = Object.assign;
        return "function" == typeof t && (t(e = {
          foo: "raz"
        }, {
          bar: "dwa"
        }, {
          trzy: "trzy"
        }), e.foo + e.bar + e.trzy === "razdwatrzy");
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(21),
          o = n(24),
          i = Math.max;

      e.exports = function (e, t) {
        var n,
            a,
            s,
            u = i(arguments.length, 2);

        for (e = Object(o(e)), s = function s(r) {
          try {
            e[r] = t[r];
          } catch (e) {
            n || (n = e);
          }
        }, a = 1; a < u; ++a) {
          t = arguments[a], r(t).forEach(s);
        }

        if (void 0 !== n) throw n;
        return e;
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = n(22)() ? Object.keys : n(23);
    }, function (e, t, n) {
      "use strict";

      e.exports = function () {
        try {
          return Object.keys("primitive"), !0;
        } catch (e) {
          return !1;
        }
      };
    }, function (e, t, n) {
      "use strict";

      var r = Object.keys;

      e.exports = function (e) {
        return r(null == e ? e : Object(e));
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = function (e) {
        if (null == e) throw new TypeError("Cannot use null or undefined");
        return e;
      };
    }, function (e, t, n) {
      "use strict";

      var r = Array.prototype.forEach,
          o = Object.create;

      e.exports = function (e) {
        var t = o(null);
        return r.call(arguments, function (e) {
          null != e && function (e, t) {
            var n;

            for (n in e) {
              t[n] = e[n];
            }
          }(Object(e), t);
        }), t;
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = function (e) {
        return "function" == typeof e;
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = n(28)() ? String.prototype.contains : n(29);
    }, function (e, t, n) {
      "use strict";

      var r = "razdwatrzy";

      e.exports = function () {
        return "function" == typeof r.contains && !0 === r.contains("dwa") && !1 === r.contains("foo");
      };
    }, function (e, t, n) {
      "use strict";

      var r = String.prototype.indexOf;

      e.exports = function (e) {
        return r.call(this, e, arguments[1]) > -1;
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(31);

      e.exports = function (e) {
        if (!r(e)) throw new TypeError(e + " is not a symbol");
        return e;
      };
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      e.exports = function (e) {
        return e && ("symbol" === r(e) || "Symbol" === e["@@toStringTag"]) || !1;
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(4);

      e.exports = function (e, t) {
        t.forEach(function (t) {
          var n = t.pop(),
              o = t.reduce(function (e, t) {
            return e ? e[t] : null;
          }, e);

          if (o && o[n]) {
            var i = {};
            i[r.name] = o[n].name, i[r.type] = o[n].type, i[r.meta] = o[n].meta, i[r.inspected] = !1, o[n] = i;
          }
        });
      };
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var o = 2;

      function i(e, t, n, r) {
        var o = {};
        return "array" !== e && "typed_array" !== e || (o.length = t.length), "iterator" !== e && "typed_array" !== e || (o.readOnly = !0), n.push(r), {
          type: e,
          meta: o,
          name: t.constructor && "Object" !== t.constructor.name ? t.constructor.name : ""
        };
      }

      e.exports = function e(t, n) {
        var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
            u = function (e) {
          if (!e) return null;
          var t = r(e);

          if ("object" === t) {
            if (e._reactFragment) return "react_fragment";
            if (Array.isArray(e)) return "array";
            if (ArrayBuffer.isView(e)) return e instanceof DataView ? "data_view" : "typed_array";
            if (e instanceof ArrayBuffer) return "array_buffer";
            if ("function" == typeof e[Symbol.iterator]) return "iterator";
            if ("[object Date]" === Object.prototype.toString.call(e)) return "date";
          }

          return t;
        }(t);

        switch (u) {
          case "function":
            return n.push(a), {
              name: t.name,
              type: "function"
            };

          case "string":
            return t.length <= 500 ? t : t.slice(0, 500) + "...";

          case "symbol":
            return n.push(a), {
              type: "symbol",
              name: t.toString()
            };

          case "react_fragment":
            return "A React Fragment";

          case "array_buffer":
          case "data_view":
            return n.push(a), {
              type: u,
              name: "data_view" === u ? "DataView" : "ArrayBuffer",
              meta: {
                length: t.byteLength,
                uninspectable: !0
              }
            };

          case "array":
            return s > o ? i(u, t, n, a) : t.map(function (t, r) {
              return e(t, n, a.concat([r]), s + 1);
            });

          case "typed_array":
          case "iterator":
            return i(u, t, n, a);

          case "date":
            return n.push(a), {
              name: t.toString(),
              type: "date",
              meta: {
                uninspectable: !0
              }
            };

          case "object":
            if (s > o || t.constructor && "function" == typeof t.constructor && "Object" !== t.constructor.name) return i(u, t, n, a);
            var c = {};

            for (var l in t) {
              c[l] = e(t[l], n, a.concat([l]), s + 1);
            }

            return c;

          default:
            return t;
        }
      };
    }, function (e, t, n) {
      "use strict";

      var r,
          o = n(35);
      r = o.now ? function () {
        return o.now();
      } : function () {
        return Date.now();
      }, e.exports = r;
    }, function (e, t, n) {
      "use strict";

      var r;
      n(36).canUseDOM && (r = window.performance || window.msPerformance || window.webkitPerformance), e.exports = r || {};
    }, function (e, t, n) {
      "use strict";

      var r = !("undefined" == typeof window || !window.document || !window.document.createElement),
          o = {
        canUseDOM: r,
        canUseWorkers: "undefined" != typeof Worker,
        canUseEventListeners: r && !(!window.addEventListener && !window.attachEvent),
        canUseViewport: r && !!window.screen,
        isInWorker: !r
      };
      e.exports = o;
    }, function (e, t, n) {
      "use strict";

      function r(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
      }

      function o(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = n, e;
      }

      function i(e) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var a = "object" === ("undefined" == typeof performance ? "undefined" : i(performance)) && "function" == typeof performance.now ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      },
          s = function () {
        function e(t) {
          var n = this;
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, e), o(this, "_committedNodes", new Set()), o(this, "_isRecording", !1), o(this, "_maxActualDuration", 0), o(this, "_recordingStartTime", 0), o(this, "_onIsRecording", function (e) {
            n._committedNodes = new Set(), n._isRecording = e, n._recordingStartTime = e ? a() : 0, e && n._agent.emit("clearSnapshots");
          }), o(this, "_onMountOrUpdate", function (e) {
            n._isRecording && void 0 !== e.actualDuration && (n._committedNodes.add(e.id), n._maxActualDuration = Math.max(n._maxActualDuration, e.actualDuration));
          }), o(this, "_onRootCommitted", function (e, t, r) {
            n._isRecording && (n._takeCommitSnapshotForRoot(e, r), n._committedNodes = new Set(), n._maxActualDuration = 0);
          }), o(this, "_onUnmount", function (e) {
            n._committedNodes.delete(e);
          }), this._agent = t, t.on("isRecording", this._onIsRecording), t.on("mount", this._onMountOrUpdate), t.on("rootCommitted", this._onRootCommitted), t.on("unmount", this._onUnmount), t.on("update", this._onMountOrUpdate);
        }

        var t, n, i;
        return t = e, (n = [{
          key: "_takeCommitSnapshotForRoot",
          value: function value(e, t) {
            var n = this,
                r = {
              memoizedInteractions: (null != t.memoizedInteractions ? Array.from(t.memoizedInteractions) : []).map(function (e) {
                return {
                  name: e.name,
                  timestamp: e.timestamp - n._recordingStartTime
                };
              }),
              committedNodes: Array.from(this._committedNodes),
              commitTime: a() - this._recordingStartTime,
              duration: this._maxActualDuration,
              root: e
            };

            this._agent.emit("storeSnapshot", r);
          }
        }]) && r(t.prototype, n), i && r(t, i), e;
      }();

      e.exports = {
        init: function init(e) {
          return new s(e);
        }
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = function (e) {
        if (!e.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var t = !1,
              n = {
            _renderers: {},
            helpers: {},
            checkDCE: function checkDCE(e) {
              try {
                Function.prototype.toString.call(e).indexOf("^_^") > -1 && (t = !0, setTimeout(function () {
                  throw new Error("React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://fb.me/react-perf-use-the-production-build");
                }));
              } catch (e) {}
            },
            inject: function inject(e) {
              var r = Math.random().toString(16).slice(2);
              n._renderers[r] = e;
              var o = t ? "deadcode" : function (e) {
                try {
                  if ("string" == typeof e.version) return e.bundleType > 0 ? "development" : "production";
                  var t = Function.prototype.toString;

                  if (e.Mount && e.Mount._renderNewRootComponent) {
                    var n = t.call(e.Mount._renderNewRootComponent);
                    return 0 !== n.indexOf("function") ? "production" : -1 !== n.indexOf("storedMeasure") ? "development" : -1 !== n.indexOf("should be a pure function") ? -1 !== n.indexOf("NODE_ENV") ? "development" : -1 !== n.indexOf("development") ? "development" : -1 !== n.indexOf("true") ? "development" : -1 !== n.indexOf("nextElement") || -1 !== n.indexOf("nextComponent") ? "unminified" : "development" : -1 !== n.indexOf("nextElement") || -1 !== n.indexOf("nextComponent") ? "unminified" : "outdated";
                  }
                } catch (e) {}

                return "production";
              }(e);
              return n.emit("renderer", {
                id: r,
                renderer: e,
                reactBuildType: o
              }), r;
            },
            _listeners: {},
            sub: function sub(e, t) {
              return n.on(e, t), function () {
                return n.off(e, t);
              };
            },
            on: function on(e, t) {
              n._listeners[e] || (n._listeners[e] = []), n._listeners[e].push(t);
            },
            off: function off(e, t) {
              if (n._listeners[e]) {
                var r = n._listeners[e].indexOf(t);

                -1 !== r && n._listeners[e].splice(r, 1), n._listeners[e].length || (n._listeners[e] = null);
              }
            },
            emit: function emit(e, t) {
              n._listeners[e] && n._listeners[e].map(function (e) {
                return e(t);
              });
            },
            supportsFiber: !0,
            _fiberRoots: {},
            getFiberRoots: function getFiberRoots(e) {
              var t = n._fiberRoots;
              return t[e] || (t[e] = new Set()), t[e];
            },
            onCommitFiberUnmount: function onCommitFiberUnmount(e, t) {
              n.helpers[e] && n.helpers[e].handleCommitFiberUnmount(t);
            },
            onCommitFiberRoot: function onCommitFiberRoot(e, t) {
              var r = n.getFiberRoots(e),
                  o = t.current,
                  i = r.has(t),
                  a = null == o.memoizedState || null == o.memoizedState.element;
              i || a ? i && a && r.delete(t) : r.add(t), n.helpers[e] && n.helpers[e].handleCommitFiberRoot(t);
            }
          };
          Object.defineProperty(e, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
            value: n
          });
        }
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(40);

      e.exports = function (e, t) {
        var n = [e.sub("renderer-attached", function (e) {
          var n = e.id,
              r = (e.renderer, e.helpers);
          t.setReactInternals(n, r), r.walkTree(t.onMounted.bind(t, n), t.addRoot.bind(t, n));
        }), e.sub("mount", function (e) {
          var n = e.renderer,
              r = e.internalInstance,
              o = e.data;
          return t.onMounted(n, r, o);
        }), e.sub("unmount", function (e) {
          e.renderer;
          var n = e.internalInstance;
          return t.onUnmounted(n);
        }), e.sub("update", function (e) {
          e.renderer;
          var n = e.internalInstance,
              r = e.data;
          return t.onUpdated(n, r);
        }), e.sub("root", function (e) {
          var n = e.renderer,
              r = e.internalInstance;
          return t.addRoot(n, r);
        }), e.sub("rootCommitted", function (e) {
          var n = e.renderer,
              r = e.internalInstance,
              o = e.data;
          return t.rootCommitted(n, r, o);
        }), e.sub("updateProfileTimes", function (e) {
          e.renderer;
          var n = e.internalInstance,
              r = e.data;
          return t.onUpdatedProfileTimes(n, r);
        })];
        r(e) && (e.emit("react-devtools", t), e.reactDevtoolsAgent = t, t.on("shutdown", function () {
          n.forEach(function (e) {
            return e();
          }), e.reactDevtoolsAgent = null;
        }));
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(41);

      e.exports = function (e) {
        var t = window.React && window.React.__internals;

        for (var n in t && 0 === Object.keys(e._renderers).length && e.inject(t), e._renderers) {
          e.helpers[n] = r(e, n, e._renderers[n]), e.emit("renderer-attached", {
            id: n,
            renderer: e._renderers[n],
            helpers: e.helpers[n]
          });
        }

        e.on("renderer", function (t) {
          var n = t.id,
              o = t.renderer;
          e.helpers[n] = r(e, n, o), e.emit("renderer-attached", {
            id: n,
            renderer: o,
            helpers: e.helpers[n]
          });
        });
        return e.on("shutdown", function t() {
          for (var n in e.helpers) {
            e.helpers[n].cleanup();
          }

          e.off("shutdown", t);
        }), !0;
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(42),
          o = n(45),
          i = n(46);

      function a(e, t, n) {
        var i = n ? o(e) : r(e);
        i.children && Array.isArray(i.children) && i.children.forEach(function (e) {
          return a(e, t, n);
        }), t(e, i);
      }

      function s(e, t, n) {
        var r = e[t];
        return e[t] = function (e) {
          var t = r.apply(this, arguments);
          return n(t), t;
        }, r;
      }

      function u(e, t, n) {
        var r = e[t];
        return e[t] = function (e) {
          var t = r.apply(this, arguments);
          return n.apply(this, arguments), t;
        }, r;
      }

      function c(e, t) {
        var n = {};

        for (var r in t) {
          n[r] = u(e, r, t[r]);
        }

        return n;
      }

      function l(e, t) {
        for (var n in t) {
          e[n] = t[n];
        }
      }

      e.exports = function (e, t, n) {
        var u,
            f,
            p,
            d = new Map(),
            h = {},
            m = !n.Reconciler;
        return "function" == typeof n.findFiberByHostInstance ? i(e, t, n) : (n.Mount.findNodeHandle && n.Mount.nativeTagToRootNodeID ? (h.getNativeFromReactElement = function (e) {
          return n.Mount.findNodeHandle(e);
        }, h.getReactElementFromNative = function (e) {
          var t = n.Mount.nativeTagToRootNodeID(e);
          return d.get(t);
        }) : n.ComponentTree ? (h.getNativeFromReactElement = function (e) {
          return n.ComponentTree.getNodeFromInstance(e);
        }, h.getReactElementFromNative = function (e) {
          return n.ComponentTree.getClosestInstanceFromNode(e);
        }) : n.Mount.getID && n.Mount.getNode ? (h.getNativeFromReactElement = function (e) {
          try {
            return n.Mount.getNode(e._rootNodeID);
          } catch (e) {
            return;
          }
        }, h.getReactElementFromNative = function (e) {
          for (var t = n.Mount.getID(e); e && e.parentNode && !t;) {
            e = e.parentNode, t = n.Mount.getID(e);
          }

          return d.get(t);
        }) : console.warn("Unknown react version (does not have getID), probably an unshimmed React Native"), n.Mount._renderNewRootComponent ? p = s(n.Mount, "_renderNewRootComponent", function (n) {
          e.emit("root", {
            renderer: t,
            internalInstance: n
          });
        }) : n.Mount.renderComponent && (f = s(n.Mount, "renderComponent", function (n) {
          e.emit("root", {
            renderer: t,
            internalInstance: n._reactInternalInstance
          });
        })), n.Component ? (console.error("You are using a version of React with limited support in this version of the devtools.\nPlease upgrade to use at least 0.13, or you can downgrade to use the old version of the devtools:\ninstructions here https://github.com/facebook/react-devtools/tree/devtools-next#how-do-i-use-this-for-react--013"), u = c(n.Component.Mixin, {
          mountComponent: function mountComponent() {
            var n = this;
            d.set(this._rootNodeID, this), setTimeout(function () {
              e.emit("mount", {
                internalInstance: n,
                data: o(n),
                renderer: t
              });
            }, 0);
          },
          updateComponent: function updateComponent() {
            var n = this;
            setTimeout(function () {
              e.emit("update", {
                internalInstance: n,
                data: o(n),
                renderer: t
              });
            }, 0);
          },
          unmountComponent: function unmountComponent() {
            e.emit("unmount", {
              internalInstance: this,
              renderer: t
            }), d.delete(this._rootNodeID);
          }
        })) : n.Reconciler && (u = c(n.Reconciler, {
          mountComponent: function mountComponent(n, o, i, a) {
            var s = r(n);
            d.set(n._rootNodeID, n), e.emit("mount", {
              internalInstance: n,
              data: s,
              renderer: t
            });
          },
          performUpdateIfNecessary: function performUpdateIfNecessary(n, o, i, a) {
            e.emit("update", {
              internalInstance: n,
              data: r(n),
              renderer: t
            });
          },
          receiveComponent: function receiveComponent(n, o, i, a) {
            e.emit("update", {
              internalInstance: n,
              data: r(n),
              renderer: t
            });
          },
          unmountComponent: function unmountComponent(n) {
            e.emit("unmount", {
              internalInstance: n,
              renderer: t
            }), d.delete(n._rootNodeID);
          }
        })), h.walkTree = function (e, t) {
          !function (e, t, n, r) {
            for (var o in e) {
              a(e[o], t, r), n(e[o]);
            }
          }(n.Mount._instancesByReactRootID || n.Mount._instancesByContainerID, function (t, n) {
            d.set(t._rootNodeID, t), e(t, n);
          }, t, m);
        }, h.cleanup = function () {
          u && (n.Component ? l(n.Component.Mixin, u) : l(n.Reconciler, u)), p && (n.Mount._renderNewRootComponent = p), f && (n.Mount.renderComponent = f), u = null, p = null, f = null;
        }, h.renderer = null, h);
      };
    }, function (e, t, n) {
      "use strict";

      function r(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = n, e;
      }

      function o(e) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var i = n(2),
          a = n(5),
          s = n(43);

      function u(e, t, n) {
        var r = t.pop(),
            o = t.reduce(function (e, t) {
          return e ? e[t] : null;
        }, e);
        o && (o[r] = n);
      }

      function c(e) {
        var t = [];

        for (var n in e) {
          t.push(e[n]);
        }

        return t;
      }

      e.exports = function (e) {
        var t = null,
            n = null,
            l = null,
            f = null,
            p = null,
            d = null,
            h = null,
            m = null,
            y = null,
            v = null,
            g = null,
            b = null,
            _ = "Native";
        if ("object" !== o(e)) _ = "Text", g = e + "";else if (null === e._currentElement || !1 === e._currentElement) _ = "Empty";else if (e._renderedComponent) _ = "NativeWrapper", t = [e._renderedComponent], n = e._instance.props, l = e._instance.state, (f = e._instance.context) && 0 === Object.keys(f).length && (f = null);else if (e._renderedChildren) t = c(e._renderedChildren);else if (e._currentElement && e._currentElement.props) {
          var w = e._currentElement.props.children,
              S = [];
          s(w, "", function (e, t) {
            var n = o(t);
            "string" !== n && "number" !== n || S.push(t);
          }), t = S.length <= 1 ? S.length ? String(S[0]) : void 0 : S;
        }

        if (!n && e._currentElement && e._currentElement.props && (n = e._currentElement.props), null != e._currentElement && (h = e._currentElement.type, e._currentElement.key && (m = String(e._currentElement.key)), v = e._currentElement._source, y = e._currentElement.ref, "string" == typeof h ? (d = h, null != e._nativeNode && (b = e._nativeNode), null != e._hostNode && (b = e._hostNode)) : "function" == typeof h ? (_ = "Composite", d = a(h), e._renderedComponent && (e._currentElement.props === e._renderedComponent._currentElement || e._currentElement.type.isReactTopLevelWrapper) && (_ = "Wrapper"), null === d && (d = "No display name")) : "string" == typeof e._stringText ? (_ = "Text", g = e._stringText) : d = a(h)), e._instance) {
          var E = e._instance,
              O = E.forceUpdate || E.updater && E.updater.enqueueForceUpdate && function (e) {
            E.updater.enqueueForceUpdate(this, e, "forceUpdate");
          };

          p = {
            canUpdate: !0,
            setState: E.setState && E.setState.bind(E),
            setInProps: O && function (e, t, n, o) {
              var a = e._currentElement;
              e._currentElement = function (e) {
                for (var t = 1; t < arguments.length; t++) {
                  var n = null != arguments[t] ? arguments[t] : {},
                      o = Object.keys(n);
                  "function" == typeof Object.getOwnPropertySymbols && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function (e) {
                    return Object.getOwnPropertyDescriptor(n, e).enumerable;
                  }))), o.forEach(function (t) {
                    r(e, t, n[t]);
                  });
                }

                return e;
              }({}, a, {
                props: i(a.props, n, o)
              }), t.call(e._instance);
            }.bind(null, e, O),
            setInState: E.forceUpdate && function (e, t, n) {
              u(e.state, t, n), e.forceUpdate();
            }.bind(null, E),
            setInContext: O && function (e, t, n, r) {
              u(e.context, n, r), t.call(e);
            }.bind(null, E, O)
          }, "function" == typeof h && (b = E), E._renderedChildren && (t = c(E._renderedChildren));
        }

        return "function" == typeof e.setNativeProps && (p = {
          setNativeProps: function setNativeProps(t) {
            e.setNativeProps(t);
          }
        }), {
          nodeType: _,
          type: h,
          key: m,
          ref: y,
          source: v,
          name: d,
          props: n,
          state: l,
          context: f,
          children: t,
          text: g,
          updater: p,
          publicInstance: b
        };
      };
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var o = n(44),
          i = ".",
          a = ":",
          s = "@@iterator",
          u = "function" == typeof Symbol && Symbol.iterator,
          c = "function" == typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;

      function l(e, t) {
        return "object" === r(e) && null !== e && null != e.key ? (n = e.key, o = {
          "=": "=0",
          ":": "=2"
        }, "$" + ("" + n).replace(/[=:]/g, function (e) {
          return o[e];
        })) : t.toString(36);
        var n, o;
      }

      e.exports = function e(t, n, f, p) {
        var d,
            h = r(t);
        if ("undefined" !== h && "boolean" !== h || (t = null), null === t || "string" === h || "number" === h || "object" === h && t.$$typeof === c) return f(p, t, "" === n ? i + l(t, 0) : n), 1;
        var m = 0,
            y = "" === n ? i : n + a;
        if (Array.isArray(t)) for (var v = 0; v < t.length; v++) {
          m += e(d = t[v], y + l(d, v), f, p);
        } else {
          var g = u && t[u] || t[s];
          if ("function" == typeof g) for (var b, _ = g.call(t), w = 0; !(b = _.next()).done;) {
            m += e(d = b.value, y + l(d, w++), f, p);
          } else if ("object" === h) {
            var S = "" + t;
            o(!1, "The React Devtools cannot render an object as a child. (found: %s).%s", "[object Object]" === S ? "object with keys {" + Object.keys(t).join(", ") + "}" : S, " If you meant to render a collection of children, use an array instead.");
          }
        }
        return m;
      };
    }, function (e, t, n) {
      "use strict";

      e.exports = function (e, t, n, r, o, i, a, s) {
        if (!e) {
          var u;
          if (void 0 === t) u = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
            var c = [n, r, o, i, a, s],
                l = 0;
            (u = new Error(t.replace(/%s/g, function () {
              return c[l++];
            }))).name = "Invariant Violation";
          }
          throw u.framesToPop = 1, u;
        }
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(2);

      function o(e, t, n) {
        var r = t.pop(),
            o = t.reduce(function (e, t) {
          return e ? e[t] : null;
        }, e);
        o && (o[r] = n);
      }

      e.exports = function (e) {
        var t = null,
            n = e.props,
            i = e.state,
            a = e.context,
            s = null,
            u = null,
            c = null,
            l = null,
            f = null,
            p = null,
            d = null,
            h = "Native";
        return e._renderedComponent ? (h = "Wrapper", t = [e._renderedComponent], a && 0 === Object.keys(a).length && (a = null)) : e._renderedChildren ? (u = e.constructor.displayName, t = function (e) {
          var t = [];

          for (var n in e) {
            t.push(e[n]);
          }

          return t;
        }(e._renderedChildren)) : "string" == typeof n.children && (u = e.constructor.displayName, t = n.children, h = "Native"), !n && e._currentElement && e._currentElement.props && (n = e._currentElement.props), e._currentElement && (c = e._currentElement.type, e._currentElement.key && (l = String(e._currentElement.key)), f = e._currentElement.ref, "string" == typeof c ? u = c : (h = "Composite", (u = c.displayName) || (u = "No display name"))), u || (u = e.constructor.displayName || "No display name", h = "Composite"), "string" == typeof n && (h = "Text", p = n, n = null, u = null), e.forceUpdate && (s = {
          canUpdate: !0,
          setState: e.setState.bind(e),
          setInProps: e.forceUpdate && function (e, t, n) {
            e.props = r(e.props, t, n), e.forceUpdate();
          }.bind(null, e),
          setInState: e.forceUpdate && function (e, t, n) {
            o(e.state, t, n), e.forceUpdate();
          }.bind(null, e),
          setInContext: e.forceUpdate && function (e, t, n) {
            o(e.context, t, n), e.forceUpdate();
          }.bind(null, e)
        }, d = e), {
          nodeType: h,
          type: c,
          key: l,
          ref: f,
          source: null,
          name: u,
          props: n,
          state: i,
          context: a,
          children: t,
          text: p,
          updater: s,
          publicInstance: d
        };
      };
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var o = n(47),
          i = n(2),
          a = n(5);

      e.exports = function (e, t, n) {
        var s,
            u = n.overrideProps,
            c = (s = n.version, {
          ReactTypeOfWork: o.gte(s, "16.6.0-beta.0") ? {
            ClassComponent: 1,
            ContextConsumer: 9,
            ContextProvider: 10,
            CoroutineComponent: -1,
            CoroutineHandlerPhase: -1,
            ForwardRef: 11,
            Fragment: 7,
            FunctionComponent: 0,
            HostComponent: 5,
            HostPortal: 4,
            HostRoot: 3,
            HostText: 6,
            IncompleteClassComponent: 17,
            IndeterminateComponent: 2,
            LazyComponent: 16,
            MemoComponent: 14,
            Mode: 8,
            Profiler: 12,
            SimpleMemoComponent: 15,
            SuspenseComponent: 13,
            YieldComponent: -1
          } : o.gte(s, "16.4.3-alpha") ? {
            ClassComponent: 2,
            ContextConsumer: 11,
            ContextProvider: 12,
            CoroutineComponent: -1,
            CoroutineHandlerPhase: -1,
            ForwardRef: 13,
            Fragment: 9,
            FunctionComponent: 0,
            HostComponent: 7,
            HostPortal: 6,
            HostRoot: 5,
            HostText: 8,
            IncompleteClassComponent: -1,
            IndeterminateComponent: 4,
            LazyComponent: -1,
            MemoComponent: -1,
            Mode: 10,
            Profiler: 15,
            SimpleMemoComponent: -1,
            SuspenseComponent: 16,
            YieldComponent: -1
          } : {
            ClassComponent: 2,
            ContextConsumer: 12,
            ContextProvider: 13,
            CoroutineComponent: 7,
            CoroutineHandlerPhase: 8,
            ForwardRef: 14,
            Fragment: 10,
            FunctionComponent: 1,
            HostComponent: 5,
            HostPortal: 4,
            HostRoot: 3,
            HostText: 6,
            IncompleteClassComponent: -1,
            IndeterminateComponent: 0,
            LazyComponent: -1,
            MemoComponent: -1,
            Mode: 11,
            Profiler: 15,
            SimpleMemoComponent: -1,
            SuspenseComponent: 16,
            YieldComponent: 9
          },
          ReactSymbols: {
            CONCURRENT_MODE_NUMBER: 60111,
            CONCURRENT_MODE_SYMBOL_STRING: "Symbol(react.concurrent_mode)",
            DEPRECATED_ASYNC_MODE_SYMBOL_STRING: "Symbol(react.async_mode)",
            CONTEXT_CONSUMER_NUMBER: 60110,
            CONTEXT_CONSUMER_SYMBOL_STRING: "Symbol(react.context)",
            CONTEXT_PROVIDER_NUMBER: 60109,
            CONTEXT_PROVIDER_SYMBOL_STRING: "Symbol(react.provider)",
            FORWARD_REF_NUMBER: 60112,
            FORWARD_REF_SYMBOL_STRING: "Symbol(react.forward_ref)",
            MEMO_NUMBER: 60115,
            MEMO_SYMBOL_STRING: "Symbol(react.memo)",
            PROFILER_NUMBER: 60114,
            PROFILER_SYMBOL_STRING: "Symbol(react.profiler)",
            STRICT_MODE_NUMBER: 60108,
            STRICT_MODE_SYMBOL_STRING: "Symbol(react.strict_mode)",
            SUSPENSE_NUMBER: 60113,
            SUSPENSE_SYMBOL_STRING: "Symbol(react.suspense)",
            DEPRECATED_PLACEHOLDER_SYMBOL_STRING: "Symbol(react.placeholder)"
          },
          ReactTypeOfSideEffect: {
            PerformedWork: 1
          }
        }),
            l = c.ReactTypeOfWork,
            f = c.ReactSymbols,
            p = c.ReactTypeOfSideEffect.PerformedWork,
            d = l.FunctionComponent,
            h = l.ClassComponent,
            m = l.ContextConsumer,
            y = l.Fragment,
            v = l.ForwardRef,
            g = l.HostRoot,
            b = l.HostPortal,
            _ = l.HostComponent,
            w = l.HostText,
            S = l.IncompleteClassComponent,
            E = l.IndeterminateComponent,
            O = l.MemoComponent,
            x = l.SimpleMemoComponent,
            C = f.CONCURRENT_MODE_NUMBER,
            I = f.CONCURRENT_MODE_SYMBOL_STRING,
            N = f.DEPRECATED_ASYNC_MODE_SYMBOL_STRING,
            T = f.CONTEXT_CONSUMER_NUMBER,
            k = f.CONTEXT_CONSUMER_SYMBOL_STRING,
            R = f.CONTEXT_PROVIDER_NUMBER,
            j = f.CONTEXT_PROVIDER_SYMBOL_STRING,
            M = f.PROFILER_NUMBER,
            D = f.PROFILER_SYMBOL_STRING,
            P = f.STRICT_MODE_NUMBER,
            L = f.STRICT_MODE_SYMBOL_STRING,
            A = f.SUSPENSE_NUMBER,
            B = f.SUSPENSE_SYMBOL_STRING,
            F = f.DEPRECATED_PLACEHOLDER_SYMBOL_STRING;

        function U(e) {
          var t = e.elementType,
              n = e.type,
              o = e.key,
              s = e.ref,
              c = e.tag,
              l = e._debugSource,
              f = null,
              p = null,
              m = null,
              U = null,
              H = null,
              $ = null,
              G = null,
              W = null,
              q = null,
              Y = null,
              K = null,
              X = null,
              J = null,
              Z = null,
              Q = !1,
              ee = (c === d || c === x || c === v) && !!e.memoizedState,
              te = n;

          switch ("object" === r(n) && null !== n && "function" == typeof n.then && (te = n._reactResult), "function" == typeof u && ($ = {
            canUpdate: !0,
            setState: null,
            setInProps: u.bind(null, e),
            setInState: null,
            setInContext: null
          }), c) {
            case h:
            case d:
            case S:
            case E:
              G = "Composite", W = a(te), f = e.stateNode, p = e.memoizedProps, m = e.memoizedState, null != f && (H = f.context) && 0 === Object.keys(H).length && (H = null);
              var ne = f;
              ne && ($ = {
                canUpdate: !0,
                setState: ne.setState && ne.setState.bind(ne),
                setInProps: ne.forceUpdate && function (e, t, n) {
                  var r = e.stateNode;
                  e.pendingProps = i(r.props, t, n), e.alternate && (e.alternate.pendingProps = e.pendingProps), e.stateNode.forceUpdate();
                }.bind(null, e),
                setInState: ne.forceUpdate && function (e, t, n) {
                  z(e.state, t, n), e.forceUpdate();
                }.bind(null, ne),
                setInContext: ne.forceUpdate && function (e, t, n) {
                  z(e.context, t, n), e.forceUpdate();
                }.bind(null, ne)
              }), U = [];
              break;

            case v:
              var re = a(te.render, "");
              G = "Special", W = te.displayName || ("" !== re ? "ForwardRef(".concat(re, ")") : "ForwardRef"), p = e.memoizedProps, m = e.memoizedState, U = [];
              break;

            case g:
              G = "Wrapper", U = [], K = e.stateNode.memoizedInteractions;
              break;

            case b:
              G = "Portal", W = "ReactPortal", p = {
                target: e.stateNode.containerInfo
              }, U = [];
              break;

            case _:
              G = "Native", W = (W = e.type).replace("topsecret-", ""), f = e.stateNode, U = "string" == typeof (p = e.memoizedProps).children || "number" == typeof p.children ? p.children.toString() : [], "function" == typeof e.stateNode.setNativeProps && ($ = {
                setNativeProps: function setNativeProps(t) {
                  e.stateNode.setNativeProps(t);
                }
              });
              break;

            case w:
              G = "Text", f = e.stateNode, q = e.memoizedProps;
              break;

            case y:
              G = "Wrapper", U = [];
              break;

            case O:
            case x:
              if (G = "Composite", t.displayName) W = t.displayName;else {
                var oe = n.displayName || n.name;
                W = oe ? "Memo(".concat(oe, ")") : "Memo";
              }
              p = e.memoizedProps, m = e.memoizedState, U = [];
              break;

            default:
              var ie = "object" === r(n) && null !== n ? n.$$typeof : n;

              switch ("symbol" === r(ie) ? ie.toString() : ie) {
                case C:
                case I:
                case N:
                  G = "Special", W = "ConcurrentMode", U = [];
                  break;

                case R:
                case j:
                  G = "Special", p = e.memoizedProps, Y = e.type._context || e.type.context, W = "".concat(Y.displayName || "Context", ".Provider"), U = [];
                  break;

                case T:
                case k:
                  G = "Special", p = e.memoizedProps, Y = e.type._context || e.type, W = "".concat(Y.displayName || "Context", ".Consumer"), U = [];
                  break;

                case P:
                case L:
                  G = "Special", W = "StrictMode", U = [];
                  break;

                case A:
                case B:
                case F:
                  G = "Special", W = "Suspense", p = e.memoizedProps, U = [], Q = null !== e.memoizedState;
                  break;

                case M:
                case D:
                  G = "Special", p = e.memoizedProps, W = "Profiler(".concat(e.memoizedProps.id, ")"), U = [];
                  break;

                default:
                  G = "Native", p = e.memoizedProps, W = "TODO_NOT_IMPLEMENTED_YET", U = [];
              }

          }

          if (null !== p && void 0 !== r(e.elementType) && e.type !== e.elementType && (p = function (e, t) {
            if (e && e.defaultProps) {
              var n = _extends({}, t),
                  r = e.defaultProps;

              for (var o in r) {
                void 0 === n[o] && (n[o] = r[o]);
              }

              return n;
            }

            return t;
          }(e.type, p)), Array.isArray(U)) if (Q) {
            var ae = e.child,
                se = ae.child,
                ue = ae.sibling.child;
            U.push(se), U.push(ue);
          } else for (var ce = e.child; ce;) {
            U.push(V(ce)), ce = ce.sibling;
          }
          return void 0 !== e.actualDuration && (X = e.actualDuration, J = e.actualStartTime, Z = e.treeBaseDuration), null === f && (f = {
            props: p,
            state: m,
            type: n
          }), {
            nodeType: G,
            type: n,
            key: o,
            ref: s,
            source: l,
            name: W,
            props: p,
            state: m,
            context: H,
            children: U,
            text: q,
            updater: $,
            publicInstance: f,
            memoizedInteractions: K,
            actualDuration: X,
            actualStartTime: J,
            treeBaseDuration: Z,
            containsHooks: ee
          };
        }

        function z(e, t, n) {
          var r = t.pop(),
              o = t.reduce(function (e, t) {
            return e ? e[t] : null;
          }, e);
          o && (o[r] = n);
        }

        var H = new Set();

        function V(e) {
          if (H.has(e)) return e;
          var t = e.alternate;
          return null != t && H.has(t) ? t : (H.add(e), e);
        }

        var $ = [];

        function G() {
          var t = $;
          $ = [];

          for (var n = 0; n < t.length; n++) {
            var r = t[n];
            e.emit(r.type, r);
          }
        }

        function W(e) {
          $.push({
            internalInstance: V(e),
            data: U(e),
            renderer: t,
            type: "mount"
          }), e.tag === g && $.push({
            internalInstance: V(e),
            renderer: t,
            type: "root"
          });
        }

        function q(e, n) {
          var r,
              o,
              i = U(e);
          if (!n && !function (e, t) {
            switch (t.tag) {
              case h:
              case d:
              case m:
              case O:
              case x:
                return (t.effectTag & p) === p;

              default:
                return e.memoizedProps !== t.memoizedProps || e.memoizedState !== t.memoizedState || e.ref !== t.ref;
            }
          }(e.alternate, e)) return r = e.alternate, o = e, void (void 0 === r.actualDuration || r.actualDuration === o.actualDuration && r.actualStartTime === o.actualStartTime && r.treeBaseDuration === o.treeBaseDuration || $.push({
            internalInstance: V(e),
            data: i,
            renderer: t,
            type: "updateProfileTimes"
          }));
          $.push({
            internalInstance: V(e),
            data: i,
            renderer: t,
            type: "update"
          });
        }

        function Y(e) {
          var n = e.tag === g,
              r = V(e),
              o = {
            internalInstance: r,
            renderer: t,
            type: "unmount"
          };
          n ? $.push(o) : $.unshift(o), H.delete(r);
        }

        function K(e) {
          $.push({
            internalInstance: V(e),
            data: U(e),
            renderer: t,
            type: "rootCommitted"
          });
        }

        function X(e) {
          var t = e;

          e: for (;;) {
            if (t.child) t.child.return = t, t = t.child;else {
              if (W(t), t == e) return;

              if (!t.sibling) {
                for (; t.return;) {
                  if (W(t = t.return), t == e) return;

                  if (t.sibling) {
                    t.sibling.return = t.return, t = t.sibling;
                    continue e;
                  }
                }

                return;
              }

              t.sibling.return = t.return, t = t.sibling;
            }
          }
        }

        return {
          getNativeFromReactElement: function getNativeFromReactElement(e) {
            try {
              var t = e;
              return n.findHostInstanceByFiber(t);
            } catch (e) {
              return null;
            }
          },
          getReactElementFromNative: function getReactElementFromNative(e) {
            var t = n.findFiberByHostInstance(e);
            return null != t ? V(t) : null;
          },
          handleCommitFiberRoot: function handleCommitFiberRoot(e) {
            var t = e.current,
                n = t.alternate;

            if (n) {
              var r = null != n.memoizedState && null != n.memoizedState.element,
                  o = null != t.memoizedState && null != t.memoizedState.element;
              !r && o ? X(t) : r && o ? function e(t, n) {
                if (t.tag === l.SuspenseComponent && null !== t.memoizedState) {
                  var r = t.child.sibling.child;
                  r.alternate ? e(r, r.alternate) : X(r), q(t, !1);
                } else {
                  var o = !1;

                  if (t.child !== n.child) {
                    for (var i = t.child, a = n.child; i;) {
                      if (i.alternate) {
                        var s = i.alternate;
                        e(i, s), o || s === a || (o = !0);
                      } else X(i), o || (o = !0);

                      i = i.sibling, o || null == a || (a = a.sibling);
                    }

                    o || null == a || (o = !0);
                  }

                  q(t, o);
                }
              }(t, n) : r && !o && Y(t);
            } else X(t);

            K(t), G();
          },
          handleCommitFiberUnmount: function handleCommitFiberUnmount(e) {
            Y(e);
          },
          cleanup: function cleanup() {},
          walkTree: function walkTree() {
            e.getFiberRoots(t).forEach(function (e) {
              X(e.current), K(e.current);
            }), G();
          },
          renderer: n
        };
      };
    }, function (e, t, n) {
      (function (n) {
        function r(e) {
          return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e;
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          })(e);
        }

        var o;
        t = e.exports = K, o = "object" === (void 0 === n ? "undefined" : r(n)) && n.env && n.env.NODE_DEBUG && /\bsemver\b/i.test(n.env.NODE_DEBUG) ? function () {
          var e = Array.prototype.slice.call(arguments, 0);
          e.unshift("SEMVER"), console.log.apply(console, e);
        } : function () {}, t.SEMVER_SPEC_VERSION = "2.0.0";
        var i = 256,
            a = Number.MAX_SAFE_INTEGER || 9007199254740991,
            s = t.re = [],
            u = t.src = [],
            c = 0,
            l = c++;
        u[l] = "0|[1-9]\\d*";
        var f = c++;
        u[f] = "[0-9]+";
        var p = c++;
        u[p] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
        var d = c++;
        u[d] = "(" + u[l] + ")\\.(" + u[l] + ")\\.(" + u[l] + ")";
        var h = c++;
        u[h] = "(" + u[f] + ")\\.(" + u[f] + ")\\.(" + u[f] + ")";
        var m = c++;
        u[m] = "(?:" + u[l] + "|" + u[p] + ")";
        var y = c++;
        u[y] = "(?:" + u[f] + "|" + u[p] + ")";
        var v = c++;
        u[v] = "(?:-(" + u[m] + "(?:\\." + u[m] + ")*))";
        var g = c++;
        u[g] = "(?:-?(" + u[y] + "(?:\\." + u[y] + ")*))";
        var b = c++;
        u[b] = "[0-9A-Za-z-]+";

        var _ = c++;

        u[_] = "(?:\\+(" + u[b] + "(?:\\." + u[b] + ")*))";
        var w = c++,
            S = "v?" + u[d] + u[v] + "?" + u[_] + "?";
        u[w] = "^" + S + "$";
        var E = "[v=\\s]*" + u[h] + u[g] + "?" + u[_] + "?",
            O = c++;
        u[O] = "^" + E + "$";
        var x = c++;
        u[x] = "((?:<|>)?=?)";
        var C = c++;
        u[C] = u[f] + "|x|X|\\*";
        var I = c++;
        u[I] = u[l] + "|x|X|\\*";
        var N = c++;
        u[N] = "[v=\\s]*(" + u[I] + ")(?:\\.(" + u[I] + ")(?:\\.(" + u[I] + ")(?:" + u[v] + ")?" + u[_] + "?)?)?";
        var T = c++;
        u[T] = "[v=\\s]*(" + u[C] + ")(?:\\.(" + u[C] + ")(?:\\.(" + u[C] + ")(?:" + u[g] + ")?" + u[_] + "?)?)?";
        var k = c++;
        u[k] = "^" + u[x] + "\\s*" + u[N] + "$";
        var R = c++;
        u[R] = "^" + u[x] + "\\s*" + u[T] + "$";
        var j = c++;
        u[j] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
        var M = c++;
        u[M] = "(?:~>?)";
        var D = c++;
        u[D] = "(\\s*)" + u[M] + "\\s+", s[D] = new RegExp(u[D], "g");
        var P = c++;
        u[P] = "^" + u[M] + u[N] + "$";
        var L = c++;
        u[L] = "^" + u[M] + u[T] + "$";
        var A = c++;
        u[A] = "(?:\\^)";
        var B = c++;
        u[B] = "(\\s*)" + u[A] + "\\s+", s[B] = new RegExp(u[B], "g");
        var F = c++;
        u[F] = "^" + u[A] + u[N] + "$";
        var U = c++;
        u[U] = "^" + u[A] + u[T] + "$";
        var z = c++;
        u[z] = "^" + u[x] + "\\s*(" + E + ")$|^$";
        var H = c++;
        u[H] = "^" + u[x] + "\\s*(" + S + ")$|^$";
        var V = c++;
        u[V] = "(\\s*)" + u[x] + "\\s*(" + E + "|" + u[N] + ")", s[V] = new RegExp(u[V], "g");
        var $ = c++;
        u[$] = "^\\s*(" + u[N] + ")\\s+-\\s+(" + u[N] + ")\\s*$";
        var G = c++;
        u[G] = "^\\s*(" + u[T] + ")\\s+-\\s+(" + u[T] + ")\\s*$";
        var W = c++;
        u[W] = "(<|>)?=?\\s*\\*";

        for (var q = 0; q < 35; q++) {
          o(q, u[q]), s[q] || (s[q] = new RegExp(u[q]));
        }

        function Y(e, t) {
          if (e instanceof K) return e;
          if ("string" != typeof e) return null;
          if (e.length > i) return null;
          if (!(t ? s[O] : s[w]).test(e)) return null;

          try {
            return new K(e, t);
          } catch (e) {
            return null;
          }
        }

        function K(e, t) {
          if (e instanceof K) {
            if (e.loose === t) return e;
            e = e.version;
          } else if ("string" != typeof e) throw new TypeError("Invalid Version: " + e);

          if (e.length > i) throw new TypeError("version is longer than " + i + " characters");
          if (!(this instanceof K)) return new K(e, t);
          o("SemVer", e, t), this.loose = t;
          var n = e.trim().match(t ? s[O] : s[w]);
          if (!n) throw new TypeError("Invalid Version: " + e);
          if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > a || this.major < 0) throw new TypeError("Invalid major version");
          if (this.minor > a || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > a || this.patch < 0) throw new TypeError("Invalid patch version");
          n[4] ? this.prerelease = n[4].split(".").map(function (e) {
            if (/^[0-9]+$/.test(e)) {
              var t = +e;
              if (t >= 0 && t < a) return t;
            }

            return e;
          }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
        }

        t.parse = Y, t.valid = function (e, t) {
          var n = Y(e, t);
          return n ? n.version : null;
        }, t.clean = function (e, t) {
          var n = Y(e.trim().replace(/^[=v]+/, ""), t);
          return n ? n.version : null;
        }, t.SemVer = K, K.prototype.format = function () {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, K.prototype.toString = function () {
          return this.version;
        }, K.prototype.compare = function (e) {
          return o("SemVer.compare", this.version, this.loose, e), e instanceof K || (e = new K(e, this.loose)), this.compareMain(e) || this.comparePre(e);
        }, K.prototype.compareMain = function (e) {
          return e instanceof K || (e = new K(e, this.loose)), J(this.major, e.major) || J(this.minor, e.minor) || J(this.patch, e.patch);
        }, K.prototype.comparePre = function (e) {
          if (e instanceof K || (e = new K(e, this.loose)), this.prerelease.length && !e.prerelease.length) return -1;
          if (!this.prerelease.length && e.prerelease.length) return 1;
          if (!this.prerelease.length && !e.prerelease.length) return 0;
          var t = 0;

          do {
            var n = this.prerelease[t],
                r = e.prerelease[t];
            if (o("prerelease compare", t, n, r), void 0 === n && void 0 === r) return 0;
            if (void 0 === r) return 1;
            if (void 0 === n) return -1;
            if (n !== r) return J(n, r);
          } while (++t);
        }, K.prototype.inc = function (e, t) {
          switch (e) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
              break;

            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
              break;

            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
              break;

            case "prerelease":
              0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
              break;

            case "major":
              0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;

            case "minor":
              0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
              break;

            case "patch":
              0 === this.prerelease.length && this.patch++, this.prerelease = [];
              break;

            case "pre":
              if (0 === this.prerelease.length) this.prerelease = [0];else {
                for (var n = this.prerelease.length; --n >= 0;) {
                  "number" == typeof this.prerelease[n] && (this.prerelease[n]++, n = -2);
                }

                -1 === n && this.prerelease.push(0);
              }
              t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
              break;

            default:
              throw new Error("invalid increment argument: " + e);
          }

          return this.format(), this.raw = this.version, this;
        }, t.inc = function (e, t, n, r) {
          "string" == typeof n && (r = n, n = void 0);

          try {
            return new K(e, n).inc(t, r).version;
          } catch (e) {
            return null;
          }
        }, t.diff = function (e, t) {
          if (te(e, t)) return null;
          var n = Y(e),
              r = Y(t);

          if (n.prerelease.length || r.prerelease.length) {
            for (var o in n) {
              if (("major" === o || "minor" === o || "patch" === o) && n[o] !== r[o]) return "pre" + o;
            }

            return "prerelease";
          }

          for (var o in n) {
            if (("major" === o || "minor" === o || "patch" === o) && n[o] !== r[o]) return o;
          }
        }, t.compareIdentifiers = J;
        var X = /^[0-9]+$/;

        function J(e, t) {
          var n = X.test(e),
              r = X.test(t);
          return n && r && (e = +e, t = +t), n && !r ? -1 : r && !n ? 1 : e < t ? -1 : e > t ? 1 : 0;
        }

        function Z(e, t, n) {
          return new K(e, n).compare(new K(t, n));
        }

        function Q(e, t, n) {
          return Z(e, t, n) > 0;
        }

        function ee(e, t, n) {
          return Z(e, t, n) < 0;
        }

        function te(e, t, n) {
          return 0 === Z(e, t, n);
        }

        function ne(e, t, n) {
          return 0 !== Z(e, t, n);
        }

        function re(e, t, n) {
          return Z(e, t, n) >= 0;
        }

        function oe(e, t, n) {
          return Z(e, t, n) <= 0;
        }

        function ie(e, t, n, o) {
          var i;

          switch (t) {
            case "===":
              "object" === r(e) && (e = e.version), "object" === r(n) && (n = n.version), i = e === n;
              break;

            case "!==":
              "object" === r(e) && (e = e.version), "object" === r(n) && (n = n.version), i = e !== n;
              break;

            case "":
            case "=":
            case "==":
              i = te(e, n, o);
              break;

            case "!=":
              i = ne(e, n, o);
              break;

            case ">":
              i = Q(e, n, o);
              break;

            case ">=":
              i = re(e, n, o);
              break;

            case "<":
              i = ee(e, n, o);
              break;

            case "<=":
              i = oe(e, n, o);
              break;

            default:
              throw new TypeError("Invalid operator: " + t);
          }

          return i;
        }

        function ae(e, t) {
          if (e instanceof ae) {
            if (e.loose === t) return e;
            e = e.value;
          }

          if (!(this instanceof ae)) return new ae(e, t);
          o("comparator", e, t), this.loose = t, this.parse(e), this.semver === se ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
        }

        t.rcompareIdentifiers = function (e, t) {
          return J(t, e);
        }, t.major = function (e, t) {
          return new K(e, t).major;
        }, t.minor = function (e, t) {
          return new K(e, t).minor;
        }, t.patch = function (e, t) {
          return new K(e, t).patch;
        }, t.compare = Z, t.compareLoose = function (e, t) {
          return Z(e, t, !0);
        }, t.rcompare = function (e, t, n) {
          return Z(t, e, n);
        }, t.sort = function (e, n) {
          return e.sort(function (e, r) {
            return t.compare(e, r, n);
          });
        }, t.rsort = function (e, n) {
          return e.sort(function (e, r) {
            return t.rcompare(e, r, n);
          });
        }, t.gt = Q, t.lt = ee, t.eq = te, t.neq = ne, t.gte = re, t.lte = oe, t.cmp = ie, t.Comparator = ae;
        var se = {};

        function ue(e, t) {
          if (e instanceof ue) return e.loose === t ? e : new ue(e.raw, t);
          if (e instanceof ae) return new ue(e.value, t);
          if (!(this instanceof ue)) return new ue(e, t);
          if (this.loose = t, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map(function (e) {
            return this.parseRange(e.trim());
          }, this).filter(function (e) {
            return e.length;
          }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e);
          this.format();
        }

        function ce(e) {
          return !e || "x" === e.toLowerCase() || "*" === e;
        }

        function le(e, t, n, r, o, i, a, s, u, c, l, f, p) {
          return ((t = ce(n) ? "" : ce(r) ? ">=" + n + ".0.0" : ce(o) ? ">=" + n + "." + r + ".0" : ">=" + t) + " " + (s = ce(u) ? "" : ce(c) ? "<" + (+u + 1) + ".0.0" : ce(l) ? "<" + u + "." + (+c + 1) + ".0" : f ? "<=" + u + "." + c + "." + l + "-" + f : "<=" + s)).trim();
        }

        function fe(e, t) {
          for (var n = 0; n < e.length; n++) {
            if (!e[n].test(t)) return !1;
          }

          if (t.prerelease.length) {
            for (n = 0; n < e.length; n++) {
              if (o(e[n].semver), e[n].semver !== se && e[n].semver.prerelease.length > 0) {
                var r = e[n].semver;
                if (r.major === t.major && r.minor === t.minor && r.patch === t.patch) return !0;
              }
            }

            return !1;
          }

          return !0;
        }

        function pe(e, t, n) {
          try {
            t = new ue(t, n);
          } catch (e) {
            return !1;
          }

          return t.test(e);
        }

        function de(e, t, n, r) {
          var o, i, a, s, u;

          switch (e = new K(e, r), t = new ue(t, r), n) {
            case ">":
              o = Q, i = oe, a = ee, s = ">", u = ">=";
              break;

            case "<":
              o = ee, i = re, a = Q, s = "<", u = "<=";
              break;

            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }

          if (pe(e, t, r)) return !1;

          for (var c = 0; c < t.set.length; ++c) {
            var l = t.set[c],
                f = null,
                p = null;
            if (l.forEach(function (e) {
              e.semver === se && (e = new ae(">=0.0.0")), f = f || e, p = p || e, o(e.semver, f.semver, r) ? f = e : a(e.semver, p.semver, r) && (p = e);
            }), f.operator === s || f.operator === u) return !1;
            if ((!p.operator || p.operator === s) && i(e, p.semver)) return !1;
            if (p.operator === u && a(e, p.semver)) return !1;
          }

          return !0;
        }

        ae.prototype.parse = function (e) {
          var t = this.loose ? s[z] : s[H],
              n = e.match(t);
          if (!n) throw new TypeError("Invalid comparator: " + e);
          this.operator = n[1], "=" === this.operator && (this.operator = ""), n[2] ? this.semver = new K(n[2], this.loose) : this.semver = se;
        }, ae.prototype.toString = function () {
          return this.value;
        }, ae.prototype.test = function (e) {
          return o("Comparator.test", e, this.loose), this.semver === se || ("string" == typeof e && (e = new K(e, this.loose)), ie(e, this.operator, this.semver, this.loose));
        }, ae.prototype.intersects = function (e, t) {
          if (!(e instanceof ae)) throw new TypeError("a Comparator is required");
          var n;
          if ("" === this.operator) return n = new ue(e.value, t), pe(this.value, n, t);
          if ("" === e.operator) return n = new ue(this.value, t), pe(e.semver, n, t);
          var r = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e.operator && ">" !== e.operator),
              o = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e.operator && "<" !== e.operator),
              i = this.semver.version === e.semver.version,
              a = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e.operator && "<=" !== e.operator),
              s = ie(this.semver, "<", e.semver, t) && (">=" === this.operator || ">" === this.operator) && ("<=" === e.operator || "<" === e.operator),
              u = ie(this.semver, ">", e.semver, t) && ("<=" === this.operator || "<" === this.operator) && (">=" === e.operator || ">" === e.operator);
          return r || o || i && a || s || u;
        }, t.Range = ue, ue.prototype.format = function () {
          return this.range = this.set.map(function (e) {
            return e.join(" ").trim();
          }).join("||").trim(), this.range;
        }, ue.prototype.toString = function () {
          return this.range;
        }, ue.prototype.parseRange = function (e) {
          var t = this.loose;
          e = e.trim(), o("range", e, t);
          var n = t ? s[G] : s[$];
          e = e.replace(n, le), o("hyphen replace", e), e = e.replace(s[V], "$1$2$3"), o("comparator trim", e, s[V]), e = (e = (e = e.replace(s[D], "$1~")).replace(s[B], "$1^")).split(/\s+/).join(" ");
          var r = t ? s[z] : s[H],
              i = e.split(" ").map(function (e) {
            return function (e, t) {
              return o("comp", e), e = function (e, t) {
                return e.trim().split(/\s+/).map(function (e) {
                  return function (e, t) {
                    o("caret", e, t);
                    var n = t ? s[U] : s[F];
                    return e.replace(n, function (t, n, r, i, a) {
                      var s;
                      return o("caret", e, t, n, r, i, a), ce(n) ? s = "" : ce(r) ? s = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : ce(i) ? s = "0" === n ? ">=" + n + "." + r + ".0 <" + n + "." + (+r + 1) + ".0" : ">=" + n + "." + r + ".0 <" + (+n + 1) + ".0.0" : a ? (o("replaceCaret pr", a), "-" !== a.charAt(0) && (a = "-" + a), s = "0" === n ? "0" === r ? ">=" + n + "." + r + "." + i + a + " <" + n + "." + r + "." + (+i + 1) : ">=" + n + "." + r + "." + i + a + " <" + n + "." + (+r + 1) + ".0" : ">=" + n + "." + r + "." + i + a + " <" + (+n + 1) + ".0.0") : (o("no pr"), s = "0" === n ? "0" === r ? ">=" + n + "." + r + "." + i + " <" + n + "." + r + "." + (+i + 1) : ">=" + n + "." + r + "." + i + " <" + n + "." + (+r + 1) + ".0" : ">=" + n + "." + r + "." + i + " <" + (+n + 1) + ".0.0"), o("caret return", s), s;
                    });
                  }(e, t);
                }).join(" ");
              }(e, t), o("caret", e), e = function (e, t) {
                return e.trim().split(/\s+/).map(function (e) {
                  return function (e, t) {
                    var n = t ? s[L] : s[P];
                    return e.replace(n, function (t, n, r, i, a) {
                      var s;
                      return o("tilde", e, t, n, r, i, a), ce(n) ? s = "" : ce(r) ? s = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : ce(i) ? s = ">=" + n + "." + r + ".0 <" + n + "." + (+r + 1) + ".0" : a ? (o("replaceTilde pr", a), "-" !== a.charAt(0) && (a = "-" + a), s = ">=" + n + "." + r + "." + i + a + " <" + n + "." + (+r + 1) + ".0") : s = ">=" + n + "." + r + "." + i + " <" + n + "." + (+r + 1) + ".0", o("tilde return", s), s;
                    });
                  }(e, t);
                }).join(" ");
              }(e, t), o("tildes", e), e = function (e, t) {
                return o("replaceXRanges", e, t), e.split(/\s+/).map(function (e) {
                  return function (e, t) {
                    e = e.trim();
                    var n = t ? s[R] : s[k];
                    return e.replace(n, function (t, n, r, i, a, s) {
                      o("xRange", e, t, n, r, i, a, s);
                      var u = ce(r),
                          c = u || ce(i),
                          l = c || ce(a),
                          f = l;
                      return "=" === n && f && (n = ""), u ? t = ">" === n || "<" === n ? "<0.0.0" : "*" : n && f ? (c && (i = 0), l && (a = 0), ">" === n ? (n = ">=", c ? (r = +r + 1, i = 0, a = 0) : l && (i = +i + 1, a = 0)) : "<=" === n && (n = "<", c ? r = +r + 1 : i = +i + 1), t = n + r + "." + i + "." + a) : c ? t = ">=" + r + ".0.0 <" + (+r + 1) + ".0.0" : l && (t = ">=" + r + "." + i + ".0 <" + r + "." + (+i + 1) + ".0"), o("xRange return", t), t;
                    });
                  }(e, t);
                }).join(" ");
              }(e, t), o("xrange", e), e = function (e, t) {
                return o("replaceStars", e, t), e.trim().replace(s[W], "");
              }(e, t), o("stars", e), e;
            }(e, t);
          }).join(" ").split(/\s+/);
          return this.loose && (i = i.filter(function (e) {
            return !!e.match(r);
          })), i = i.map(function (e) {
            return new ae(e, t);
          });
        }, ue.prototype.intersects = function (e, t) {
          if (!(e instanceof ue)) throw new TypeError("a Range is required");
          return this.set.some(function (n) {
            return n.every(function (n) {
              return e.set.some(function (e) {
                return e.every(function (e) {
                  return n.intersects(e, t);
                });
              });
            });
          });
        }, t.toComparators = function (e, t) {
          return new ue(e, t).set.map(function (e) {
            return e.map(function (e) {
              return e.value;
            }).join(" ").trim().split(" ");
          });
        }, ue.prototype.test = function (e) {
          if (!e) return !1;
          "string" == typeof e && (e = new K(e, this.loose));

          for (var t = 0; t < this.set.length; t++) {
            if (fe(this.set[t], e)) return !0;
          }

          return !1;
        }, t.satisfies = pe, t.maxSatisfying = function (e, t, n) {
          var r = null,
              o = null;

          try {
            var i = new ue(t, n);
          } catch (e) {
            return null;
          }

          return e.forEach(function (e) {
            i.test(e) && (r && -1 !== o.compare(e) || (o = new K(r = e, n)));
          }), r;
        }, t.minSatisfying = function (e, t, n) {
          var r = null,
              o = null;

          try {
            var i = new ue(t, n);
          } catch (e) {
            return null;
          }

          return e.forEach(function (e) {
            i.test(e) && (r && 1 !== o.compare(e) || (o = new K(r = e, n)));
          }), r;
        }, t.validRange = function (e, t) {
          try {
            return new ue(e, t).range || "*";
          } catch (e) {
            return null;
          }
        }, t.ltr = function (e, t, n) {
          return de(e, t, "<", n);
        }, t.gtr = function (e, t, n) {
          return de(e, t, ">", n);
        }, t.outside = de, t.prerelease = function (e, t) {
          var n = Y(e, t);
          return n && n.prerelease.length ? n.prerelease : null;
        }, t.intersects = function (e, t, n) {
          return e = new ue(e, n), t = new ue(t, n), e.intersects(t);
        }, t.coerce = function (e) {
          if (e instanceof K) return e;
          if ("string" != typeof e) return null;
          var t = e.match(s[j]);
          return null == t ? null : Y((t[1] || "0") + "." + (t[2] || "0") + "." + (t[3] || "0"));
        };
      }).call(this, n(6));
    }, function (e, t, n) {
      "use strict";

      (function (t) {
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */
        function r(e) {
          return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e;
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          })(e);
        }

        function o(e, t) {
          if (e === t) return 0;

          for (var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o) {
            if (e[o] !== t[o]) {
              n = e[o], r = t[o];
              break;
            }
          }

          return n < r ? -1 : r < n ? 1 : 0;
        }

        function i(e) {
          return t.Buffer && "function" == typeof t.Buffer.isBuffer ? t.Buffer.isBuffer(e) : !(null == e || !e._isBuffer);
        }

        var a = n(49),
            s = Object.prototype.hasOwnProperty,
            u = Array.prototype.slice,
            c = "foo" === function () {}.name;

        function l(e) {
          return Object.prototype.toString.call(e);
        }

        function f(e) {
          return !i(e) && "function" == typeof t.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : !!e && (e instanceof DataView || !!(e.buffer && e.buffer instanceof ArrayBuffer)));
        }

        var p = e.exports = g,
            d = /\s*function\s+([^\(\s]*)\s*/;

        function h(e) {
          if (a.isFunction(e)) {
            if (c) return e.name;
            var t = e.toString().match(d);
            return t && t[1];
          }
        }

        function m(e, t) {
          return "string" == typeof e ? e.length < t ? e : e.slice(0, t) : e;
        }

        function y(e) {
          if (c || !a.isFunction(e)) return a.inspect(e);
          var t = h(e);
          return "[Function" + (t ? ": " + t : "") + "]";
        }

        function v(e, t, n, r, o) {
          throw new p.AssertionError({
            message: n,
            actual: e,
            expected: t,
            operator: r,
            stackStartFunction: o
          });
        }

        function g(e, t) {
          e || v(e, !0, t, "==", p.ok);
        }

        function b(e, t, n, s) {
          if (e === t) return !0;
          if (i(e) && i(t)) return 0 === o(e, t);
          if (a.isDate(e) && a.isDate(t)) return e.getTime() === t.getTime();
          if (a.isRegExp(e) && a.isRegExp(t)) return e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.lastIndex === t.lastIndex && e.ignoreCase === t.ignoreCase;

          if (null !== e && "object" === r(e) || null !== t && "object" === r(t)) {
            if (f(e) && f(t) && l(e) === l(t) && !(e instanceof Float32Array || e instanceof Float64Array)) return 0 === o(new Uint8Array(e.buffer), new Uint8Array(t.buffer));
            if (i(e) !== i(t)) return !1;
            var c = (s = s || {
              actual: [],
              expected: []
            }).actual.indexOf(e);
            return -1 !== c && c === s.expected.indexOf(t) || (s.actual.push(e), s.expected.push(t), function (e, t, n, r) {
              if (null == e || null == t) return !1;
              if (a.isPrimitive(e) || a.isPrimitive(t)) return e === t;
              if (n && Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1;

              var o = _(e),
                  i = _(t);

              if (o && !i || !o && i) return !1;
              if (o) return e = u.call(e), t = u.call(t), b(e, t, n);
              var s,
                  c,
                  l = E(e),
                  f = E(t);
              if (l.length !== f.length) return !1;

              for (l.sort(), f.sort(), c = l.length - 1; c >= 0; c--) {
                if (l[c] !== f[c]) return !1;
              }

              for (c = l.length - 1; c >= 0; c--) {
                if (s = l[c], !b(e[s], t[s], n, r)) return !1;
              }

              return !0;
            }(e, t, n, s));
          }

          return n ? e === t : e == t;
        }

        function _(e) {
          return "[object Arguments]" == Object.prototype.toString.call(e);
        }

        function w(e, t) {
          if (!e || !t) return !1;
          if ("[object RegExp]" == Object.prototype.toString.call(t)) return t.test(e);

          try {
            if (e instanceof t) return !0;
          } catch (e) {}

          return !Error.isPrototypeOf(t) && !0 === t.call({}, e);
        }

        function S(e, t, n, r) {
          var o;
          if ("function" != typeof t) throw new TypeError('"block" argument must be a function');
          "string" == typeof n && (r = n, n = null), o = function (e) {
            var t;

            try {
              e();
            } catch (e) {
              t = e;
            }

            return t;
          }(t), r = (n && n.name ? " (" + n.name + ")." : ".") + (r ? " " + r : "."), e && !o && v(o, n, "Missing expected exception" + r);
          var i = "string" == typeof r,
              s = !e && o && !n;
          if ((!e && a.isError(o) && i && w(o, n) || s) && v(o, n, "Got unwanted exception" + r), e && o && n && !w(o, n) || !e && o) throw o;
        }

        p.AssertionError = function (e) {
          var t;
          this.name = "AssertionError", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = m(y((t = this).actual), 128) + " " + t.operator + " " + m(y(t.expected), 128), this.generatedMessage = !0);
          var n = e.stackStartFunction || v;
          if (Error.captureStackTrace) Error.captureStackTrace(this, n);else {
            var r = new Error();

            if (r.stack) {
              var o = r.stack,
                  i = h(n),
                  a = o.indexOf("\n" + i);

              if (a >= 0) {
                var s = o.indexOf("\n", a + 1);
                o = o.substring(s + 1);
              }

              this.stack = o;
            }
          }
        }, a.inherits(p.AssertionError, Error), p.fail = v, p.ok = g, p.equal = function (e, t, n) {
          e != t && v(e, t, n, "==", p.equal);
        }, p.notEqual = function (e, t, n) {
          e == t && v(e, t, n, "!=", p.notEqual);
        }, p.deepEqual = function (e, t, n) {
          b(e, t, !1) || v(e, t, n, "deepEqual", p.deepEqual);
        }, p.deepStrictEqual = function (e, t, n) {
          b(e, t, !0) || v(e, t, n, "deepStrictEqual", p.deepStrictEqual);
        }, p.notDeepEqual = function (e, t, n) {
          b(e, t, !1) && v(e, t, n, "notDeepEqual", p.notDeepEqual);
        }, p.notDeepStrictEqual = function e(t, n, r) {
          b(t, n, !0) && v(t, n, r, "notDeepStrictEqual", e);
        }, p.strictEqual = function (e, t, n) {
          e !== t && v(e, t, n, "===", p.strictEqual);
        }, p.notStrictEqual = function (e, t, n) {
          e === t && v(e, t, n, "!==", p.notStrictEqual);
        }, p.throws = function (e, t, n) {
          S(!0, e, t, n);
        }, p.doesNotThrow = function (e, t, n) {
          S(!1, e, t, n);
        }, p.ifError = function (e) {
          if (e) throw e;
        };

        var E = Object.keys || function (e) {
          var t = [];

          for (var n in e) {
            s.call(e, n) && t.push(n);
          }

          return t;
        };
      }).call(this, n(7));
    }, function (e, t, n) {
      (function (e, r) {
        function o(e) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e;
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          })(e);
        }

        var i = /%[sdj%]/g;
        t.format = function (e) {
          if (!g(e)) {
            for (var t = [], n = 0; n < arguments.length; n++) {
              t.push(u(arguments[n]));
            }

            return t.join(" ");
          }

          n = 1;

          for (var r = arguments, o = r.length, a = String(e).replace(i, function (e) {
            if ("%%" === e) return "%";
            if (n >= o) return e;

            switch (e) {
              case "%s":
                return String(r[n++]);

              case "%d":
                return Number(r[n++]);

              case "%j":
                try {
                  return JSON.stringify(r[n++]);
                } catch (e) {
                  return "[Circular]";
                }

              default:
                return e;
            }
          }), s = r[n]; n < o; s = r[++n]) {
            y(s) || !w(s) ? a += " " + s : a += " " + u(s);
          }

          return a;
        }, t.deprecate = function (n, o) {
          if (b(e.process)) return function () {
            return t.deprecate(n, o).apply(this, arguments);
          };
          if (!0 === r.noDeprecation) return n;
          var i = !1;
          return function () {
            if (!i) {
              if (r.throwDeprecation) throw new Error(o);
              r.traceDeprecation ? console.trace(o) : console.error(o), i = !0;
            }

            return n.apply(this, arguments);
          };
        };
        var a,
            s = {};

        function u(e, n) {
          var r = {
            seen: [],
            stylize: l
          };
          return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), m(n) ? r.showHidden = n : n && t._extend(r, n), b(r.showHidden) && (r.showHidden = !1), b(r.depth) && (r.depth = 2), b(r.colors) && (r.colors = !1), b(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = c), f(r, e, r.depth);
        }

        function c(e, t) {
          var n = u.styles[t];
          return n ? "[" + u.colors[n][0] + "m" + e + "[" + u.colors[n][1] + "m" : e;
        }

        function l(e, t) {
          return e;
        }

        function f(e, n, r) {
          if (e.customInspect && n && O(n.inspect) && n.inspect !== t.inspect && (!n.constructor || n.constructor.prototype !== n)) {
            var o = n.inspect(r, e);
            return g(o) || (o = f(e, o, r)), o;
          }

          var i = function (e, t) {
            if (b(t)) return e.stylize("undefined", "undefined");

            if (g(t)) {
              var n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return e.stylize(n, "string");
            }

            if (v(t)) return e.stylize("" + t, "number");
            if (m(t)) return e.stylize("" + t, "boolean");
            if (y(t)) return e.stylize("null", "null");
          }(e, n);

          if (i) return i;

          var a = Object.keys(n),
              s = function (e) {
            var t = {};
            return e.forEach(function (e, n) {
              t[e] = !0;
            }), t;
          }(a);

          if (e.showHidden && (a = Object.getOwnPropertyNames(n)), E(n) && (a.indexOf("message") >= 0 || a.indexOf("description") >= 0)) return p(n);

          if (0 === a.length) {
            if (O(n)) {
              var u = n.name ? ": " + n.name : "";
              return e.stylize("[Function" + u + "]", "special");
            }

            if (_(n)) return e.stylize(RegExp.prototype.toString.call(n), "regexp");
            if (S(n)) return e.stylize(Date.prototype.toString.call(n), "date");
            if (E(n)) return p(n);
          }

          var c,
              l = "",
              w = !1,
              x = ["{", "}"];
          (h(n) && (w = !0, x = ["[", "]"]), O(n)) && (l = " [Function" + (n.name ? ": " + n.name : "") + "]");
          return _(n) && (l = " " + RegExp.prototype.toString.call(n)), S(n) && (l = " " + Date.prototype.toUTCString.call(n)), E(n) && (l = " " + p(n)), 0 !== a.length || w && 0 != n.length ? r < 0 ? _(n) ? e.stylize(RegExp.prototype.toString.call(n), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(n), c = w ? function (e, t, n, r, o) {
            for (var i = [], a = 0, s = t.length; a < s; ++a) {
              N(t, String(a)) ? i.push(d(e, t, n, r, String(a), !0)) : i.push("");
            }

            return o.forEach(function (o) {
              o.match(/^\d+$/) || i.push(d(e, t, n, r, o, !0));
            }), i;
          }(e, n, r, s, a) : a.map(function (t) {
            return d(e, n, r, s, t, w);
          }), e.seen.pop(), function (e, t, n) {
            if (e.reduce(function (e, t) {
              return 0, t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60) return n[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + n[1];
            return n[0] + t + " " + e.join(", ") + " " + n[1];
          }(c, l, x)) : x[0] + l + x[1];
        }

        function p(e) {
          return "[" + Error.prototype.toString.call(e) + "]";
        }

        function d(e, t, n, r, o, i) {
          var a, s, u;

          if ((u = Object.getOwnPropertyDescriptor(t, o) || {
            value: t[o]
          }).get ? s = u.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : u.set && (s = e.stylize("[Setter]", "special")), N(r, o) || (a = "[" + o + "]"), s || (e.seen.indexOf(u.value) < 0 ? (s = y(n) ? f(e, u.value, null) : f(e, u.value, n - 1)).indexOf("\n") > -1 && (s = i ? s.split("\n").map(function (e) {
            return "  " + e;
          }).join("\n").substr(2) : "\n" + s.split("\n").map(function (e) {
            return "   " + e;
          }).join("\n")) : s = e.stylize("[Circular]", "special")), b(a)) {
            if (i && o.match(/^\d+$/)) return s;
            (a = JSON.stringify("" + o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.substr(1, a.length - 2), a = e.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = e.stylize(a, "string"));
          }

          return a + ": " + s;
        }

        function h(e) {
          return Array.isArray(e);
        }

        function m(e) {
          return "boolean" == typeof e;
        }

        function y(e) {
          return null === e;
        }

        function v(e) {
          return "number" == typeof e;
        }

        function g(e) {
          return "string" == typeof e;
        }

        function b(e) {
          return void 0 === e;
        }

        function _(e) {
          return w(e) && "[object RegExp]" === x(e);
        }

        function w(e) {
          return "object" === o(e) && null !== e;
        }

        function S(e) {
          return w(e) && "[object Date]" === x(e);
        }

        function E(e) {
          return w(e) && ("[object Error]" === x(e) || e instanceof Error);
        }

        function O(e) {
          return "function" == typeof e;
        }

        function x(e) {
          return Object.prototype.toString.call(e);
        }

        function C(e) {
          return e < 10 ? "0" + e.toString(10) : e.toString(10);
        }

        t.debuglog = function (e) {
          if (b(a) && (a = r.env.NODE_DEBUG || ""), e = e.toUpperCase(), !s[e]) if (new RegExp("\\b" + e + "\\b", "i").test(a)) {
            var n = r.pid;

            s[e] = function () {
              var r = t.format.apply(t, arguments);
              console.error("%s %d: %s", e, n, r);
            };
          } else s[e] = function () {};
          return s[e];
        }, t.inspect = u, u.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, u.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          regexp: "red"
        }, t.isArray = h, t.isBoolean = m, t.isNull = y, t.isNullOrUndefined = function (e) {
          return null == e;
        }, t.isNumber = v, t.isString = g, t.isSymbol = function (e) {
          return "symbol" === o(e);
        }, t.isUndefined = b, t.isRegExp = _, t.isObject = w, t.isDate = S, t.isError = E, t.isFunction = O, t.isPrimitive = function (e) {
          return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" === o(e) || void 0 === e;
        }, t.isBuffer = n(50);
        var I = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        function N(e, t) {
          return Object.prototype.hasOwnProperty.call(e, t);
        }

        t.log = function () {
          var e, n;
          console.log("%s - %s", (e = new Date(), n = [C(e.getHours()), C(e.getMinutes()), C(e.getSeconds())].join(":"), [e.getDate(), I[e.getMonth()], n].join(" ")), t.format.apply(t, arguments));
        }, t.inherits = n(51), t._extend = function (e, t) {
          if (!t || !w(t)) return e;

          for (var n = Object.keys(t), r = n.length; r--;) {
            e[n[r]] = t[n[r]];
          }

          return e;
        };
      }).call(this, n(7), n(6));
    }, function (e, t) {
      function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      e.exports = function (e) {
        return e && "object" === n(e) && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8;
      };
    }, function (e, t) {
      "function" == typeof Object.create ? e.exports = function (e, t) {
        e.super_ = t, e.prototype = Object.create(t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : e.exports = function (e, t) {
        e.super_ = t;

        var n = function n() {};

        n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e;
      };
    }, function (e, t, n) {
      "use strict";

      function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      function o(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = n, e;
      }

      var i = n(53),
          a = {};

      e.exports = function (e, t, n) {
        e.onCall("rn-style:get", function (e) {
          var r = t.elementData.get(e);
          return r && r.props ? n(r.props.style) : null;
        }), e.on("rn-style:measure", function (r) {
          u(t, e, n, r);
        }), e.on("rn-style:rename", function (i) {
          var s = i.id,
              l = i.oldName,
              f = i.newName,
              p = i.val;
          !function (e, t, n, i, s) {
            var u,
                l = e.elementData.get(t),
                f = i ? (o(u = {}, n, void 0), o(u, i, s), u) : o({}, n, void 0);

            if (l && l.updater && "function" == typeof l.updater.setInProps) {
              var p,
                  d = l && l.props && l.props.style;

              if (Array.isArray(d)) {
                var h = d.length - 1;
                "object" !== r(d[h]) || Array.isArray(d[h]) ? (d = d.concat([f]), l.updater.setInProps(["style"], d)) : (delete (p = c(d[h]))[n], i ? p[i] = s : p[n] = void 0, l.updater.setInProps(["style", h], p));
              } else "object" === r(d) ? (delete (p = c(d))[n], i ? p[i] = s : p[n] = void 0, l.updater.setInProps(["style"], p)) : (d = [d, f], l.updater.setInProps(["style"], d));
            } else {
              if (!l || !l.updater || "function" != typeof l.updater.setNativeProps) return;
              a[t] ? _extends(a[t], f) : a[t] = f, l.updater.setNativeProps({
                style: f
              });
            }

            e.emit("hideHighlight");
          }(t, s, l, f, p), setTimeout(function () {
            return u(t, e, n, s);
          });
        }), e.on("rn-style:set", function (i) {
          var s = i.id,
              c = i.attr,
              l = i.val;
          !function (e, t, n, i) {
            var s = e.elementData.get(t),
                u = o({}, n, i);

            if (s && s.updater && "function" == typeof s.updater.setInProps) {
              var c = s.props && s.props.style;

              if (Array.isArray(c)) {
                var l = c.length - 1;
                "object" !== r(c[l]) || Array.isArray(c[l]) ? (c = c.concat([u]), s.updater.setInProps(["style"], c)) : s.updater.setInProps(["style", l, n], i);
              } else c = [c, u], s.updater.setInProps(["style"], c);
            } else {
              if (!s || !s.updater || "function" != typeof s.updater.setNativeProps) return;
              a[t] ? _extends(a[t], u) : a[t] = u, s.updater.setNativeProps({
                style: u
              });
            }

            e.emit("hideHighlight");
          }(t, s, c, l), setTimeout(function () {
            return u(t, e, n, s);
          });
        });
      };

      var s = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };

      function u(e, t, n, r) {
        var o = e.elementData.get(r);

        if (o && o.props) {
          var u = n(o.props.style);
          a[r] && (u = _extends({}, u, a[r]));
          var c = o.publicInstance;
          c && c.measure ? c.measure(function (e, n, r, o, a, c) {
            if ("number" == typeof e) {
              var l = u && i("margin", u) || s,
                  f = u && i("padding", u) || s;
              t.send("rn-style:measure", {
                style: u,
                measuredLayout: {
                  x: e,
                  y: n,
                  width: r,
                  height: o,
                  left: a,
                  top: c,
                  margin: l,
                  padding: f
                }
              });
            } else t.send("rn-style:measure", {
              style: u
            });
          }) : t.send("rn-style:measure", {
            style: u
          });
        } else t.send("rn-style:measure", {});
      }

      function c(e) {
        var t = {};

        for (var n in e) {
          t[n] = e[n];
        }

        return t;
      }
    }, function (e, t) {
      e.exports = function (e, t) {
        var n = {},
            r = ["top", "left", "bottom", "right"],
            o = !1;
        return r.forEach(function (r) {
          n[r] = t[e] || 0;
        }), t[e] && (o = !0), t[e + "Vertical"] && (n.top = n.bottom = t[e + "Vertical"], o = !0), t[e + "Horizontal"] && (n.left = n.right = t[e + "Horizontal"], o = !0), r.forEach(function (r) {
          var i,
              a = t[e + (i = r, i[0].toUpperCase() + i.slice(1))];
          a && (n[r] = a, o = !0);
        }), o ? n : null;
      };
    }, function (e, t, n) {
      var r, o, i;
      !function (n, a) {
        "use strict";

        o = [], void 0 === (i = "function" == typeof (r = function r() {
          function e(e) {
            return !isNaN(parseFloat(e)) && isFinite(e);
          }

          function t(e) {
            return e.charAt(0).toUpperCase() + e.substring(1);
          }

          function n(e) {
            return function () {
              return this[e];
            };
          }

          var r = ["isConstructor", "isEval", "isNative", "isToplevel"],
              o = ["columnNumber", "lineNumber"],
              i = ["fileName", "functionName", "source"],
              a = r.concat(o, i, ["args"]);

          function s(e) {
            if (e instanceof Object) for (var n = 0; n < a.length; n++) {
              e.hasOwnProperty(a[n]) && void 0 !== e[a[n]] && this["set" + t(a[n])](e[a[n]]);
            }
          }

          s.prototype = {
            getArgs: function getArgs() {
              return this.args;
            },
            setArgs: function setArgs(e) {
              if ("[object Array]" !== Object.prototype.toString.call(e)) throw new TypeError("Args must be an Array");
              this.args = e;
            },
            getEvalOrigin: function getEvalOrigin() {
              return this.evalOrigin;
            },
            setEvalOrigin: function setEvalOrigin(e) {
              if (e instanceof s) this.evalOrigin = e;else {
                if (!(e instanceof Object)) throw new TypeError("Eval Origin must be an Object or StackFrame");
                this.evalOrigin = new s(e);
              }
            },
            toString: function toString() {
              var t = this.getFunctionName() || "{anonymous}",
                  n = "(" + (this.getArgs() || []).join(",") + ")",
                  r = this.getFileName() ? "@" + this.getFileName() : "",
                  o = e(this.getLineNumber()) ? ":" + this.getLineNumber() : "",
                  i = e(this.getColumnNumber()) ? ":" + this.getColumnNumber() : "";
              return t + n + r + o + i;
            }
          };

          for (var u = 0; u < r.length; u++) {
            s.prototype["get" + t(r[u])] = n(r[u]), s.prototype["set" + t(r[u])] = function (e) {
              return function (t) {
                this[e] = Boolean(t);
              };
            }(r[u]);
          }

          for (var c = 0; c < o.length; c++) {
            s.prototype["get" + t(o[c])] = n(o[c]), s.prototype["set" + t(o[c])] = function (t) {
              return function (n) {
                if (!e(n)) throw new TypeError(t + " must be a Number");
                this[t] = Number(n);
              };
            }(o[c]);
          }

          for (var l = 0; l < i.length; l++) {
            s.prototype["get" + t(i[l])] = n(i[l]), s.prototype["set" + t(i[l])] = function (e) {
              return function (t) {
                this[e] = String(t);
              };
            }(i[l]);
          }

          return s;
        }) ? r.apply(t, o) : r) || (e.exports = i);
      }();
    }, function (e, t, n) {
      "use strict";

      var r = function r() {};

      e.exports = function (e, t, n) {
        var o = function o() {
          var n = !1;
          t.roots.forEach(function (e) {
            t.internalInstancesById.get(e).hasOwnProperty("treeBaseDuration") && (n = !0);
          }), e.call("profiler:update", [n], r);
        };

        t.on("root", o), t.on("rootUnmounted", o), o();
      };
    }, function (e, t, n) {
      "use strict";

      var r = n(57);

      e.exports = function (e) {
        var t = new r(window, function (t) {
          e.selectFromDOMNode(t);
        });
        e.on("highlight", function (e) {
          return t.highlight(e.node, e.name);
        }), e.on("highlightMany", function (e) {
          return t.highlightMany(e);
        }), e.on("hideHighlight", function () {
          return t.hideHighlight();
        }), e.on("refreshMultiOverlay", function () {
          return t.refreshMultiOverlay();
        }), e.on("startInspecting", function () {
          return t.startInspecting();
        }), e.on("stopInspecting", function () {
          return t.stopInspecting();
        }), e.on("shutdown", function () {
          t.remove();
        });
      };
    }, function (e, t, n) {
      "use strict";

      function r(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
      }

      var o = n(58),
          i = n(60),
          a = function () {
        function e(t, n) {
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, e), this._win = t, this._onSelect = n, this._overlay = null, this._multiOverlay = null, this._subs = [];
        }

        var t, n, a;
        return t = e, (n = [{
          key: "startInspecting",
          value: function value() {
            this._inspecting = !0, this._subs = [s(this._win, "mouseover", this.onHover.bind(this)), s(this._win, "mousedown", this.onMouseDown.bind(this)), s(this._win, "click", this.onClick.bind(this))];
          }
        }, {
          key: "stopInspecting",
          value: function value() {
            this._subs.forEach(function (e) {
              return e();
            }), this.hideHighlight();
          }
        }, {
          key: "remove",
          value: function value() {
            this.stopInspecting(), this._button && this._button.parentNode && this._button.parentNode.removeChild(this._button);
          }
        }, {
          key: "highlight",
          value: function value(e, t) {
            this.removeMultiOverlay(), e.nodeType !== Node.COMMENT_NODE && (this._overlay || (this._overlay = new o(this._win)), this._overlay.inspect(e, t));
          }
        }, {
          key: "highlightMany",
          value: function value(e) {
            this.removeOverlay(), this._multiOverlay || (this._multiOverlay = new i(this._win)), this._multiOverlay.highlightMany(e);
          }
        }, {
          key: "hideHighlight",
          value: function value() {
            this._inspecting = !1, this.removeOverlay(), this.removeMultiOverlay();
          }
        }, {
          key: "refreshMultiOverlay",
          value: function value() {
            this._multiOverlay && this._multiOverlay.refresh();
          }
        }, {
          key: "removeOverlay",
          value: function value() {
            this._overlay && (this._overlay.remove(), this._overlay = null);
          }
        }, {
          key: "removeMultiOverlay",
          value: function value() {
            this._multiOverlay && (this._multiOverlay.remove(), this._multiOverlay = null);
          }
        }, {
          key: "onMouseDown",
          value: function value(e) {
            this._inspecting && (e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0, this._onSelect(e.target));
          }
        }, {
          key: "onClick",
          value: function value(e) {
            this._inspecting && (this._subs.forEach(function (e) {
              return e();
            }), e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0, this.hideHighlight());
          }
        }, {
          key: "onHover",
          value: function value(e) {
            this._inspecting && (e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0, this.highlight(e.target));
          }
        }, {
          key: "injectButton",
          value: function value() {
            var e;
            this._button = ((e = window.document.createElement("button")).innerHTML = "&#128269;", e.style.backgroundColor = "transparent", e.style.border = "none", e.style.outline = "none", e.style.cursor = "pointer", e.style.position = "fixed", e.style.bottom = "10px", e.style.right = "10px", e.style.fontSize = "30px", e.style.zIndex = 1e7, e), this._button.onclick = this.startInspecting.bind(this), this._win.document.body.appendChild(this._button);
          }
        }]) && r(t.prototype, n), a && r(t, a), e;
      }();

      function s(e, t, n) {
        return e.addEventListener(t, n, !0), function () {
          return e.removeEventListener(t, n, !0);
        };
      }

      e.exports = a;
    }, function (e, t, n) {
      "use strict";

      function r(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
      }

      var o = n(1),
          i = n(59).monospace,
          a = function () {
        function e(t) {
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, e);
          var n = t.document;
          this.win = t, this.container = n.createElement("div"), this.node = n.createElement("div"), this.border = n.createElement("div"), this.padding = n.createElement("div"), this.content = n.createElement("div"), this.border.style.borderColor = d.border, this.padding.style.borderColor = d.padding, this.content.style.backgroundColor = d.background, o(this.node.style, {
            borderColor: d.margin,
            pointerEvents: "none",
            position: "fixed"
          }), this.tip = n.createElement("div"), o(this.tip.style, {
            backgroundColor: "#333740",
            borderRadius: "2px",
            fontFamily: i.family,
            fontWeight: "bold",
            padding: "3px 5px",
            position: "fixed",
            fontSize: i.sizes.normal + "px"
          }), this.nameSpan = n.createElement("span"), this.tip.appendChild(this.nameSpan), o(this.nameSpan.style, {
            color: "#ee78e6",
            borderRight: "1px solid #aaaaaa",
            paddingRight: "0.5rem",
            marginRight: "0.5rem"
          }), this.dimSpan = n.createElement("span"), this.tip.appendChild(this.dimSpan), o(this.dimSpan.style, {
            color: "#d7d7d7"
          }), this.container.style.zIndex = 1e7, this.node.style.zIndex = 1e7, this.tip.style.zIndex = 1e7, this.container.appendChild(this.node), this.container.appendChild(this.tip), this.node.appendChild(this.border), this.border.appendChild(this.padding), this.padding.appendChild(this.content), n.body.appendChild(this.container);
        }

        var t, n, a;
        return t = e, (n = [{
          key: "remove",
          value: function value() {
            this.container.parentNode && this.container.parentNode.removeChild(this.container);
          }
        }, {
          key: "inspect",
          value: function value(e, t) {
            if (e.nodeType === Node.ELEMENT_NODE) {
              var n = function (e, t) {
                var n = c(e);

                if (n && n !== t) {
                  for (var r = [e.getBoundingClientRect()], o = n, i = !1; o;) {
                    var a = l(o);
                    if (r.push(a), o = c(o), i) break;
                    o && u(o) === t && (i = !0);
                  }

                  return f(r);
                }

                return e.getBoundingClientRect();
              }(e, this.win),
                  r = s(e);

              p(r, "margin", this.node), p(r, "border", this.border), p(r, "padding", this.padding), o(this.content.style, {
                height: n.height - r.borderTop - r.borderBottom - r.paddingTop - r.paddingBottom + "px",
                width: n.width - r.borderLeft - r.borderRight - r.paddingLeft - r.paddingRight + "px"
              }), o(this.node.style, {
                top: n.top - r.marginTop + "px",
                left: n.left - r.marginLeft + "px"
              }), this.nameSpan.textContent = t || e.nodeName.toLowerCase(), this.dimSpan.textContent = n.width + "px × " + n.height + "px";

              var i = function (e, t) {
                var n;
                n = e.top + e.height + 20 <= t.innerHeight ? e.top + e.height < 0 ? 5 : e.top + e.height + 5 : e.top - 20 <= t.innerHeight ? e.top - 20 - 5 < 5 ? 5 : e.top - 20 - 5 : t.innerHeight - 20 - 5;
                if (n += "px", e.left < 0) return {
                  top: n,
                  left: 5
                };
                if (e.left + 200 > t.innerWidth) return {
                  top: n,
                  right: 5
                };
                return {
                  top: n,
                  left: e.left + 5 + "px"
                };
              }({
                top: n.top - r.marginTop,
                left: n.left - r.marginLeft,
                height: n.height + r.marginTop + r.marginBottom,
                width: n.width + r.marginLeft + r.marginRight
              }, this.win);

              o(this.tip.style, i);
            }
          }
        }]) && r(t.prototype, n), a && r(t, a), e;
      }();

      function s(e) {
        var t = window.getComputedStyle(e);
        return {
          borderLeft: +t.borderLeftWidth.match(/[0-9]*/)[0],
          borderRight: +t.borderRightWidth.match(/[0-9]*/)[0],
          borderTop: +t.borderTopWidth.match(/[0-9]*/)[0],
          borderBottom: +t.borderBottomWidth.match(/[0-9]*/)[0],
          marginLeft: +t.marginLeft.match(/[0-9]*/)[0],
          marginRight: +t.marginRight.match(/[0-9]*/)[0],
          marginTop: +t.marginTop.match(/[0-9]*/)[0],
          marginBottom: +t.marginBottom.match(/[0-9]*/)[0],
          paddingLeft: +t.paddingLeft.match(/[0-9]*/)[0],
          paddingRight: +t.paddingRight.match(/[0-9]*/)[0],
          paddingTop: +t.paddingTop.match(/[0-9]*/)[0],
          paddingBottom: +t.paddingBottom.match(/[0-9]*/)[0]
        };
      }

      function u(e) {
        return e.ownerDocument ? e.ownerDocument.defaultView : null;
      }

      function c(e) {
        var t = u(e);
        return t ? t.frameElement : null;
      }

      function l(e) {
        var t = s(e);
        return f([e.getBoundingClientRect(), {
          top: t.borderTop,
          left: t.borderLeft,
          bottom: t.borderBottom,
          right: t.borderRight,
          width: 0,
          height: 0
        }]);
      }

      function f(e) {
        return e.reduce(function (e, t) {
          return null == e ? t : {
            top: e.top + t.top,
            left: e.left + t.left,
            width: e.width,
            height: e.height,
            bottom: e.bottom + t.bottom,
            right: e.right + t.right
          };
        });
      }

      function p(e, t, n) {
        o(n.style, {
          borderTopWidth: e[t + "Top"] + "px",
          borderLeftWidth: e[t + "Left"] + "px",
          borderRightWidth: e[t + "Right"] + "px",
          borderBottomWidth: e[t + "Bottom"] + "px",
          borderStyle: "solid"
        });
      }

      var d = {
        background: "rgba(120, 170, 210, 0.7)",
        padding: "rgba(77, 200, 0, 0.3)",
        margin: "rgba(255, 155, 0, 0.3)",
        border: "rgba(255, 200, 50, 0.3)"
      };
      e.exports = a;
    }, function (e, t, n) {
      "use strict";

      e.exports = {
        monospace: {
          family: "Menlo, Consolas, monospace",
          sizes: {
            normal: 11,
            large: 14
          }
        },
        sansSerif: {
          family: '"Helvetica Neue", "Lucida Grande", -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, sans-serif',
          sizes: {
            small: 10,
            normal: 12,
            large: 14
          }
        }
      };
    }, function (e, t, n) {
      "use strict";

      function r(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
      }

      var o = n(1),
          i = function () {
        function e(t) {
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, e), this.win = t;
          var n = t.document;
          this.container = n.createElement("div"), n.body.appendChild(this.container), this._currentNodes = null;
        }

        var t, n, i;
        return t = e, (n = [{
          key: "highlightMany",
          value: function value(e) {
            var t = this;
            this._currentNodes = e, this.container.innerHTML = "", e.forEach(function (e) {
              var n = t.win.document.createElement("div");

              if ("function" == typeof e.getBoundingClientRect) {
                var r = e.getBoundingClientRect();
                r.bottom < 0 || r.top > window.innerHeight || (o(n.style, {
                  top: r.top + "px",
                  left: r.left + "px",
                  width: r.width + "px",
                  height: r.height + "px",
                  border: "2px dotted rgba(200, 100, 100, .8)",
                  boxSizing: "border-box",
                  backgroundColor: "rgba(200, 100, 100, .2)",
                  position: "fixed",
                  zIndex: 1e7,
                  pointerEvents: "none"
                }), t.container.appendChild(n));
              }
            });
          }
        }, {
          key: "refresh",
          value: function value() {
            this._currentNodes && this.highlightMany(this._currentNodes);
          }
        }, {
          key: "remove",
          value: function value() {
            this.container.parentNode && (this.container.parentNode.removeChild(this.container), this._currentNodes = null);
          }
        }]) && r(t.prototype, n), i && r(t, i), e;
      }();

      e.exports = i;
    }, function (e, t, n) {
      "use strict";

      n.r(t);
      var r = n(0),
          o = n.n(r);

      function i(e) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        })(e);
      }

      var a = 10,
          s = 11,
          u = 0,
          c = 15,
          l = [],
          f = null;

      function p() {
        if (null === f) {
          var e,
              t = new Map();

          try {
            m.useContext({
              _currentValue: null
            }), m.useState(null), m.useReducer(function (e, t) {
              return e;
            }, null), m.useRef(null), m.useLayoutEffect(function () {}), m.useEffect(function () {}), m.useImperativeHandle(void 0, function () {
              return null;
            }), m.useCallback(function () {}), m.useMemo(function () {
              return null;
            }), m.useDebugValue(null);
          } finally {
            e = l, l = [];
          }

          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            t.set(r.primitive, o.a.parse(r.stackError));
          }

          f = t;
        }

        return f;
      }

      var d = null;

      function h() {
        var e = d;
        return null !== e && (d = e.next), e;
      }

      var m = {
        readContext: function readContext(e, t) {
          return e._currentValue;
        },
        useCallback: function useCallback(e, t) {
          var n = h();
          return l.push({
            primitive: "Callback",
            stackError: new Error(),
            value: null !== n ? n.memoizedState[0] : e
          }), e;
        },
        useContext: function useContext(e, t) {
          return l.push({
            primitive: "Context",
            stackError: new Error(),
            value: e._currentValue
          }), e._currentValue;
        },
        useEffect: function useEffect(e, t) {
          h(), l.push({
            primitive: "Effect",
            stackError: new Error(),
            value: e
          });
        },
        useImperativeHandle: function useImperativeHandle(e, t, n) {
          h();
          var r = void 0;
          null !== e && "object" === i(e) && (r = e.current), l.push({
            primitive: "ImperativeHandle",
            stackError: new Error(),
            value: r
          });
        },
        useDebugValue: function useDebugValue(e, t) {
          l.push({
            primitive: "DebugValue",
            stackError: new Error(),
            value: "function" == typeof t ? t(e) : e
          });
        },
        useLayoutEffect: function useLayoutEffect(e, t) {
          h(), l.push({
            primitive: "LayoutEffect",
            stackError: new Error(),
            value: e
          });
        },
        useMemo: function useMemo(e, t) {
          var n = h(),
              r = null !== n ? n.memoizedState[0] : e();
          return l.push({
            primitive: "Memo",
            stackError: new Error(),
            value: r
          }), r;
        },
        useReducer: function useReducer(e, t, n) {
          var r = h(),
              o = null !== r ? r.memoizedState : t;
          return l.push({
            primitive: "Reducer",
            stackError: new Error(),
            value: o
          }), [o, function (e) {}];
        },
        useRef: function useRef(e) {
          var t = h(),
              n = null !== t ? t.memoizedState : {
            current: e
          };
          return l.push({
            primitive: "Ref",
            stackError: new Error(),
            value: n.current
          }), n;
        },
        useState: function useState(e) {
          var t = h(),
              n = null !== t ? t.memoizedState : "function" == typeof e ? e() : e;
          return l.push({
            primitive: "State",
            stackError: new Error(),
            value: n
          }), [n, function (e) {}];
        }
      },
          y = 0;

      function v(e, t, n) {
        var r = t[n].source;

        e: for (var o = 0; o < e.length; o++) {
          if (e[o].source === r) {
            for (var i = n + 1, a = o + 1; i < t.length && a < e.length; i++, a++) {
              if (e[a].source !== t[i].source) continue e;
            }

            return o;
          }
        }

        return -1;
      }

      function g(e, t) {
        if (!e) return !1;
        var n = "use" + t;
        return !(e.length < n.length) && e.lastIndexOf(n) === e.length - n.length;
      }

      function b(e, t) {
        var n = o.a.parse(t.stackError),
            r = function (e, t) {
          var n = v(t, e, y);
          if (-1 !== n) return n;

          for (var r = 0; r < e.length && r < 5; r++) {
            if (-1 !== (n = v(t, e, r))) return y = r, n;
          }

          return -1;
        }(e, n),
            i = function (e, t) {
          var n = p().get(t.primitive);
          if (void 0 === n) return -1;

          for (var r = 0; r < n.length && r < e.length; r++) {
            if (n[r].source !== e[r].source) return r < e.length - 1 && g(e[r].functionName, t.primitive) && r++, r < e.length - 1 && g(e[r].functionName, t.primitive) && r++, r;
          }

          return -1;
        }(n, t);

        return -1 === r || -1 === i || r - i < 2 ? null : n.slice(i, r - 1);
      }

      function _(e) {
        if (!e) return "";
        var t = e.lastIndexOf(".");
        return -1 === t && (t = 0), "use" === e.substr(t, 3) && (t += 3), e.substr(t);
      }

      function w(e, t) {
        for (var n = [], r = null, o = n, i = [], a = 0; a < t.length; a++) {
          var s = t[a],
              u = b(e, s);

          if (null !== u) {
            var c = 0;

            if (null !== r) {
              for (; c < u.length && c < r.length;) {
                if (u[u.length - c - 1].source !== r[r.length - c - 1].source) break;
                c++;
              }

              for (var l = r.length - 1; l > c; l--) {
                o = i.pop();
              }
            }

            for (var f = u.length - c - 1; f >= 1; f--) {
              var p = [];
              o.push({
                name: _(u[f - 1].functionName),
                value: void 0,
                subHooks: p
              }), i.push(o), o = p;
            }

            r = u;
          }

          o.push({
            name: s.primitive,
            value: s.value,
            subHooks: []
          });
        }

        return function e(t, n) {
          var r = [];

          for (var o = 0; o < t.length; o++) {
            var i = t[o];
            "DebugValue" === i.name && 0 === i.subHooks.length ? (t.splice(o, 1), o--, r.push(i)) : e(i.subHooks, i);
          }

          null !== n && (1 === r.length ? n.value = r[0].value : r.length > 1 && (n.value = r.map(function (e) {
            var t = e.value;
            return t;
          })));
        }(n, null), n;
      }

      function S(e, t) {
        if (e.tag !== u && e.tag !== c && e.tag !== s) throw new Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
        p();
        var n = e.type,
            r = e.memoizedProps;
        n !== e.elementType && (r = function (e, t) {
          if (e && e.defaultProps) {
            var n = _extends({}, t),
                r = e.defaultProps;

            for (var o in r) {
              void 0 === n[o] && (n[o] = r[o]);
            }

            return n;
          }

          return t;
        }(n, r)), d = e.memoizedState;
        var i = new Map();

        try {
          return function (e, t) {
            for (var n = t; n;) {
              if (n.tag === a) {
                var r = n.type._context;
                e.has(r) || (e.set(r, r._currentValue), r._currentValue = n.memoizedProps.value);
              }

              n = n.return;
            }
          }(i, e), e.tag === s ? function (e, t, n, r) {
            var i,
                a,
                s = r.current;
            r.current = m;

            try {
              a = new Error(), e(t, n);
            } finally {
              i = l, l = [], r.current = s;
            }

            return w(o.a.parse(a), i);
          }(n.render, r, e.ref, t) : function (e, t, n) {
            var r,
                i,
                a = n.current;
            n.current = m;

            try {
              i = new Error(), e(t);
            } finally {
              r = l, l = [], n.current = a;
            }

            return w(o.a.parse(i), r);
          }(n, r, t);
        } finally {
          d = null, function (e) {
            e.forEach(function (e, t) {
              return t._currentValue = e;
            });
          }(i);
        }
      }

      function E(e, t) {
        var n = null,
            r = null;

        function o(e) {
          var n = t.elementData.get(e),
              r = t.internalInstancesById.get(e);

          if (r) {
            var o = t.renderers.get(e);

            if (o) {
              var i = t.reactInternals[o].renderer;
              if (i && i.currentDispatcherRef) return {
                elementID: e,
                id: "hooksTree",
                hooksTree: S(n.state === r.memoizedState ? r : r.alternate, i.currentDispatcherRef)
              };
            }
          }

          return null;
        }

        t.on("selected", function (i) {
          r = i;
          var a = t.elementData.get(i),
              s = null;
          a && a.containsHooks && (s = o(i)), n !== s && (n = s, e.send("inspectedHooks", s));
        }), t.on("update", function (t) {
          if (null !== r && null !== n && n.elementID === t.id) {
            var i = o(t.id);
            n !== i && (n = i, e.send("inspectedHooks", i));
          }
        });
      }

      n.d(t, "default", function () {
        return E;
      });
    }]);
  });
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-devtools-core_build_backend.js",["node_modules_@babel_runtime_helpers_extends.js"],"node_modules/react-devtools-core/build/backend.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var JSInspector = {
    registerAgent: function registerAgent(type) {
      if (global.__registerInspectorAgent) {
        global.__registerInspectorAgent(type);
      }
    },
    getTimestamp: function getTimestamp() {
      return global.__inspectorTimestamp();
    }
  };
  module.exports = JSInspector;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_JSInspector_JSInspector.js",[],"node_modules/react-native/Libraries/JSInspector/JSInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _inherits = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/getPrototypeOf");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var InspectorAgent = _$$_REQUIRE(_dependencyMap[5], "InspectorAgent");

  var JSInspector = _$$_REQUIRE(_dependencyMap[6], "JSInspector");

  var XMLHttpRequest = _$$_REQUIRE(_dependencyMap[7], "XMLHttpRequest");

  var Interceptor = function () {
    function Interceptor(agent) {
      _classCallCheck(this, Interceptor);

      this._agent = agent;
      this._requests = new Map();
    }

    _createClass(Interceptor, [{
      key: "getData",
      value: function getData(requestId) {
        return this._requests.get(requestId);
      }
    }, {
      key: "requestSent",
      value: function requestSent(id, url, method, headers) {
        var requestId = String(id);

        this._requests.set(requestId, '');

        var request = {
          url: url,
          method: method,
          headers: headers,
          initialPriority: 'Medium'
        };
        var event = {
          requestId: requestId,
          documentURL: '',
          frameId: '1',
          loaderId: '1',
          request: request,
          timestamp: JSInspector.getTimestamp(),
          initiator: {
            type: 'other'
          },
          type: 'Other'
        };

        this._agent.sendEvent('requestWillBeSent', event);
      }
    }, {
      key: "responseReceived",
      value: function responseReceived(id, url, status, headers) {
        var requestId = String(id);
        var response = {
          url: url,
          status: status,
          statusText: String(status),
          headers: headers,
          requestHeaders: {},
          mimeType: this._getMimeType(headers),
          connectionReused: false,
          connectionId: -1,
          encodedDataLength: 0,
          securityState: 'unknown'
        };
        var event = {
          requestId: requestId,
          frameId: '1',
          loaderId: '1',
          timestamp: JSInspector.getTimestamp(),
          type: 'Other',
          response: response
        };

        this._agent.sendEvent('responseReceived', event);
      }
    }, {
      key: "dataReceived",
      value: function dataReceived(id, data) {
        var requestId = String(id);
        var existingData = this._requests.get(requestId) || '';

        this._requests.set(requestId, existingData.concat(data));

        var event = {
          requestId: requestId,
          timestamp: JSInspector.getTimestamp(),
          dataLength: data.length,
          encodedDataLength: data.length
        };

        this._agent.sendEvent('dataReceived', event);
      }
    }, {
      key: "loadingFinished",
      value: function loadingFinished(id, encodedDataLength) {
        var event = {
          requestId: String(id),
          timestamp: JSInspector.getTimestamp(),
          encodedDataLength: encodedDataLength
        };

        this._agent.sendEvent('loadingFinished', event);
      }
    }, {
      key: "loadingFailed",
      value: function loadingFailed(id, error) {
        var event = {
          requestId: String(id),
          timestamp: JSInspector.getTimestamp(),
          type: 'Other',
          errorText: error
        };

        this._agent.sendEvent('loadingFailed', event);
      }
    }, {
      key: "_getMimeType",
      value: function _getMimeType(headers) {
        var contentType = headers['Content-Type'] || '';
        return contentType.split(';')[0];
      }
    }]);

    return Interceptor;
  }();

  var NetworkAgent = function (_InspectorAgent) {
    _inherits(NetworkAgent, _InspectorAgent);

    var _super = _createSuper(NetworkAgent);

    function NetworkAgent() {
      _classCallCheck(this, NetworkAgent);

      return _super.apply(this, arguments);
    }

    _createClass(NetworkAgent, [{
      key: "enable",
      value: function enable(_ref) {
        var maxResourceBufferSize = _ref.maxResourceBufferSize,
            maxTotalBufferSize = _ref.maxTotalBufferSize;
        this._interceptor = new Interceptor(this);
        XMLHttpRequest.setInterceptor(this._interceptor);
      }
    }, {
      key: "disable",
      value: function disable() {
        XMLHttpRequest.setInterceptor(null);
        this._interceptor = null;
      }
    }, {
      key: "getResponseBody",
      value: function getResponseBody(_ref2) {
        var requestId = _ref2.requestId;
        return {
          body: this.interceptor().getData(requestId),
          base64Encoded: false
        };
      }
    }, {
      key: "interceptor",
      value: function interceptor() {
        if (this._interceptor) {
          return this._interceptor;
        } else {
          throw Error('_interceptor can not be null');
        }
      }
    }]);

    return NetworkAgent;
  }(InspectorAgent);

  NetworkAgent.DOMAIN = 'Network';
  module.exports = NetworkAgent;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_JSInspector_NetworkAgent.js",["node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_JSInspector_InspectorAgent.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_JSInspector_JSInspector.js","node_modules_react-native_Libraries_Network_XMLHttpRequest.js"],"node_modules/react-native/Libraries/JSInspector/NetworkAgent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var InspectorAgent = function () {
    function InspectorAgent(eventSender) {
      _classCallCheck(this, InspectorAgent);

      this._eventSender = eventSender;
    }

    _createClass(InspectorAgent, [{
      key: "sendEvent",
      value: function sendEvent(name, params) {
        this._eventSender(name, params);
      }
    }]);

    return InspectorAgent;
  }();

  module.exports = InspectorAgent;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_JSInspector_InspectorAgent.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js"],"node_modules/react-native/Libraries/JSInspector/InspectorAgent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = _$$_REQUIRE(_dependencyMap[0], "./cjs/scheduler-tracing.production.min.js");
  } else {
    module.exports = _$$_REQUIRE(_dependencyMap[1], "./cjs/scheduler-tracing.development.js");
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_tracing.js",["system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_cjs_scheduler-tracing.production.min.js","system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_cjs_scheduler-tracing.development.js"],"node_modules/scheduler/tracing.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v0.13.6
   * scheduler-tracing.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var b = 0;
  exports.__interactionsRef = null;
  exports.__subscriberRef = null;

  exports.unstable_clear = function (a) {
    return a();
  };

  exports.unstable_getCurrent = function () {
    return null;
  };

  exports.unstable_getThreadID = function () {
    return ++b;
  };

  exports.unstable_trace = function (a, d, c) {
    return c();
  };

  exports.unstable_wrap = function (a) {
    return a;
  };

  exports.unstable_subscribe = function () {};

  exports.unstable_unsubscribe = function () {};
},"system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_cjs_scheduler-tracing.production.min.js",[],"node_modules/scheduler/cjs/scheduler-tracing.production.min.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v0.13.6
   * scheduler-tracing.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      var enableSchedulerTracing = true;
      var DEFAULT_THREAD_ID = 0;
      var interactionIDCounter = 0;
      var threadIDCounter = 0;
      exports.__interactionsRef = null;
      exports.__subscriberRef = null;

      if (enableSchedulerTracing) {
        exports.__interactionsRef = {
          current: new Set()
        };
        exports.__subscriberRef = {
          current: null
        };
      }

      function unstable_clear(callback) {
        if (!enableSchedulerTracing) {
          return callback();
        }

        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = new Set();

        try {
          return callback();
        } finally {
          exports.__interactionsRef.current = prevInteractions;
        }
      }

      function unstable_getCurrent() {
        if (!enableSchedulerTracing) {
          return null;
        } else {
          return exports.__interactionsRef.current;
        }
      }

      function unstable_getThreadID() {
        return ++threadIDCounter;
      }

      function unstable_trace(name, timestamp, callback) {
        var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

        if (!enableSchedulerTracing) {
          return callback();
        }

        var interaction = {
          __count: 1,
          id: interactionIDCounter++,
          name: name,
          timestamp: timestamp
        };
        var prevInteractions = exports.__interactionsRef.current;
        var interactions = new Set(prevInteractions);
        interactions.add(interaction);
        exports.__interactionsRef.current = interactions;
        var subscriber = exports.__subscriberRef.current;
        var returnValue = void 0;

        try {
          if (subscriber !== null) {
            subscriber.onInteractionTraced(interaction);
          }
        } finally {
          try {
            if (subscriber !== null) {
              subscriber.onWorkStarted(interactions, threadID);
            }
          } finally {
            try {
              returnValue = callback();
            } finally {
              exports.__interactionsRef.current = prevInteractions;

              try {
                if (subscriber !== null) {
                  subscriber.onWorkStopped(interactions, threadID);
                }
              } finally {
                interaction.__count--;

                if (subscriber !== null && interaction.__count === 0) {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                }
              }
            }
          }
        }

        return returnValue;
      }

      function unstable_wrap(callback) {
        var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

        if (!enableSchedulerTracing) {
          return callback;
        }

        var wrappedInteractions = exports.__interactionsRef.current;
        var subscriber = exports.__subscriberRef.current;

        if (subscriber !== null) {
          subscriber.onWorkScheduled(wrappedInteractions, threadID);
        }

        wrappedInteractions.forEach(function (interaction) {
          interaction.__count++;
        });
        var hasRun = false;

        function wrapped() {
          var prevInteractions = exports.__interactionsRef.current;
          exports.__interactionsRef.current = wrappedInteractions;
          subscriber = exports.__subscriberRef.current;

          try {
            var returnValue = void 0;

            try {
              if (subscriber !== null) {
                subscriber.onWorkStarted(wrappedInteractions, threadID);
              }
            } finally {
              try {
                returnValue = callback.apply(undefined, arguments);
              } finally {
                exports.__interactionsRef.current = prevInteractions;

                if (subscriber !== null) {
                  subscriber.onWorkStopped(wrappedInteractions, threadID);
                }
              }
            }

            return returnValue;
          } finally {
            if (!hasRun) {
              hasRun = true;
              wrappedInteractions.forEach(function (interaction) {
                interaction.__count--;

                if (subscriber !== null && interaction.__count === 0) {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                }
              });
            }
          }
        }

        wrapped.cancel = function cancel() {
          subscriber = exports.__subscriberRef.current;

          try {
            if (subscriber !== null) {
              subscriber.onWorkCanceled(wrappedInteractions, threadID);
            }
          } finally {
            wrappedInteractions.forEach(function (interaction) {
              interaction.__count--;

              if (subscriber && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            });
          }
        };

        return wrapped;
      }

      var subscribers = null;

      if (enableSchedulerTracing) {
        subscribers = new Set();
      }

      function unstable_subscribe(subscriber) {
        if (enableSchedulerTracing) {
          subscribers.add(subscriber);

          if (subscribers.size === 1) {
            exports.__subscriberRef.current = {
              onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
              onInteractionTraced: onInteractionTraced,
              onWorkCanceled: onWorkCanceled,
              onWorkScheduled: onWorkScheduled,
              onWorkStarted: onWorkStarted,
              onWorkStopped: onWorkStopped
            };
          }
        }
      }

      function unstable_unsubscribe(subscriber) {
        if (enableSchedulerTracing) {
          subscribers.delete(subscriber);

          if (subscribers.size === 0) {
            exports.__subscriberRef.current = null;
          }
        }
      }

      function onInteractionTraced(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onInteractionTraced(interaction);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onInteractionScheduledWorkCompleted(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkScheduled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkScheduled(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkStarted(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkStarted(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkStopped(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkStopped(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkCanceled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkCanceled(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      exports.unstable_clear = unstable_clear;
      exports.unstable_getCurrent = unstable_getCurrent;
      exports.unstable_getThreadID = unstable_getThreadID;
      exports.unstable_trace = unstable_trace;
      exports.unstable_wrap = unstable_wrap;
      exports.unstable_subscribe = unstable_subscribe;
      exports.unstable_unsubscribe = unstable_unsubscribe;
    })();
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_cjs_scheduler-tracing.development.js",[],"node_modules/scheduler/cjs/scheduler-tracing.development.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v0.13.6
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      var enableSchedulerDebugging = false;
      var ImmediatePriority = 1;
      var UserBlockingPriority = 2;
      var NormalPriority = 3;
      var LowPriority = 4;
      var IdlePriority = 5;
      var maxSigned31BitInt = 1073741823;
      var IMMEDIATE_PRIORITY_TIMEOUT = -1;
      var USER_BLOCKING_PRIORITY = 250;
      var NORMAL_PRIORITY_TIMEOUT = 5000;
      var LOW_PRIORITY_TIMEOUT = 10000;
      var IDLE_PRIORITY = maxSigned31BitInt;
      var firstCallbackNode = null;
      var currentDidTimeout = false;
      var isSchedulerPaused = false;
      var currentPriorityLevel = NormalPriority;
      var currentEventStartTime = -1;
      var currentExpirationTime = -1;
      var isExecutingCallback = false;
      var isHostCallbackScheduled = false;
      var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

      function ensureHostCallbackIsScheduled() {
        if (isExecutingCallback) {
          return;
        }

        var expirationTime = firstCallbackNode.expirationTime;

        if (!isHostCallbackScheduled) {
          isHostCallbackScheduled = true;
        } else {
          cancelHostCallback();
        }

        _requestHostCallback(flushWork, expirationTime);
      }

      function flushFirstCallback() {
        var flushedNode = firstCallbackNode;
        var next = firstCallbackNode.next;

        if (firstCallbackNode === next) {
          firstCallbackNode = null;
          next = null;
        } else {
          var lastCallbackNode = firstCallbackNode.previous;
          firstCallbackNode = lastCallbackNode.next = next;
          next.previous = lastCallbackNode;
        }

        flushedNode.next = flushedNode.previous = null;
        var callback = flushedNode.callback;
        var expirationTime = flushedNode.expirationTime;
        var priorityLevel = flushedNode.priorityLevel;
        var previousPriorityLevel = currentPriorityLevel;
        var previousExpirationTime = currentExpirationTime;
        currentPriorityLevel = priorityLevel;
        currentExpirationTime = expirationTime;
        var continuationCallback;

        try {
          continuationCallback = callback();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
          currentExpirationTime = previousExpirationTime;
        }

        if (typeof continuationCallback === 'function') {
          var continuationNode = {
            callback: continuationCallback,
            priorityLevel: priorityLevel,
            expirationTime: expirationTime,
            next: null,
            previous: null
          };

          if (firstCallbackNode === null) {
            firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;
          } else {
            var nextAfterContinuation = null;
            var node = firstCallbackNode;

            do {
              if (node.expirationTime >= expirationTime) {
                nextAfterContinuation = node;
                break;
              }

              node = node.next;
            } while (node !== firstCallbackNode);

            if (nextAfterContinuation === null) {
              nextAfterContinuation = firstCallbackNode;
            } else if (nextAfterContinuation === firstCallbackNode) {
              firstCallbackNode = continuationNode;
              ensureHostCallbackIsScheduled();
            }

            var previous = nextAfterContinuation.previous;
            previous.next = nextAfterContinuation.previous = continuationNode;
            continuationNode.next = nextAfterContinuation;
            continuationNode.previous = previous;
          }
        }
      }

      function flushImmediateWork() {
        if (currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {
          isExecutingCallback = true;

          try {
            do {
              flushFirstCallback();
            } while (firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);
          } finally {
            isExecutingCallback = false;

            if (firstCallbackNode !== null) {
              ensureHostCallbackIsScheduled();
            } else {
              isHostCallbackScheduled = false;
            }
          }
        }
      }

      function flushWork(didTimeout) {
        if (enableSchedulerDebugging && isSchedulerPaused) {
          return;
        }

        isExecutingCallback = true;
        var previousDidTimeout = currentDidTimeout;
        currentDidTimeout = didTimeout;

        try {
          if (didTimeout) {
            while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {
              var currentTime = exports.unstable_now();

              if (firstCallbackNode.expirationTime <= currentTime) {
                do {
                  flushFirstCallback();
                } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));

                continue;
              }

              break;
            }
          } else {
            if (firstCallbackNode !== null) {
              do {
                if (enableSchedulerDebugging && isSchedulerPaused) {
                  break;
                }

                flushFirstCallback();
              } while (firstCallbackNode !== null && !shouldYieldToHost());
            }
          }
        } finally {
          isExecutingCallback = false;
          currentDidTimeout = previousDidTimeout;

          if (firstCallbackNode !== null) {
            ensureHostCallbackIsScheduled();
          } else {
            isHostCallbackScheduled = false;
          }

          flushImmediateWork();
        }
      }

      function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
          case LowPriority:
          case IdlePriority:
            break;

          default:
            priorityLevel = NormalPriority;
        }

        var previousPriorityLevel = currentPriorityLevel;
        var previousEventStartTime = currentEventStartTime;
        currentPriorityLevel = priorityLevel;
        currentEventStartTime = exports.unstable_now();

        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
          currentEventStartTime = previousEventStartTime;
          flushImmediateWork();
        }
      }

      function unstable_next(eventHandler) {
        var priorityLevel = void 0;

        switch (currentPriorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
            priorityLevel = NormalPriority;
            break;

          default:
            priorityLevel = currentPriorityLevel;
            break;
        }

        var previousPriorityLevel = currentPriorityLevel;
        var previousEventStartTime = currentEventStartTime;
        currentPriorityLevel = priorityLevel;
        currentEventStartTime = exports.unstable_now();

        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
          currentEventStartTime = previousEventStartTime;
          flushImmediateWork();
        }
      }

      function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function () {
          var previousPriorityLevel = currentPriorityLevel;
          var previousEventStartTime = currentEventStartTime;
          currentPriorityLevel = parentPriorityLevel;
          currentEventStartTime = exports.unstable_now();

          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
            currentEventStartTime = previousEventStartTime;
            flushImmediateWork();
          }
        };
      }

      function unstable_scheduleCallback(callback, deprecated_options) {
        var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();
        var expirationTime;

        if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {
          expirationTime = startTime + deprecated_options.timeout;
        } else {
          switch (currentPriorityLevel) {
            case ImmediatePriority:
              expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;
              break;

            case UserBlockingPriority:
              expirationTime = startTime + USER_BLOCKING_PRIORITY;
              break;

            case IdlePriority:
              expirationTime = startTime + IDLE_PRIORITY;
              break;

            case LowPriority:
              expirationTime = startTime + LOW_PRIORITY_TIMEOUT;
              break;

            case NormalPriority:
            default:
              expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;
          }
        }

        var newNode = {
          callback: callback,
          priorityLevel: currentPriorityLevel,
          expirationTime: expirationTime,
          next: null,
          previous: null
        };

        if (firstCallbackNode === null) {
          firstCallbackNode = newNode.next = newNode.previous = newNode;
          ensureHostCallbackIsScheduled();
        } else {
          var next = null;
          var node = firstCallbackNode;

          do {
            if (node.expirationTime > expirationTime) {
              next = node;
              break;
            }

            node = node.next;
          } while (node !== firstCallbackNode);

          if (next === null) {
            next = firstCallbackNode;
          } else if (next === firstCallbackNode) {
            firstCallbackNode = newNode;
            ensureHostCallbackIsScheduled();
          }

          var previous = next.previous;
          previous.next = next.previous = newNode;
          newNode.next = next;
          newNode.previous = previous;
        }

        return newNode;
      }

      function unstable_pauseExecution() {
        isSchedulerPaused = true;
      }

      function unstable_continueExecution() {
        isSchedulerPaused = false;

        if (firstCallbackNode !== null) {
          ensureHostCallbackIsScheduled();
        }
      }

      function unstable_getFirstCallbackNode() {
        return firstCallbackNode;
      }

      function unstable_cancelCallback(callbackNode) {
        var next = callbackNode.next;

        if (next === null) {
          return;
        }

        if (next === callbackNode) {
          firstCallbackNode = null;
        } else {
          if (callbackNode === firstCallbackNode) {
            firstCallbackNode = next;
          }

          var previous = callbackNode.previous;
          previous.next = next;
          next.previous = previous;
        }

        callbackNode.next = callbackNode.previous = null;
      }

      function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
      }

      function unstable_shouldYield() {
        return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());
      }

      var localDate = Date;
      var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
      var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
      var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;
      var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;
      var ANIMATION_FRAME_TIMEOUT = 100;
      var rAFID;
      var rAFTimeoutID;

      var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {
        rAFID = localRequestAnimationFrame(function (timestamp) {
          localClearTimeout(rAFTimeoutID);
          callback(timestamp);
        });
        rAFTimeoutID = localSetTimeout(function () {
          localCancelAnimationFrame(rAFID);
          callback(exports.unstable_now());
        }, ANIMATION_FRAME_TIMEOUT);
      };

      if (hasNativePerformanceNow) {
        var Performance = performance;

        exports.unstable_now = function () {
          return Performance.now();
        };
      } else {
        exports.unstable_now = function () {
          return localDate.now();
        };
      }

      var _requestHostCallback;

      var cancelHostCallback;
      var shouldYieldToHost;
      var globalValue = null;

      if (typeof window !== 'undefined') {
        globalValue = window;
      } else if (typeof global !== 'undefined') {
        globalValue = global;
      }

      if (globalValue && globalValue._schedMock) {
        var globalImpl = globalValue._schedMock;
        _requestHostCallback = globalImpl[0];
        cancelHostCallback = globalImpl[1];
        shouldYieldToHost = globalImpl[2];
        exports.unstable_now = globalImpl[3];
      } else if (typeof window === 'undefined' || typeof MessageChannel !== 'function') {
        var _callback = null;

        var _flushCallback = function _flushCallback(didTimeout) {
          if (_callback !== null) {
            try {
              _callback(didTimeout);
            } finally {
              _callback = null;
            }
          }
        };

        _requestHostCallback = function requestHostCallback(cb, ms) {
          if (_callback !== null) {
            setTimeout(_requestHostCallback, 0, cb);
          } else {
            _callback = cb;
            setTimeout(_flushCallback, 0, false);
          }
        };

        cancelHostCallback = function cancelHostCallback() {
          _callback = null;
        };

        shouldYieldToHost = function shouldYieldToHost() {
          return false;
        };
      } else {
        if (typeof console !== 'undefined') {
          if (typeof localRequestAnimationFrame !== 'function') {
            console.error("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
          }

          if (typeof localCancelAnimationFrame !== 'function') {
            console.error("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
          }
        }

        var scheduledHostCallback = null;
        var isMessageEventScheduled = false;
        var timeoutTime = -1;
        var isAnimationFrameScheduled = false;
        var isFlushingHostCallback = false;
        var frameDeadline = 0;
        var previousFrameTime = 33;
        var activeFrameTime = 33;

        shouldYieldToHost = function shouldYieldToHost() {
          return frameDeadline <= exports.unstable_now();
        };

        var channel = new MessageChannel();
        var port = channel.port2;

        channel.port1.onmessage = function (event) {
          isMessageEventScheduled = false;
          var prevScheduledCallback = scheduledHostCallback;
          var prevTimeoutTime = timeoutTime;
          scheduledHostCallback = null;
          timeoutTime = -1;
          var currentTime = exports.unstable_now();
          var didTimeout = false;

          if (frameDeadline - currentTime <= 0) {
            if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {
              didTimeout = true;
            } else {
              if (!isAnimationFrameScheduled) {
                isAnimationFrameScheduled = true;
                requestAnimationFrameWithTimeout(animationTick);
              }

              scheduledHostCallback = prevScheduledCallback;
              timeoutTime = prevTimeoutTime;
              return;
            }
          }

          if (prevScheduledCallback !== null) {
            isFlushingHostCallback = true;

            try {
              prevScheduledCallback(didTimeout);
            } finally {
              isFlushingHostCallback = false;
            }
          }
        };

        var animationTick = function animationTick(rafTime) {
          if (scheduledHostCallback !== null) {
            requestAnimationFrameWithTimeout(animationTick);
          } else {
            isAnimationFrameScheduled = false;
            return;
          }

          var nextFrameTime = rafTime - frameDeadline + activeFrameTime;

          if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
            if (nextFrameTime < 8) {
              nextFrameTime = 8;
            }

            activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
          } else {
            previousFrameTime = nextFrameTime;
          }

          frameDeadline = rafTime + activeFrameTime;

          if (!isMessageEventScheduled) {
            isMessageEventScheduled = true;
            port.postMessage(undefined);
          }
        };

        _requestHostCallback = function _requestHostCallback(callback, absoluteTimeout) {
          scheduledHostCallback = callback;
          timeoutTime = absoluteTimeout;

          if (isFlushingHostCallback || absoluteTimeout < 0) {
            port.postMessage(undefined);
          } else if (!isAnimationFrameScheduled) {
            isAnimationFrameScheduled = true;
            requestAnimationFrameWithTimeout(animationTick);
          }
        };

        cancelHostCallback = function cancelHostCallback() {
          scheduledHostCallback = null;
          isMessageEventScheduled = false;
          timeoutTime = -1;
        };
      }

      exports.unstable_ImmediatePriority = ImmediatePriority;
      exports.unstable_UserBlockingPriority = UserBlockingPriority;
      exports.unstable_NormalPriority = NormalPriority;
      exports.unstable_IdlePriority = IdlePriority;
      exports.unstable_LowPriority = LowPriority;
      exports.unstable_runWithPriority = unstable_runWithPriority;
      exports.unstable_next = unstable_next;
      exports.unstable_scheduleCallback = unstable_scheduleCallback;
      exports.unstable_cancelCallback = unstable_cancelCallback;
      exports.unstable_wrapCallback = unstable_wrapCallback;
      exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
      exports.unstable_shouldYield = unstable_shouldYield;
      exports.unstable_continueExecution = unstable_continueExecution;
      exports.unstable_pauseExecution = unstable_pauseExecution;
      exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
    })();
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_cjs_scheduler.development.js",[],"node_modules/scheduler/cjs/scheduler.development.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    NlpPath: true
  };
  Object.defineProperty(exports, "NlpPath", {
    enumerable: true,
    get: function get() {
      return _NlpPath.NlpPath;
    }
  });

  var _Eve = _$$_REQUIRE(_dependencyMap[0], "./Eve");

  Object.keys(_Eve).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _Eve[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _Eve[key];
      }
    });
  });

  var _AppManager = _$$_REQUIRE(_dependencyMap[1], "./src/robot/api/AppManager");

  Object.keys(_AppManager).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _AppManager[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _AppManager[key];
      }
    });
  });

  var _AppUpdateManager = _$$_REQUIRE(_dependencyMap[2], "./src/robot/api/AppUpdateManager");

  Object.keys(_AppUpdateManager).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _AppUpdateManager[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _AppUpdateManager[key];
      }
    });
  });

  var _RobotSettingApi = _$$_REQUIRE(_dependencyMap[3], "./src/robot/api/RobotSettingApi");

  Object.keys(_RobotSettingApi).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _RobotSettingApi[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _RobotSettingApi[key];
      }
    });
  });

  var _NlpPath = _$$_REQUIRE(_dependencyMap[4], "./src/nlp/path/NlpPath");
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts",["orionos-eve-core_Eve.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_AppManager.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_AppUpdateManager.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_RobotSettingApi.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_nlp_path_NlpPath.js"],"node_modules/orionos-eve-core/index.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  exports.DOMImplementation = window.DOMImplementation;
  exports.XMLSerializer = window.XMLSerializer;
  exports.DOMParser = window.DOMParser;
},"system_2d01160272669884793b18983a46dcd0_node_modules_roslib_src_util_shim_@xmldom_xmldom.js",[],"node_modules/roslib/src/util/shim/@xmldom/xmldom.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AppManager = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3], "react-native");

  var _Initial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "../../Initial"));

  var _Utils = _$$_REQUIRE(_dependencyMap[5], "../../utils/Utils");

  var appManager = _reactNative.NativeModules.AppManager;

  var AppManager = function () {
    function AppManager() {
      (0, _classCallCheck2.default)(this, AppManager);
    }

    (0, _createClass2.default)(AppManager, null, [{
      key: "getAppJson",
      value: function getAppJson() {
        if (this.appId) {
          if (_Initial.default.isSupportPlugin) {
            return appManager.getAppJsonByAppId(this.appId);
          } else {
            (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
            return '';
          }
        } else {
          try {
            return appManager.getAppJson();
          } catch (error) {
            (0, _Utils.newError)(error);
            return '';
          }
        }
      }
    }, {
      key: "getOpkPath",
      value: function getOpkPath() {
        if (this.appId) {
          if (_Initial.default.isSupportPlugin) {
            return appManager.getOpkPathByAppId(this.appId);
          } else {
            (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
            return '';
          }
        } else {
          try {
            return appManager.getOpkPath();
          } catch (error) {
            (0, _Utils.newError)(error);
            return '';
          }
        }
      }
    }, {
      key: "getOpkExtraPath",
      value: function getOpkExtraPath() {
        if (this.appId) {
          if (_Initial.default.isSupportPlugin) {
            return appManager.getOpkExtraPathByAppId(this.appId);
          } else {
            (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
            return '';
          }
        } else {
          try {
            return appManager.getOpkExtraPath();
          } catch (error) {
            (0, _Utils.newError)(error);
            return '';
          }
        }
      }
    }, {
      key: "getAppId",
      value: function getAppId() {
        if (this.appId) {
          return this.appId;
        }

        if (_Initial.default.isSupportAppId) {
          try {
            var appJson = AppManager.getAppJson();

            if (appJson) {
              return JSON.parse(appJson).appid;
            }

            (0, _Utils.newWarn)('getAppId AppJson error');
            return '';
          } catch (error) {
            (0, _Utils.newWarn)(error);
            return '';
          }
        }

        return '';
      }
    }, {
      key: "getAppIcon",
      value: function getAppIcon() {
        if (_Initial.default.isSupportPlugin) {
          return appManager.getAppIcon(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return '';
        }
      }
    }, {
      key: "getAppConfig",
      value: function getAppConfig() {
        if (_Initial.default.isSupportPlugin) {
          return appManager.getAppConfig(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return '';
        }
      }
    }, {
      key: "setAppConfig",
      value: function setAppConfig(key, value) {
        if (_Initial.default.isSupportConfigUpdateNotify && this.appId) {
          appManager.setAppConfig(this.appId, key, value);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
        }
      }
    }, {
      key: "setConfigUpdateListener",
      value: function setConfigUpdateListener(onConfigUpdate) {
        if (_Initial.default.isSupportConfigUpdateNotify && this.appId) {
          if (this.configUpdate) {
            this.configUpdate.remove();
          }

          this.configUpdate = _reactNative.DeviceEventEmitter.addListener('configUpdate_' + this.appId, function (data) {
            var config = JSON.parse(data);
            onConfigUpdate(config);
          });
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return '';
        }
      }
    }, {
      key: "setSystemConfigUpdateListener",
      value: function setSystemConfigUpdateListener(onConfigUpdate) {
        var systemId = this.getSystemId();

        if (_Initial.default.isSupportConfigUpdateNotify && systemId) {
          if (this.systemConfigUpdate) {
            this.systemConfigUpdate.remove();
          }

          this.systemConfigUpdate = _reactNative.DeviceEventEmitter.addListener('configUpdate_' + systemId, function (data) {
            var config = JSON.parse(data);
            onConfigUpdate(config);
          });
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return '';
        }
      }
    }, {
      key: "getSystemId",
      value: function getSystemId() {
        if (_Initial.default.isSupportSystemId) {
          return appManager.getSystemId();
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return '';
        }
      }
    }, {
      key: "restartApp",
      value: function restartApp() {
        if (_Initial.default.isSupportPlugin) {
          appManager.restartApp(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
        }
      }
    }, {
      key: "startApp",
      value: function startApp(appId) {
        if (_Initial.default.isSupportNlpParser) {
          appManager.startApp(appId);
        } else {
          var msg = 'The device does not support startApp API.';
          (0, _Utils.newError)(msg);
        }
      }
    }, {
      key: "destroyApp",
      value: function destroyApp(appId) {
        if (_Initial.default.isSupportNlpParser) {
          appManager.destroyApp(appId);
        } else {
          var msg = 'The device does not support destroyApp API.';
          (0, _Utils.newWarn)(msg);
        }
      }
    }, {
      key: "moveToForeground",
      value: function moveToForeground(appId) {
        if (_Initial.default.isSupportNlpParser) {
          appManager.moveToForeground(appId);
        } else {
          var msg = 'The device does not support moveToForeground API.';
          (0, _Utils.newWarn)(msg);
        }
      }
    }, {
      key: "moveToBack",
      value: function moveToBack(appId) {
        if (_Initial.default.isSupportNlpParser) {
          appManager.moveToBack(appId);
        } else {
          var msg = 'The device does not support moveToBack API.';
          (0, _Utils.newWarn)(msg);
        }
      }
    }, {
      key: "setAppPath",
      value: function setAppPath(appId, path) {
        if (_Initial.default.isSupportNlpParser) {
          appManager.setAppPath(appId, path);
        } else {
          var msg = 'The device does not support setAppPath API.';
          (0, _Utils.newError)(msg);
        }
      }
    }, {
      key: "setAppVersion",
      value: function setAppVersion(appId, version) {
        var msg = 'The device does not support setAppVersion API.';
        (0, _Utils.newWarn)(msg);
      }
    }, {
      key: "setAppInfo",
      value: function setAppInfo(appId, path, subPage, version) {
        if (_Initial.default.isSupportNlpParser) {
          if (appId) {
            appManager.setAsyncCustomNlpData('opt_scene_switch', JSON.stringify({
              app_id: appId,
              path: path == undefined ? '' : path,
              subPage: subPage == undefined ? '' : subPage,
              version: version == undefined ? '' : version
            }));
          } else {
            var msg = 'nlp_launcher_:setAppInfo appId is null';
            (0, _Utils.newError)(msg);
          }
        } else {
          var _msg = 'The device does not support setAsyncCustomNlpData API.';
          (0, _Utils.newError)(_msg);
        }
      }
    }]);
    return AppManager;
  }();

  exports.AppManager = AppManager;
  AppManager.appId = null;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_AppManager.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","orionos-eve-core_src_Initial.ts","orionos-eve-core_src_utils_Utils.ts"],"node_modules/orionos-eve-core/src/robot/api/AppManager.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TriggerType = exports.Trigger = void 0;

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _Crash = _$$_REQUIRE(_dependencyMap[3], "./utils/Crash");

  var _NativeApi = _$$_REQUIRE(_dependencyMap[4], "./robot/api/NativeApi");

  var _EmojiPlayerModel = _$$_REQUIRE(_dependencyMap[5], "./models/EmojiPlayerModel");

  var _NlpScene = _$$_REQUIRE(_dependencyMap[6], "./nlp/scene/NlpScene");

  var _TriggerManager = _$$_REQUIRE(_dependencyMap[7], "./TriggerManager");

  var TriggerType;
  exports.TriggerType = TriggerType;

  (function (TriggerType) {
    TriggerType[TriggerType["api"] = 1] = "api";
    TriggerType[TriggerType["voice"] = 2] = "voice";
    TriggerType[TriggerType["ui"] = 3] = "ui";
    TriggerType[TriggerType["deepLink"] = 4] = "deepLink";
  })(TriggerType || (exports.TriggerType = TriggerType = {}));

  var Trigger = (0, _createClass2.default)(function Trigger(channel) {
    var _this = this;

    (0, _classCallCheck2.default)(this, Trigger);
    this.appId = null;

    this.getChannel = function () {
      return _this._channel;
    };

    this.dispatch = function (data) {
      data.eventId = data.eventId || -1;

      _this.trigger(data);
    };

    this.goBack = function (data) {
      if (_TriggerManager.triggerManager.type === _TriggerManager.TriggerNavigate.stackNavigate) {
        _TriggerManager.triggerManager.getNavigation().goBack();

        return;
      }

      var stackInfo = _TriggerManager.triggerManager.popRouteName();

      if (stackInfo) {
        data.result = stackInfo.protocol && stackInfo.protocol.result;
        data.goBack = true;

        _this._trigger(stackInfo.name, data);
      }
    };

    this._trigger = function (router, data) {
      var goBack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var navigation = _TriggerManager.triggerManager.getNavigation();

      var current = navigation.state;
      data.channel = current.routeName;
      console.log('caller: ', _this._channel, current, data);

      _Crash.Crash.putCurrentScenesState({
        Name: router
      });

      _NlpScene.NlpScene.switchScene(router);

      if (_TriggerManager.triggerManager.middleware) {
        _TriggerManager.triggerManager.middleware(current.routeName, router, data);
      }

      if (_TriggerManager.triggerManager.type === _TriggerManager.TriggerNavigate.replaceNavigate) {
        navigation.replace(router, data);
      } else {
        navigation.navigate(router, data);
      }

      if (data.goBack !== true) {
        if (data.channel !== router) {
          var existRoute = _TriggerManager.triggerManager.isRouteExistInStack(router);

          if (existRoute) {
            _TriggerManager.triggerManager.popTo(router);
          } else {
            if (data.putStack !== false) {
              _TriggerManager.triggerManager.pushRouteName(data.channel, data);
            }
          }
        }
      }

      _this.navSwitch(data.channel, router);
    };

    this.stopTTS = function () {
      _NativeApi.speechApi.stopTTS();
    };

    this.playTextWithEmoji = function (listenerId, text) {
      _EmojiPlayerModel.emojiPlayerModel.setShow(true);

      _NativeApi.speechApi.playText(listenerId, text);
    };

    if (this.appId) {
      this._channel = this.appId + '_' + channel;
    } else {
      this._channel = channel;
    }

    _TriggerManager.triggerManager.addTrigger(this);
  });
  exports.Trigger = Trigger;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_Trigger.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_classCallCheck.js","orionos-eve-core_src_utils_Crash.ts","orionos-eve-core_src_robot_api_NativeApi.ts","orionos-eve-core_src_models_EmojiPlayerModel.ts","orionos-eve-core_src_nlp_scene_NlpScene.ts","orionos-eve-core_src_TriggerManager.ts"],"node_modules/orionos-eve-core/src/Trigger.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MsgPushType = exports.MsgPushManager = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3], "react-native");

  var _ = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4], "lodash"));

  var _Utils = _$$_REQUIRE(_dependencyMap[5], "../../utils/Utils");

  var _Initial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "../../Initial"));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var messagePushApi = _reactNative.NativeModules.MsgPushManager;
  var MsgPushType;
  exports.MsgPushType = MsgPushType;

  (function (MsgPushType) {
    MsgPushType[MsgPushType["APP_OBTAIN"] = 1] = "APP_OBTAIN";
    MsgPushType[MsgPushType["BOOT_RECOMMEND"] = 2] = "BOOT_RECOMMEND";
    MsgPushType[MsgPushType["OTA_RECOMMEND"] = 3] = "OTA_RECOMMEND";
  })(MsgPushType || (exports.MsgPushType = MsgPushType = {}));

  var MsgPushManager = function () {
    function MsgPushManager() {
      (0, _classCallCheck2.default)(this, MsgPushManager);
    }

    (0, _createClass2.default)(MsgPushManager, null, [{
      key: "getMessages",
      value: function getMessages() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MsgPushType.APP_OBTAIN;
        var appId = arguments.length > 1 ? arguments[1] : undefined;
        var appPath = arguments.length > 2 ? arguments[2] : undefined;

        if (_Initial.default.msgControlVer > 0) {
          return messagePushApi.getMessages(type, appId, appPath);
        } else {
          (0, _Utils.newError)('Your ModuleApp do not support getMessages');
          return '';
        }
      }
    }, {
      key: "getMessageContent",
      value: function getMessageContent(msgId) {
        if (_Initial.default.msgControlVer > 0) {
          return messagePushApi.getMessageContent(msgId);
        } else {
          (0, _Utils.newError)('Your ModuleApp do not support getMessageContent');
          return '';
        }
      }
    }, {
      key: "getDetail",
      value: function getDetail(detailId) {
        if (_Initial.default.msgControlVer > 1) {
          return messagePushApi.getDetail(detailId);
        } else {
          (0, _Utils.newError)('Your ModuleApp do not support getDetail');
          return '';
        }
      }
    }, {
      key: "increaseDetailPlayTimes",
      value: function increaseDetailPlayTimes(detailId) {
        if (_Initial.default.msgControlVer > 1) {
          messagePushApi.increaseDetailPlayTimes(detailId);
        } else {
          (0, _Utils.newError)('Your ModuleApp do not support increaseDetailPlayTimes');
        }
      }
    }, {
      key: "deleteDetail",
      value: function deleteDetail(detailId) {
        if (_Initial.default.msgControlVer > 1) {
          messagePushApi.deleteDetail(detailId);
        } else {
          (0, _Utils.newError)('Your ModuleApp do not support deleteDetail');
        }
      }
    }, {
      key: "registerMsgChanged",
      value: function registerMsgChanged(callbackId, type, appId, appPath) {
        if (_Initial.default.msgControlVer > 0) {
          if (!_.isNumber(callbackId) || callbackId < 0) {
            (0, _Utils.newError)('MsgPushListener callbackId must be validate.');
          } else {
            messagePushApi.registerMsgChanged(callbackId, type, appId, appPath);
          }
        } else {
          (0, _Utils.newError)('Your ModuleApp do not support monitor msg push changes.');
        }
      }
    }, {
      key: "unregisterMsgChanged",
      value: function unregisterMsgChanged(callbackId) {
        if (_Initial.default.msgControlVer > 0) {
          if (!_.isNumber(callbackId) || callbackId < 0) {
            (0, _Utils.newError)('MsgPushListener callbackId must be validate.');
          } else {
            messagePushApi.unregisterMsgChanged(callbackId);
          }
        } else {
          (0, _Utils.newError)('Your ModuleApp do not support monitor msg push changes.');
        }
      }
    }]);
    return MsgPushManager;
  }();

  exports.MsgPushManager = MsgPushManager;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_MsgPushManager.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","node_modules_lodash_lodash.js","orionos-eve-core_src_utils_Utils.ts","orionos-eve-core_src_Initial.ts"],"node_modules/orionos-eve-core/src/robot/api/MsgPushManager.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BaseViewModel = void 0;

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3], "react-native");

  var _Trigger = _$$_REQUIRE(_dependencyMap[4], "./Trigger");

  var _RecognitionModel = _$$_REQUIRE(_dependencyMap[5], "./models/RecognitionModel");

  var _EmojiPlayerModel = _$$_REQUIRE(_dependencyMap[6], "./models/EmojiPlayerModel");

  var _FaceParticleModel = _$$_REQUIRE(_dependencyMap[7], "./models/FaceParticleModel");

  var BaseViewModel = (0, _createClass2.default)(function BaseViewModel(channel) {
    var _this = this;

    (0, _classCallCheck2.default)(this, BaseViewModel);
    this.recognitionStore = _RecognitionModel.recognitionModel;
    this.emojiPlayerStore = _EmojiPlayerModel.emojiPlayerModel;
    this.faceParticleStore = _FaceParticleModel.faceParticleModel;
    this.appId = null;

    this.setVoice = function (voice) {
      _this._voice = voice;
      _this._voice && _this._voice.start();
      return _this;
    };

    this.setSpeakInfoMap = function (speakInfoMap) {
      if (_this._voice) {
        _this._voice.setSpeakInfoMap(speakInfoMap);
      }
    };

    this.updateSpeakInfo = function (speakInfo) {
      if (_this._voice) {
        _this._voice.updateSpeakInfo(speakInfo);
      }
    };

    this.setView = function (view) {
      _this._view = view;
      return _this;
    };

    this.getChannel = function () {
      return _this._channel;
    };

    this._trigger = function (type, eventId, data) {
      var protocol = {
        channel: _this._channel,
        eventId: eventId,
        type: type,
        result: data
      };
      console.log('trigger: ', protocol);

      _reactNative.DeviceEventEmitter.emit('__trigger__', protocol);
    };

    this._uiTrigger = function (eventId, data) {
      _this._trigger(_Trigger.TriggerType.ui, eventId, data);
    };

    this._voiceTrigger = function (eventId, data, queryType) {
      if (queryType === 2) {
        _this._trigger(_Trigger.TriggerType.ui, eventId, data);
      } else {
        _this._trigger(_Trigger.TriggerType.voice, eventId, data);
      }
    };

    this._apiTrigger = function (eventId, data) {
      _this._trigger(_Trigger.TriggerType.api, eventId, data);
    };

    this.start = function () {
      if (_this.status === 'stop') {
        _this.status = 'start';
        _this._voice && _this._voice.start();

        _this.onStart();
      }
    };

    this.stop = function () {
      if (_this.status === 'start') {
        _this.status = 'stop';
        _this._voice && _this._voice.stop();

        _this.onStop();

        _this._voice = undefined;
        _this._view = undefined;
      }
    };

    this.showEmojiPlayer = function () {
      _this.emojiPlayerStore.setShow(true);
    };

    this.hideEmojiPlayer = function () {
      _this.emojiPlayerStore.setShow(false);
    };

    this.startEmojiTalk = function () {
      _this.emojiPlayerStore.setTalk(true);
    };

    this.stopEmojiTalk = function () {
      _this.emojiPlayerStore.setTalk(false);
    };

    this.showRecognition = function () {
      _this.recognitionStore.setShow(true);
    };

    this.hideRecognition = function () {
      _this.recognitionStore.setShow(false);
    };

    this.showFaceParticle = function () {
      _this.faceParticleStore.setHide(false);
    };

    this.hideFaceParticle = function () {
      _this.faceParticleStore.setHide(true);
    };

    this.showEyeCenter = function () {
      _this.faceParticleStore.setShowCenter(true);
    };

    this.showEyeLeft = function () {
      _this.faceParticleStore.setShowCenter(false);
    };

    this.showBackgroundStar = function () {
      _this.faceParticleStore.setShowStar(true);
    };

    this.hideBackgroundStar = function () {
      _this.faceParticleStore.setShowStar(false);
    };

    if (this.appId) {
      this._channel = this.appId + '_' + channel;
    } else {
      this._channel = channel;
    }

    this.status = 'stop';
  });
  exports.BaseViewModel = BaseViewModel;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_BaseViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_Trigger.ts","orionos-eve-core_src_models_RecognitionModel.ts","orionos-eve-core_src_models_EmojiPlayerModel.ts","orionos-eve-core_src_models_FaceParticleModel.ts"],"node_modules/orionos-eve-core/src/BaseViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationTransferComponent = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _BaseRobotComponent2 = _$$_REQUIRE(_dependencyMap[6], "./BaseRobotComponent");

  var _Utils = _$$_REQUIRE(_dependencyMap[7], "../../utils/Utils");

  var _Initial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../../Initial"));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var sprintf = _$$_REQUIRE(_dependencyMap[9], "sprintf-js").sprintf;

  var COMPONENT_NATIVE_BRIDGE_NAME = 'NavigationTransfer';

  var NavigationTransferComponent = function (_BaseRobotComponent) {
    (0, _inherits2.default)(NavigationTransferComponent, _BaseRobotComponent);

    var _super = _createSuper(NavigationTransferComponent);

    function NavigationTransferComponent(props) {
      var _this;

      (0, _classCallCheck2.default)(this, NavigationTransferComponent);
      _this = _super.call(this, props);

      if (_Initial.default.multiRobotNavigationVer <= 0) {
        (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
      }

      return _this;
    }

    (0, _createClass2.default)(NavigationTransferComponent, [{
      key: "getComponentParam",
      value: function getComponentParam() {
        return this.props.param;
      }
    }, {
      key: "generateComponentInfo",
      value: function generateComponentInfo() {
        return new _BaseRobotComponent2.RobotComponentInfo(COMPONENT_NATIVE_BRIDGE_NAME, (0, _Utils.getuuid)(), true, true, true, [_BaseRobotComponent2.ResouceType.Navigation]);
      }
    }]);
    return NavigationTransferComponent;
  }(_BaseRobotComponent2.BaseRobotComponent);

  exports.NavigationTransferComponent = NavigationTransferComponent;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_components_NavigationTransferComponent.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","orionos-eve-core_src_robot_components_BaseRobotComponent.tsx","orionos-eve-core_src_utils_Utils.ts","orionos-eve-core_src_Initial.ts","node_modules_sprintf-js_src_sprintf.js"],"node_modules/orionos-eve-core/src/robot/components/NavigationTransferComponent.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationCheckComponent = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _BaseRobotComponent2 = _$$_REQUIRE(_dependencyMap[6], "./BaseRobotComponent");

  var _Utils = _$$_REQUIRE(_dependencyMap[7], "../../utils/Utils");

  var _Initial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../../Initial"));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var sprintf = _$$_REQUIRE(_dependencyMap[9], "sprintf-js").sprintf;

  var COMPONENT_NATIVE_BRIDGE_NAME = 'NavigationCheck';

  var NavigationCheckComponent = function (_BaseRobotComponent) {
    (0, _inherits2.default)(NavigationCheckComponent, _BaseRobotComponent);

    var _super = _createSuper(NavigationCheckComponent);

    function NavigationCheckComponent(props) {
      var _this;

      (0, _classCallCheck2.default)(this, NavigationCheckComponent);
      _this = _super.call(this, props);

      if (_Initial.default.multiRobotNavigationVer <= 0) {
        (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
      }

      return _this;
    }

    (0, _createClass2.default)(NavigationCheckComponent, [{
      key: "getComponentParam",
      value: function getComponentParam() {
        return this.props.param;
      }
    }, {
      key: "generateComponentInfo",
      value: function generateComponentInfo() {
        return new _BaseRobotComponent2.RobotComponentInfo(COMPONENT_NATIVE_BRIDGE_NAME, (0, _Utils.getuuid)(), true, true, false, [_BaseRobotComponent2.ResouceType.Navigation]);
      }
    }]);
    return NavigationCheckComponent;
  }(_BaseRobotComponent2.BaseRobotComponent);

  exports.NavigationCheckComponent = NavigationCheckComponent;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_components_NavigationCheckComponent.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","orionos-eve-core_src_robot_components_BaseRobotComponent.tsx","orionos-eve-core_src_utils_Utils.ts","orionos-eve-core_src_Initial.ts","node_modules_sprintf-js_src_sprintf.js"],"node_modules/orionos-eve-core/src/robot/components/NavigationCheckComponent.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.RobotMapManager = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3], "react-native");

  var _Initial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "../../Initial"));

  var _Utils = _$$_REQUIRE(_dependencyMap[5], "../../utils/Utils");

  var robotMapManager = _reactNative.NativeModules.MapManager;

  var RobotMapManager = function () {
    function RobotMapManager() {
      (0, _classCallCheck2.default)(this, RobotMapManager);
    }

    (0, _createClass2.default)(RobotMapManager, null, [{
      key: "t9Search",
      value: function t9Search(query) {
        if (_Initial.default.mapControlVer > 0) {
          return robotMapManager.t9Search(query);
        } else {
          var msg = 'The device does not support t9Search API.';
          (0, _Utils.newError)(msg);
          return '';
        }
      }
    }]);
    return RobotMapManager;
  }();

  exports.RobotMapManager = RobotMapManager;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_RobotMapManager.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","orionos-eve-core_src_Initial.ts","orionos-eve-core_src_utils_Utils.ts"],"node_modules/orionos-eve-core/src/robot/api/RobotMapManager.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TaskEvent = void 0;

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var TaskEvent = (0, _createClass2.default)(function TaskEvent(taskId, taskData, eventType, eventData, subTaskId, subTaskType, subTaskData, isCreateOnStart) {
    (0, _classCallCheck2.default)(this, TaskEvent);
    this.taskId = taskId;
    this.taskData = taskData;
    this.eventType = eventType;
    this.eventData = eventData;
    this.subTaskId = subTaskId;
    this.subTaskType = subTaskType;
    this.subTaskData = subTaskData;
    this.isCreateOnStart = isCreateOnStart;
    this.taskId = taskId;
    this.taskData = taskData;
    this.eventType = eventType;
    this.eventData = eventData;
    this.subTaskId = subTaskId;
    this.subTaskType = subTaskType;
    this.subTaskData = subTaskData;
    this.isCreateOnStart = isCreateOnStart;
  });
  exports.TaskEvent = TaskEvent;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_definition_RobotApiParam.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_classCallCheck.js"],"node_modules/orionos-eve-core/src/robot/api/definition/RobotApiParam.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MsgPushListener = void 0;

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _assertThisInitialized2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/assertThisInitialized"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _get2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/get"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/getPrototypeOf"));

  var _BaseListener2 = _$$_REQUIRE(_dependencyMap[8], "./BaseListener");

  var _ListenerManager = _$$_REQUIRE(_dependencyMap[9], "../ListenerManager");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var MsgPushListener = function (_BaseListener) {
    (0, _inherits2.default)(MsgPushListener, _BaseListener);

    var _super = _createSuper(MsgPushListener);

    function MsgPushListener() {
      var _thisSuper, _this;

      (0, _classCallCheck2.default)(this, MsgPushListener);
      _this = _super.call(this, _ListenerManager.listenersManager.msgPushListenerManager);

      _this.onMsgChanged = function (callback) {
        (0, _get2.default)((_thisSuper = (0, _assertThisInitialized2.default)(_this), (0, _getPrototypeOf2.default)(MsgPushListener.prototype)), "addListener", _thisSuper).call(_thisSuper, MsgPushListener.EVENT_ON_MSG_CHANGED, callback);
      };

      return _this;
    }

    return (0, _createClass2.default)(MsgPushListener);
  }(_BaseListener2.BaseListener);

  exports.MsgPushListener = MsgPushListener;
  MsgPushListener.EVENT_ON_MSG_CHANGED = 'onMsgPushChanged';
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_listener_MsgPushListener.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_assertThisInitialized.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_get.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","orionos-eve-core_src_robot_listener_BaseListener.ts","orionos-eve-core_src_robot_ListenerManager.ts"],"node_modules/orionos-eve-core/src/robot/listener/MsgPushListener.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AppUpdateManager = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3], "react-native");

  var _Initial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "../../Initial"));

  var _Utils = _$$_REQUIRE(_dependencyMap[5], "../../utils/Utils");

  var updateManager = _reactNative.NativeModules.AppUpdateManager;

  var AppUpdateManager = function () {
    function AppUpdateManager() {
      (0, _classCallCheck2.default)(this, AppUpdateManager);
    }

    (0, _createClass2.default)(AppUpdateManager, null, [{
      key: "isInitInstall",
      value: function isInitInstall() {
        if (_Initial.default.isSupportPlugin) {
          return updateManager.isInitInstall(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return false;
        }
      }
    }, {
      key: "isUpdating",
      value: function isUpdating() {
        if (_Initial.default.isSupportPlugin) {
          return updateManager.isUpdating(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return false;
        }
      }
    }, {
      key: "checkUpdate",
      value: function checkUpdate() {
        if (_Initial.default.isSupportPlugin) {
          return updateManager.checkUpdate(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return false;
        }
      }
    }, {
      key: "setUpdateEnable",
      value: function setUpdateEnable(enable) {
        if (_Initial.default.isSupportDisableUpdate) {
          updateManager.setUpdateEnable(this.appId, enable);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
        }
      }
    }, {
      key: "setUpdateListener",
      value: function setUpdateListener(updateStatus, updateResult) {
        if (!_Initial.default.isSupportPlugin) {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
          return;
        }

        if (this.updateProgress) {
          this.updateProgress.remove();
        }

        this.updateProgress = _reactNative.DeviceEventEmitter.addListener('updateProgress', function (data) {
          var status = JSON.parse(data);
          updateStatus(status.count, status.index, status.appName, status.oper);
        });

        if (this.updateResult) {
          this.updateResult.remove();
        }

        this.updateResult = _reactNative.DeviceEventEmitter.addListener('updateResult', function (data) {
          var result = JSON.parse(data);
          updateResult(result.result, result.message);
        });
        updateManager.setUpdateListener();
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        if (_Initial.default.isSupportPlugin) {
          updateManager.startUpdate(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
        }
      }
    }, {
      key: "retryUpdate",
      value: function retryUpdate() {
        if (_Initial.default.isSupportPlugin) {
          updateManager.retryUpdate(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
        }
      }
    }, {
      key: "cancelUpdate",
      value: function cancelUpdate() {
        if (_Initial.default.isSupportPlugin) {
          updateManager.cancelUpdate(this.appId);
        } else {
          (0, _Utils.newError)(_Utils.DEV_ERROR_SUPPORT);
        }
      }
    }]);
    return AppUpdateManager;
  }();

  exports.AppUpdateManager = AppUpdateManager;
  AppUpdateManager.appId = null;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_AppUpdateManager.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","orionos-eve-core_src_Initial.ts","orionos-eve-core_src_utils_Utils.ts"],"node_modules/orionos-eve-core/src/robot/api/AppUpdateManager.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.RobotSettingApi = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3], "react-native");

  var _Initial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "../../Initial"));

  var _Utils = _$$_REQUIRE(_dependencyMap[5], "../../utils/Utils");

  var robotSettingApi = _reactNative.NativeModules.RobotSettingApi;

  var RobotSettingApi = function () {
    function RobotSettingApi() {
      (0, _classCallCheck2.default)(this, RobotSettingApi);
    }

    (0, _createClass2.default)(RobotSettingApi, null, [{
      key: "getRobotString",
      value: function getRobotString(key) {
        if (_Initial.default.isSupportRobotSettingApi) {
          return robotSettingApi.getRobotString(key);
        } else {
          var msg = 'This system version does not support getRobotString.';
          (0, _Utils.newError)(msg);
          return Promise.reject(msg);
        }
      }
    }, {
      key: "getRobotFloat",
      value: function getRobotFloat(key) {
        if (_Initial.default.isSupportRobotSettingApi) {
          return robotSettingApi.getRobotFloat(key);
        } else {
          var msg = 'This system version does not support getRobotFloat.';
          (0, _Utils.newError)(msg);
          return Promise.reject(msg);
        }
      }
    }, {
      key: "getRobotInt",
      value: function getRobotInt(key) {
        if (_Initial.default.isSupportRobotSettingApi) {
          return robotSettingApi.getRobotInt(key);
        } else {
          var msg = 'This system version does not support getRobotInt.';
          (0, _Utils.newError)(msg);
          return Promise.reject(msg);
        }
      }
    }, {
      key: "setRobotString",
      value: function setRobotString(key, value) {
        if (_Initial.default.isSupportRobotSettingApi) {
          if (this.appId && _Initial.default.isSupportRobotSettingPermission) {
            robotSettingApi.setRobotString(this.appId, key, value);
          } else {
            robotSettingApi.setRobotString(key, value);
          }
        } else {
          (0, _Utils.newError)('This system version does not support setRobotString.');
        }
      }
    }, {
      key: "setRobotFloat",
      value: function setRobotFloat(key, value) {
        if (_Initial.default.isSupportRobotSettingApi) {
          if (this.appId && _Initial.default.isSupportRobotSettingPermission) {
            robotSettingApi.setRobotFloat(this.appId, key, value);
          } else {
            robotSettingApi.setRobotFloat(key, value);
          }
        } else {
          (0, _Utils.newError)('This system version does not support setRobotFloat.');
        }
      }
    }, {
      key: "setRobotInt",
      value: function setRobotInt(key, value) {
        if (_Initial.default.isSupportRobotSettingApi) {
          if (this.appId && _Initial.default.isSupportRobotSettingPermission) {
            robotSettingApi.setRobotInt(this.appId, key, value);
          } else {
            robotSettingApi.setRobotInt(key, value);
          }
        } else {
          (0, _Utils.newError)('This system version does not support setRobotInt.');
        }
      }
    }, {
      key: "registerRobotSettingListener",
      value: function registerRobotSettingListener(callbackId, keys) {
        if (_Initial.default.isSupportRobotSettingApi) {
          robotSettingApi.registerRobotSettingListener(callbackId, keys);
        } else {
          (0, _Utils.newError)('This system version does not support registerRobotSettingListener.');
        }
      }
    }, {
      key: "unRegisterRobotSettingListener",
      value: function unRegisterRobotSettingListener(callbackId) {
        if (_Initial.default.isSupportRobotSettingApi) {
          robotSettingApi.unRegisterRobotSettingListener(callbackId);
        } else {
          (0, _Utils.newError)('This system version does not support unRegisterRobotSettingListener.');
        }
      }
    }, {
      key: "isCharging",
      value: function isCharging() {
        if (_Initial.default.robotSettingApiVersion >= 1) {
          return robotSettingApi.isCharging();
        } else {
          var msg = 'This system version does not support isCharging.';
          (0, _Utils.newError)(msg);
          return Promise.reject(msg);
        }
      }
    }, {
      key: "clearSettingsListener",
      value: function clearSettingsListener() {
        if (_Initial.default.robotSettingApiVersion >= 1) {
          robotSettingApi.clearSettingsListener();
        } else {
          (0, _Utils.newError)('This system version does not support unRegisterRobotSettingListener.');
        }
      }
    }]);
    return RobotSettingApi;
  }();

  exports.RobotSettingApi = RobotSettingApi;
  RobotSettingApi.appId = null;
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_RobotSettingApi.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","orionos-eve-core_src_Initial.ts","orionos-eve-core_src_utils_Utils.ts"],"node_modules/orionos-eve-core/src/robot/api/RobotSettingApi.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NlpPath = NlpPath;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react"));

  var _AppManager = _$$_REQUIRE(_dependencyMap[8], "../../robot/api/AppManager");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TAG = 'NlpPath';

  var appId = _AppManager.AppManager.getAppId();

  var defaultPath = 'main';
  var path = null;

  function setPath(pathName, action) {
    console.log(TAG, 'Set path : ' + pathName + '   ' + action + '   ' + appId);

    _AppManager.AppManager.setAppInfo(appId, pathName);

    if (action) {
      action.start();
    }
  }

  function onPathMount(pathName, action) {
    console.log(TAG, 'On path mount : ' + pathName + '   ' + action + '   ' + appId);
    var prePath = path;
    path = {
      pathName: pathName,
      action: action,
      pre: prePath
    };
    setPath(pathName, action);
  }

  function onPathUnmount(pathName, action) {
    console.log(TAG, 'On path unmount : ' + pathName);

    if (action) {
      action.stop();
    }

    if (path.pre && path.pre.pathName === pathName) {
      path.pre = path.pre.pre;
      return;
    }

    if (path.pathName === pathName) {
      if (path.pre) {
        path = path.pre;
        setPath(path.pathName, path.action);
      } else {
        setPath(defaultPath);
      }
    }
  }

  var NlpViewPath = function (_React$Component) {
    (0, _inherits2.default)(NlpViewPath, _React$Component);

    var _super = _createSuper(NlpViewPath);

    function NlpViewPath(props) {
      var _this;

      (0, _classCallCheck2.default)(this, NlpViewPath);
      _this = _super.call(this, props);
      _this.pathName = _this.props.pathName;
      _this.action = _this.props.action;
      return _this;
    }

    (0, _createClass2.default)(NlpViewPath, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        onPathMount(this.pathName, this.action);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        onPathUnmount(this.pathName, this.action);
      }
    }, {
      key: "render",
      value: function render() {
        return _react.default.createElement(_react.default.Fragment, null, this.props.children);
      }
    }]);
    return NlpViewPath;
  }(_react.default.Component);

  function decoratorViewPath(target, name, descriptor, pathName, action) {
    console.log('NlpPath view ********** : ' + pathName);
    var old = descriptor.value;

    descriptor.value = function () {
      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      var result = old.apply(this, arg);
      return _react.default.createElement(NlpViewPath, (0, _extends2.default)({}, arg, {
        pathName: pathName,
        action: action
      }), result);
    };
  }

  function decoratorPath(target, pathName, action) {
    console.log('NlpPath class ********** : ' + pathName);
    var targetWM = target.prototype.componentWillMount;

    target.prototype.componentWillMount = function () {
      targetWM && targetWM.call(this);
      onPathMount(pathName, action);
    };

    var targetWUM = target.prototype.componentWillUnmount;

    target.prototype.componentWillUnmount = function () {
      targetWUM && targetWUM.call(this);
      onPathUnmount(pathName, action);
    };
  }

  function NlpPath(pathName) {
    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var taskFlow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return function (target, name, descriptor) {
      if (descriptor) {
        decoratorViewPath(target, name, descriptor, pathName, action);
      } else {
        decoratorPath(target, pathName, action);
      }
    };
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_nlp_path_NlpPath.js",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_extends.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react_index.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_src_robot_api_AppManager.ts"],"node_modules/orionos-eve-core/src/nlp/path/NlpPath.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/Inspector.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Dimensions = _$$_REQUIRE(_dependencyMap[5], "Dimensions");

  var InspectorOverlay = _$$_REQUIRE(_dependencyMap[6], "InspectorOverlay");

  var InspectorPanel = _$$_REQUIRE(_dependencyMap[7], "InspectorPanel");

  var Platform = _$$_REQUIRE(_dependencyMap[8], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[9], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[10], "ReactNative");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[11], "StyleSheet");

  var Touchable = _$$_REQUIRE(_dependencyMap[12], "Touchable");

  var UIManager = _$$_REQUIRE(_dependencyMap[13], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[14], "View");

  var invariant = _$$_REQUIRE(_dependencyMap[15], "invariant");

  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  var renderers = findRenderers();
  hook.resolveRNStyle = _$$_REQUIRE(_dependencyMap[16], "flattenStyle");

  function findRenderers() {
    var allRenderers = Object.keys(hook._renderers).map(function (key) {
      return hook._renderers[key];
    });
    invariant(allRenderers.length >= 1, 'Expected to find at least one React Native renderer on DevTools hook.');
    return allRenderers;
  }

  function getInspectorDataForViewTag(touchedViewTag) {
    for (var i = 0; i < renderers.length; i++) {
      var renderer = renderers[i];

      if (Object.prototype.hasOwnProperty.call(renderer, 'getInspectorDataForViewTag')) {
        var inspectorData = renderer.getInspectorDataForViewTag(touchedViewTag);

        if (inspectorData.hierarchy.length > 0) {
          return inspectorData;
        }
      }
    }

    throw new Error('Expected to find at least one React renderer.');
  }

  var Inspector = function (_React$Component) {
    _inherits(Inspector, _React$Component);

    var _super = _createSuper(Inspector);

    function Inspector(_props) {
      var _this;

      _classCallCheck(this, Inspector);

      _this = _super.call(this, _props);

      _this.attachToDevtools = function (agent) {
        var _hideWait = null;
        var hlSub = agent.sub('highlight', function (_ref) {
          var node = _ref.node,
              name = _ref.name,
              props = _ref.props;
          clearTimeout(_hideWait);

          if (typeof node !== 'number') {
            node = ReactNative.findNodeHandle(node);
          }

          UIManager.measure(node, function (x, y, width, height, left, top) {
            _this.setState({
              hierarchy: [],
              inspected: {
                frame: {
                  left: left,
                  top: top,
                  width: width,
                  height: height
                },
                style: props ? props.style : {}
              }
            });
          });
        });
        var hideSub = agent.sub('hideHighlight', function () {
          if (_this.state.inspected === null) {
            return;
          }

          _hideWait = setTimeout(function () {
            _this.setState({
              inspected: null
            });
          }, 100);
        });
        _this._subs = [hlSub, hideSub];
        agent.on('shutdown', function () {
          _this.setState({
            devtoolsAgent: null
          });

          _this._subs = null;
        });

        _this.setState({
          devtoolsAgent: agent
        });
      };

      _this.state = {
        devtoolsAgent: null,
        hierarchy: null,
        panelPos: 'bottom',
        inspecting: true,
        perfing: false,
        inspected: null,
        selection: null,
        inspectedViewTag: _this.props.inspectedViewTag,
        networking: false
      };
      return _this;
    }

    _createClass(Inspector, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        hook.on('react-devtools', this.attachToDevtools);

        if (hook.reactDevtoolsAgent) {
          this.attachToDevtools(hook.reactDevtoolsAgent);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._subs) {
          this._subs.map(function (fn) {
            return fn();
          });
        }

        hook.off('react-devtools', this.attachToDevtools);
      }
    }, {
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(newProps) {
        this.setState({
          inspectedViewTag: newProps.inspectedViewTag
        });
      }
    }, {
      key: "setSelection",
      value: function setSelection(i) {
        var _this2 = this;

        var hierarchyItem = this.state.hierarchy[i];

        var _hierarchyItem$getIns = hierarchyItem.getInspectorData(ReactNative.findNodeHandle),
            measure = _hierarchyItem$getIns.measure,
            props = _hierarchyItem$getIns.props,
            source = _hierarchyItem$getIns.source;

        measure(function (x, y, width, height, left, top) {
          _this2.setState({
            inspected: {
              frame: {
                left: left,
                top: top,
                width: width,
                height: height
              },
              style: props.style,
              source: source
            },
            selection: i
          });
        });
      }
    }, {
      key: "onTouchViewTag",
      value: function onTouchViewTag(touchedViewTag, frame, pointerY) {
        var _getInspectorDataForV = getInspectorDataForViewTag(touchedViewTag),
            hierarchy = _getInspectorDataForV.hierarchy,
            props = _getInspectorDataForV.props,
            selection = _getInspectorDataForV.selection,
            source = _getInspectorDataForV.source;

        if (this.state.devtoolsAgent) {
          var offsetFromLeaf = hierarchy.length - 1 - selection;
          this.state.devtoolsAgent.selectFromDOMNode(touchedViewTag, true, offsetFromLeaf);
        }

        this.setState({
          panelPos: pointerY > Dimensions.get('window').height / 2 ? 'top' : 'bottom',
          selection: selection,
          hierarchy: hierarchy,
          inspected: {
            style: props.style,
            frame: frame,
            source: source
          }
        });
      }
    }, {
      key: "setPerfing",
      value: function setPerfing(val) {
        this.setState({
          perfing: val,
          inspecting: false,
          inspected: null,
          networking: false
        });
      }
    }, {
      key: "setInspecting",
      value: function setInspecting(val) {
        this.setState({
          inspecting: val,
          inspected: null
        });
      }
    }, {
      key: "setTouchTargeting",
      value: function setTouchTargeting(val) {
        var _this3 = this;

        Touchable.TOUCH_TARGET_DEBUG = val;
        this.props.onRequestRerenderApp(function (inspectedViewTag) {
          _this3.setState({
            inspectedViewTag: inspectedViewTag
          });
        });
      }
    }, {
      key: "setNetworking",
      value: function setNetworking(val) {
        this.setState({
          networking: val,
          perfing: false,
          inspecting: false,
          inspected: null
        });
      }
    }, {
      key: "render",
      value: function render() {
        var panelContainerStyle = this.state.panelPos === 'bottom' ? {
          bottom: 0
        } : {
          top: Platform.OS === 'ios' ? 20 : 0
        };
        return React.createElement(View, {
          style: styles.container,
          pointerEvents: "box-none",
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 248,
            columnNumber: 7
          }
        }, this.state.inspecting && React.createElement(InspectorOverlay, {
          inspected: this.state.inspected,
          inspectedViewTag: this.state.inspectedViewTag,
          onTouchViewTag: this.onTouchViewTag.bind(this),
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 250,
            columnNumber: 11
          }
        }), React.createElement(View, {
          style: [styles.panelContainer, panelContainerStyle],
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 256,
            columnNumber: 9
          }
        }, React.createElement(InspectorPanel, {
          devtoolsIsOpen: !!this.state.devtoolsAgent,
          inspecting: this.state.inspecting,
          perfing: this.state.perfing,
          setPerfing: this.setPerfing.bind(this),
          setInspecting: this.setInspecting.bind(this),
          inspected: this.state.inspected,
          hierarchy: this.state.hierarchy,
          selection: this.state.selection,
          setSelection: this.setSelection.bind(this),
          touchTargeting: Touchable.TOUCH_TARGET_DEBUG,
          setTouchTargeting: this.setTouchTargeting.bind(this),
          networking: this.state.networking,
          setNetworking: this.setNetworking.bind(this),
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 257,
            columnNumber: 11
          }
        })));
      }
    }]);

    return Inspector;
  }(React.Component);

  var styles = StyleSheet.create({
    container: {
      position: 'absolute',
      backgroundColor: 'transparent',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    panelContainer: {
      position: 'absolute',
      left: 0,
      right: 0
    }
  });
  module.exports = Inspector;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_Inspector.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_Utilities_Dimensions.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_InspectorOverlay.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_InspectorPanel.js","node_modules_react-native_Libraries_Utilities_Platform.android.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Renderer_shims_ReactNative.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Components_Touchable_Touchable.js","node_modules_react-native_Libraries_ReactNative_UIManager.js","node_modules_react-native_Libraries_Components_View_View.js","node_modules_invariant_browser.js","node_modules_react-native_Libraries_StyleSheet_flattenStyle.js"],"node_modules/react-native/Libraries/Inspector/Inspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/InspectorOverlay.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Dimensions = _$$_REQUIRE(_dependencyMap[5], "Dimensions");

  var ElementBox = _$$_REQUIRE(_dependencyMap[6], "ElementBox");

  var React = _$$_REQUIRE(_dependencyMap[7], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[8], "StyleSheet");

  var UIManager = _$$_REQUIRE(_dependencyMap[9], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[10], "View");

  var InspectorOverlay = function (_React$Component) {
    _inherits(InspectorOverlay, _React$Component);

    var _super = _createSuper(InspectorOverlay);

    function InspectorOverlay() {
      var _this;

      _classCallCheck(this, InspectorOverlay);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.findViewForTouchEvent = function (e) {
        var _e$nativeEvent$touche = e.nativeEvent.touches[0],
            locationX = _e$nativeEvent$touche.locationX,
            locationY = _e$nativeEvent$touche.locationY;
        UIManager.findSubviewIn(_this.props.inspectedViewTag, [locationX, locationY], function (nativeViewTag, left, top, width, height) {
          _this.props.onTouchViewTag(nativeViewTag, {
            left: left,
            top: top,
            width: width,
            height: height
          }, locationY);
        });
      };

      _this.shouldSetResponser = function (e) {
        _this.findViewForTouchEvent(e);

        return true;
      };

      return _this;
    }

    _createClass(InspectorOverlay, [{
      key: "render",
      value: function render() {
        var content = null;

        if (this.props.inspected) {
          content = React.createElement(ElementBox, {
            frame: this.props.inspected.frame,
            style: this.props.inspected.style,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 59,
              columnNumber: 9
            }
          });
        }

        return React.createElement(View, {
          onStartShouldSetResponder: this.shouldSetResponser,
          onResponderMove: this.findViewForTouchEvent,
          style: [styles.inspector, {
            height: Dimensions.get('window').height
          }],
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67,
            columnNumber: 7
          }
        }, content);
      }
    }]);

    return InspectorOverlay;
  }(React.Component);

  var styles = StyleSheet.create({
    inspector: {
      backgroundColor: 'transparent',
      position: 'absolute',
      left: 0,
      top: 0,
      right: 0
    }
  });
  module.exports = InspectorOverlay;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_InspectorOverlay.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_Utilities_Dimensions.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_ElementBox.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_ReactNative_UIManager.js","node_modules_react-native_Libraries_Components_View_View.js"],"node_modules/react-native/Libraries/Inspector/InspectorOverlay.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/ElementBox.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var BorderBox = _$$_REQUIRE(_dependencyMap[6], "BorderBox");

  var React = _$$_REQUIRE(_dependencyMap[7], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[8], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var Dimensions = _$$_REQUIRE(_dependencyMap[10], "Dimensions");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[11], "flattenStyle");

  var resolveBoxStyle = _$$_REQUIRE(_dependencyMap[12], "resolveBoxStyle");

  var ElementBox = function (_React$Component) {
    _inherits(ElementBox, _React$Component);

    var _super = _createSuper(ElementBox);

    function ElementBox() {
      _classCallCheck(this, ElementBox);

      return _super.apply(this, arguments);
    }

    _createClass(ElementBox, [{
      key: "render",
      value: function render() {
        var style = flattenStyle(this.props.style) || {};
        var margin = resolveBoxStyle('margin', style);
        var padding = resolveBoxStyle('padding', style);

        var frameStyle = _extends({}, this.props.frame);

        var contentStyle = {
          width: this.props.frame.width,
          height: this.props.frame.height
        };

        if (margin != null) {
          margin = resolveRelativeSizes(margin);
          frameStyle.top -= margin.top;
          frameStyle.left -= margin.left;
          frameStyle.height += margin.top + margin.bottom;
          frameStyle.width += margin.left + margin.right;

          if (margin.top < 0) {
            contentStyle.height += margin.top;
          }

          if (margin.bottom < 0) {
            contentStyle.height += margin.bottom;
          }

          if (margin.left < 0) {
            contentStyle.width += margin.left;
          }

          if (margin.right < 0) {
            contentStyle.width += margin.right;
          }
        }

        if (padding != null) {
          padding = resolveRelativeSizes(padding);
          contentStyle.width -= padding.left + padding.right;
          contentStyle.height -= padding.top + padding.bottom;
        }

        return React.createElement(View, {
          style: [styles.frame, frameStyle],
          pointerEvents: "none",
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 64,
            columnNumber: 7
          }
        }, React.createElement(BorderBox, {
          box: margin,
          style: styles.margin,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 65,
            columnNumber: 9
          }
        }, React.createElement(BorderBox, {
          box: padding,
          style: styles.padding,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 66,
            columnNumber: 11
          }
        }, React.createElement(View, {
          style: [styles.content, contentStyle],
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67,
            columnNumber: 13
          }
        }))));
      }
    }]);

    return ElementBox;
  }(React.Component);

  var styles = StyleSheet.create({
    frame: {
      position: 'absolute'
    },
    content: {
      backgroundColor: 'rgba(200, 230, 255, 0.8)'
    },
    padding: {
      borderColor: 'rgba(77, 255, 0, 0.3)'
    },
    margin: {
      borderColor: 'rgba(255, 132, 0, 0.3)'
    }
  });

  function resolveRelativeSizes(style) {
    var resolvedStyle = _extends({}, style);

    resolveSizeInPlace(resolvedStyle, 'top', 'height');
    resolveSizeInPlace(resolvedStyle, 'right', 'width');
    resolveSizeInPlace(resolvedStyle, 'bottom', 'height');
    resolveSizeInPlace(resolvedStyle, 'left', 'width');
    return resolvedStyle;
  }

  function resolveSizeInPlace(style, direction, dimension) {
    if (style[direction] !== null && typeof style[direction] === 'string') {
      if (style[direction].indexOf('%') !== -1) {
        style[direction] = parseFloat(style[direction]) / 100.0 * Dimensions.get('window')[dimension];
      }

      if (style[direction] === 'auto') {
        style[direction] = 0;
      }
    }
  }

  module.exports = ElementBox;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_ElementBox.js",["node_modules_@babel_runtime_helpers_extends.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_BorderBox.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Components_View_View.js","node_modules_react-native_Libraries_Utilities_Dimensions.js","node_modules_react-native_Libraries_StyleSheet_flattenStyle.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_resolveBoxStyle.js"],"node_modules/react-native/Libraries/Inspector/ElementBox.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/BorderBox.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var View = _$$_REQUIRE(_dependencyMap[6], "View");

  var BorderBox = function (_React$Component) {
    _inherits(BorderBox, _React$Component);

    var _super = _createSuper(BorderBox);

    function BorderBox() {
      _classCallCheck(this, BorderBox);

      return _super.apply(this, arguments);
    }

    _createClass(BorderBox, [{
      key: "render",
      value: function render() {
        var box = this.props.box;

        if (!box) {
          return this.props.children;
        }

        var style = {
          borderTopWidth: box.top,
          borderBottomWidth: box.bottom,
          borderLeftWidth: box.left,
          borderRightWidth: box.right
        };
        return React.createElement(View, {
          style: [style, this.props.style],
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 28,
            columnNumber: 12
          }
        }, this.props.children);
      }
    }]);

    return BorderBox;
  }(React.Component);

  module.exports = BorderBox;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_BorderBox.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Components_View_View.js"],"node_modules/react-native/Libraries/Inspector/BorderBox.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var I18nManager = _$$_REQUIRE(_dependencyMap[0], "I18nManager");

  function resolveBoxStyle(prefix, style) {
    var hasParts = false;
    var result = {
      bottom: 0,
      left: 0,
      right: 0,
      top: 0
    };
    var styleForAll = style[prefix];

    if (styleForAll != null) {
      for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        result[key] = styleForAll;
      }

      hasParts = true;
    }

    var styleForHorizontal = style[prefix + 'Horizontal'];

    if (styleForHorizontal != null) {
      result.left = styleForHorizontal;
      result.right = styleForHorizontal;
      hasParts = true;
    } else {
      var styleForLeft = style[prefix + 'Left'];

      if (styleForLeft != null) {
        result.left = styleForLeft;
        hasParts = true;
      }

      var styleForRight = style[prefix + 'Right'];

      if (styleForRight != null) {
        result.right = styleForRight;
        hasParts = true;
      }

      var styleForEnd = style[prefix + 'End'];

      if (styleForEnd != null) {
        if (I18nManager.isRTL && I18nManager.doLeftAndRightSwapInRTL) {
          result.left = styleForEnd;
        } else {
          result.right = styleForEnd;
        }

        hasParts = true;
      }

      var styleForStart = style[prefix + 'Start'];

      if (styleForStart != null) {
        if (I18nManager.isRTL && I18nManager.doLeftAndRightSwapInRTL) {
          result.right = styleForStart;
        } else {
          result.left = styleForStart;
        }

        hasParts = true;
      }
    }

    var styleForVertical = style[prefix + 'Vertical'];

    if (styleForVertical != null) {
      result.bottom = styleForVertical;
      result.top = styleForVertical;
      hasParts = true;
    } else {
      var styleForBottom = style[prefix + 'Bottom'];

      if (styleForBottom != null) {
        result.bottom = styleForBottom;
        hasParts = true;
      }

      var styleForTop = style[prefix + 'Top'];

      if (styleForTop != null) {
        result.top = styleForTop;
        hasParts = true;
      }
    }

    return hasParts ? result : null;
  }

  module.exports = resolveBoxStyle;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_resolveBoxStyle.js",["node_modules_react-native_Libraries_ReactNative_I18nManager.js"],"node_modules/react-native/Libraries/Inspector/resolveBoxStyle.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/InspectorPanel.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ElementProperties = _$$_REQUIRE(_dependencyMap[5], "ElementProperties");

  var NetworkOverlay = _$$_REQUIRE(_dependencyMap[6], "NetworkOverlay");

  var PerformanceOverlay = _$$_REQUIRE(_dependencyMap[7], "PerformanceOverlay");

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var ScrollView = _$$_REQUIRE(_dependencyMap[9], "ScrollView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[10], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[11], "Text");

  var TouchableHighlight = _$$_REQUIRE(_dependencyMap[12], "TouchableHighlight");

  var View = _$$_REQUIRE(_dependencyMap[13], "View");

  var InspectorPanel = function (_React$Component) {
    _inherits(InspectorPanel, _React$Component);

    var _super = _createSuper(InspectorPanel);

    function InspectorPanel() {
      _classCallCheck(this, InspectorPanel);

      return _super.apply(this, arguments);
    }

    _createClass(InspectorPanel, [{
      key: "renderWaiting",
      value: function renderWaiting() {
        if (this.props.inspecting) {
          return React.createElement(Text, {
            style: styles.waitingText,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 57,
              columnNumber: 9
            }
          }, "Tap something to inspect it");
        }

        return React.createElement(Text, {
          style: styles.waitingText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 60,
            columnNumber: 12
          }
        }, "Nothing is inspected");
      }
    }, {
      key: "render",
      value: function render() {
        var contents;

        if (this.props.inspected) {
          contents = React.createElement(ScrollView, {
            style: styles.properties,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 67,
              columnNumber: 9
            }
          }, React.createElement(ElementProperties, {
            style: this.props.inspected.style,
            frame: this.props.inspected.frame,
            source: this.props.inspected.source,
            hierarchy: this.props.hierarchy,
            selection: this.props.selection,
            setSelection: this.props.setSelection,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 68,
              columnNumber: 11
            }
          }));
        } else if (this.props.perfing) {
          contents = React.createElement(PerformanceOverlay, {
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 80,
              columnNumber: 18
            }
          });
        } else if (this.props.networking) {
          contents = React.createElement(NetworkOverlay, {
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 82,
              columnNumber: 18
            }
          });
        } else {
          contents = React.createElement(View, {
            style: styles.waiting,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 84,
              columnNumber: 18
            }
          }, this.renderWaiting());
        }

        return React.createElement(View, {
          style: styles.container,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 87,
            columnNumber: 7
          }
        }, !this.props.devtoolsIsOpen && contents, React.createElement(View, {
          style: styles.buttonRow,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 9
          }
        }, React.createElement(InspectorPanelButton, {
          title: 'Inspect',
          pressed: this.props.inspecting,
          onClick: this.props.setInspecting,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 11
          }
        }), React.createElement(InspectorPanelButton, {
          title: 'Perf',
          pressed: this.props.perfing,
          onClick: this.props.setPerfing,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 11
          }
        }), React.createElement(InspectorPanelButton, {
          title: 'Network',
          pressed: this.props.networking,
          onClick: this.props.setNetworking,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 100,
            columnNumber: 11
          }
        }), React.createElement(InspectorPanelButton, {
          title: 'Touchables',
          pressed: this.props.touchTargeting,
          onClick: this.props.setTouchTargeting,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 105,
            columnNumber: 11
          }
        })));
      }
    }]);

    return InspectorPanel;
  }(React.Component);

  var InspectorPanelButton = function (_React$Component2) {
    _inherits(InspectorPanelButton, _React$Component2);

    var _super2 = _createSuper(InspectorPanelButton);

    function InspectorPanelButton() {
      _classCallCheck(this, InspectorPanelButton);

      return _super2.apply(this, arguments);
    }

    _createClass(InspectorPanelButton, [{
      key: "render",
      value: function render() {
        var _this = this;

        return React.createElement(TouchableHighlight, {
          onPress: function onPress() {
            return _this.props.onClick(!_this.props.pressed);
          },
          style: [styles.button, this.props.pressed && styles.buttonPressed],
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 125,
            columnNumber: 7
          }
        }, React.createElement(Text, {
          style: styles.buttonText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 128,
            columnNumber: 9
          }
        }, this.props.title));
      }
    }]);

    return InspectorPanelButton;
  }(React.Component);

  var styles = StyleSheet.create({
    buttonRow: {
      flexDirection: 'row'
    },
    button: {
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      margin: 2,
      height: 30,
      justifyContent: 'center',
      alignItems: 'center'
    },
    buttonPressed: {
      backgroundColor: 'rgba(255, 255, 255, 0.3)'
    },
    buttonText: {
      textAlign: 'center',
      color: 'white',
      margin: 5
    },
    container: {
      backgroundColor: 'rgba(0, 0, 0, 0.7)'
    },
    properties: {
      height: 200
    },
    waiting: {
      height: 100
    },
    waitingText: {
      fontSize: 20,
      textAlign: 'center',
      marginVertical: 20,
      color: 'white'
    }
  });
  module.exports = InspectorPanel;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_InspectorPanel.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_ElementProperties.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_NetworkOverlay.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_PerformanceOverlay.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Components_ScrollView_ScrollView.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_Touchable_TouchableHighlight.js","node_modules_react-native_Libraries_Components_View_View.js"],"node_modules/react-native/Libraries/Inspector/InspectorPanel.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/ElementProperties.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var BoxInspector = _$$_REQUIRE(_dependencyMap[5], "BoxInspector");

  var React = _$$_REQUIRE(_dependencyMap[6], "React");

  var StyleInspector = _$$_REQUIRE(_dependencyMap[7], "StyleInspector");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[8], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[9], "Text");

  var TouchableHighlight = _$$_REQUIRE(_dependencyMap[10], "TouchableHighlight");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[11], "TouchableWithoutFeedback");

  var View = _$$_REQUIRE(_dependencyMap[12], "View");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[13], "flattenStyle");

  var mapWithSeparator = _$$_REQUIRE(_dependencyMap[14], "mapWithSeparator");

  var openFileInEditor = _$$_REQUIRE(_dependencyMap[15], "openFileInEditor");

  var ElementProperties = function (_React$Component) {
    _inherits(ElementProperties, _React$Component);

    var _super = _createSuper(ElementProperties);

    function ElementProperties() {
      _classCallCheck(this, ElementProperties);

      return _super.apply(this, arguments);
    }

    _createClass(ElementProperties, [{
      key: "render",
      value: function render() {
        var _this = this;

        var style = flattenStyle(this.props.style);
        var selection = this.props.selection;
        var openFileButton;
        var source = this.props.source;

        var _ref = source || {},
            fileName = _ref.fileName,
            lineNumber = _ref.lineNumber;

        if (fileName && lineNumber) {
          var parts = fileName.split('/');
          var fileNameShort = parts[parts.length - 1];
          openFileButton = React.createElement(TouchableHighlight, {
            style: styles.openButton,
            onPress: openFileInEditor.bind(null, fileName, lineNumber),
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 51,
              columnNumber: 9
            }
          }, React.createElement(Text, {
            style: styles.openButtonTitle,
            numberOfLines: 1,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 54,
              columnNumber: 11
            }
          }, fileNameShort, ":", lineNumber));
        }

        return React.createElement(TouchableWithoutFeedback, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 63,
            columnNumber: 7
          }
        }, React.createElement(View, {
          style: styles.info,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 64,
            columnNumber: 9
          }
        }, React.createElement(View, {
          style: styles.breadcrumb,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 65,
            columnNumber: 11
          }
        }, mapWithSeparator(this.props.hierarchy, function (hierarchyItem, i) {
          return React.createElement(TouchableHighlight, {
            key: 'item-' + i,
            style: [styles.breadItem, i === selection && styles.selected],
            onPress: function onPress() {
              return _this.props.setSelection(i);
            },
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 69,
              columnNumber: 17
            }
          }, React.createElement(Text, {
            style: styles.breadItemText,
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 74,
              columnNumber: 19
            }
          }, hierarchyItem.name));
        }, function (i) {
          return React.createElement(Text, {
            key: 'sep-' + i,
            style: styles.breadSep,
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 78,
              columnNumber: 17
            }
          }, "\u25B8");
        })), React.createElement(View, {
          style: styles.row,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 84,
            columnNumber: 11
          }
        }, React.createElement(View, {
          style: styles.col,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 85,
            columnNumber: 13
          }
        }, React.createElement(StyleInspector, {
          style: style,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 86,
            columnNumber: 15
          }
        }), openFileButton), React.createElement(BoxInspector, {
          style: style,
          frame: this.props.frame,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 14
          }
        }))));
      }
    }]);

    return ElementProperties;
  }(React.Component);

  var styles = StyleSheet.create({
    breadSep: {
      fontSize: 8,
      color: 'white'
    },
    breadcrumb: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      alignItems: 'flex-start',
      marginBottom: 5
    },
    selected: {
      borderColor: 'white',
      borderRadius: 5
    },
    breadItem: {
      borderWidth: 1,
      borderColor: 'transparent',
      marginHorizontal: 2
    },
    breadItemText: {
      fontSize: 10,
      color: 'white',
      marginHorizontal: 5
    },
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between'
    },
    col: {
      flex: 1
    },
    info: {
      padding: 10
    },
    openButton: {
      padding: 10,
      backgroundColor: '#000',
      marginVertical: 5,
      marginRight: 5,
      borderRadius: 2
    },
    openButtonTitle: {
      color: 'white',
      fontSize: 8
    }
  });
  module.exports = ElementProperties;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_ElementProperties.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_BoxInspector.js","node_modules_react-native_Libraries_react-native_React.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_StyleInspector.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_Touchable_TouchableHighlight.js","node_modules_react-native_Libraries_Components_Touchable_TouchableWithoutFeedback.js","node_modules_react-native_Libraries_Components_View_View.js","node_modules_react-native_Libraries_StyleSheet_flattenStyle.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Utilities_mapWithSeparator.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_openFileInEditor.js"],"node_modules/react-native/Libraries/Inspector/ElementProperties.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/BoxInspector.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[6], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[7], "Text");

  var View = _$$_REQUIRE(_dependencyMap[8], "View");

  var resolveBoxStyle = _$$_REQUIRE(_dependencyMap[9], "resolveBoxStyle");

  var blank = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };

  var BoxInspector = function (_React$Component) {
    _inherits(BoxInspector, _React$Component);

    var _super = _createSuper(BoxInspector);

    function BoxInspector() {
      _classCallCheck(this, BoxInspector);

      return _super.apply(this, arguments);
    }

    _createClass(BoxInspector, [{
      key: "render",
      value: function render() {
        var frame = this.props.frame;
        var style = this.props.style;
        var margin = style && resolveBoxStyle('margin', style) || blank;
        var padding = style && resolveBoxStyle('padding', style) || blank;
        return React.createElement(BoxContainer, {
          title: "margin",
          titleStyle: styles.marginLabel,
          box: margin,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 33,
            columnNumber: 7
          }
        }, React.createElement(BoxContainer, {
          title: "padding",
          box: padding,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 34,
            columnNumber: 9
          }
        }, React.createElement(View, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 35,
            columnNumber: 11
          }
        }, React.createElement(Text, {
          style: styles.innerText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 36,
            columnNumber: 13
          }
        }, "(", (frame.left || 0).toFixed(1), ", ", (frame.top || 0).toFixed(1), ")"), React.createElement(Text, {
          style: styles.innerText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 39,
            columnNumber: 13
          }
        }, (frame.width || 0).toFixed(1), " \xD7", ' ', (frame.height || 0).toFixed(1)))));
      }
    }]);

    return BoxInspector;
  }(React.Component);

  var BoxContainer = function (_React$Component2) {
    _inherits(BoxContainer, _React$Component2);

    var _super2 = _createSuper(BoxContainer);

    function BoxContainer() {
      _classCallCheck(this, BoxContainer);

      return _super2.apply(this, arguments);
    }

    _createClass(BoxContainer, [{
      key: "render",
      value: function render() {
        var box = this.props.box;
        return React.createElement(View, {
          style: styles.box,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 54,
            columnNumber: 7
          }
        }, React.createElement(View, {
          style: styles.row,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 55,
            columnNumber: 9
          }
        }, React.createElement(Text, {
          style: [this.props.titleStyle, styles.label],
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 57,
            columnNumber: 11
          }
        }, this.props.title), React.createElement(Text, {
          style: styles.boxText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 60,
            columnNumber: 11
          }
        }, box.top)), React.createElement(View, {
          style: styles.row,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 62,
            columnNumber: 9
          }
        }, React.createElement(Text, {
          style: styles.boxText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 63,
            columnNumber: 11
          }
        }, box.left), this.props.children, React.createElement(Text, {
          style: styles.boxText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 65,
            columnNumber: 11
          }
        }, box.right)), React.createElement(Text, {
          style: styles.boxText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67,
            columnNumber: 9
          }
        }, box.bottom));
      }
    }]);

    return BoxContainer;
  }(React.Component);

  var styles = StyleSheet.create({
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around'
    },
    marginLabel: {
      width: 60
    },
    label: {
      fontSize: 10,
      color: 'rgb(255,100,0)',
      marginLeft: 5,
      flex: 1,
      textAlign: 'left',
      top: -3
    },
    innerText: {
      color: 'yellow',
      fontSize: 12,
      textAlign: 'center',
      width: 70
    },
    box: {
      borderWidth: 1,
      borderColor: 'grey'
    },
    boxText: {
      color: 'white',
      fontSize: 12,
      marginHorizontal: 3,
      marginVertical: 2,
      textAlign: 'center'
    }
  });
  module.exports = BoxInspector;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_BoxInspector.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_resolveBoxStyle.js"],"node_modules/react-native/Libraries/Inspector/BoxInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/StyleInspector.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[6], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[7], "Text");

  var View = _$$_REQUIRE(_dependencyMap[8], "View");

  var StyleInspector = function (_React$Component) {
    _inherits(StyleInspector, _React$Component);

    var _super = _createSuper(StyleInspector);

    function StyleInspector() {
      _classCallCheck(this, StyleInspector);

      return _super.apply(this, arguments);
    }

    _createClass(StyleInspector, [{
      key: "render",
      value: function render() {
        var _this = this;

        if (!this.props.style) {
          return React.createElement(Text, {
            style: styles.noStyle,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 21,
              columnNumber: 14
            }
          }, "No style");
        }

        var names = Object.keys(this.props.style);
        return React.createElement(View, {
          style: styles.container,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 25,
            columnNumber: 7
          }
        }, React.createElement(View, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 26,
            columnNumber: 9
          }
        }, names.map(function (name) {
          return React.createElement(Text, {
            key: name,
            style: styles.attr,
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 28,
              columnNumber: 13
            }
          }, name, ":");
        })), React.createElement(View, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 34,
            columnNumber: 9
          }
        }, names.map(function (name) {
          var value = typeof _this.props.style[name] === 'object' ? JSON.stringify(_this.props.style[name]) : _this.props.style[name];
          return React.createElement(Text, {
            key: name,
            style: styles.value,
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 41,
              columnNumber: 15
            }
          }, value);
        })));
      }
    }]);

    return StyleInspector;
  }(React.Component);

  var styles = StyleSheet.create({
    container: {
      flexDirection: 'row'
    },
    attr: {
      fontSize: 10,
      color: '#ccc'
    },
    value: {
      fontSize: 10,
      color: 'white',
      marginLeft: 10
    },
    noStyle: {
      color: 'white',
      fontSize: 10
    }
  });
  module.exports = StyleInspector;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_StyleInspector.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_View_View.js"],"node_modules/react-native/Libraries/Inspector/StyleInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function mapWithSeparator(items, itemRenderer, spacerRenderer) {
    var mapped = [];

    if (items.length > 0) {
      mapped.push(itemRenderer(items[0], 0, items));

      for (var ii = 1; ii < items.length; ii++) {
        mapped.push(spacerRenderer(ii - 1), itemRenderer(items[ii], ii, items));
      }
    }

    return mapped;
  }

  module.exports = mapWithSeparator;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Utilities_mapWithSeparator.js",[],"node_modules/react-native/Libraries/Utilities/mapWithSeparator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var getDevServer = _$$_REQUIRE(_dependencyMap[0], "getDevServer");

  function openFileInEditor(file, lineNumber) {
    fetch(getDevServer().url + 'open-stack-frame', {
      method: 'POST',
      body: JSON.stringify({
        file: file,
        lineNumber: lineNumber
      })
    });
  }

  module.exports = openFileInEditor;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_openFileInEditor.js",["system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_getDevServer.js"],"node_modules/react-native/Libraries/Core/Devtools/openFileInEditor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/assertThisInitialized");

  var _inherits = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/NetworkOverlay.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FlatList = _$$_REQUIRE(_dependencyMap[6], "FlatList");

  var React = _$$_REQUIRE(_dependencyMap[7], "React");

  var ScrollView = _$$_REQUIRE(_dependencyMap[8], "ScrollView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[10], "Text");

  var TouchableHighlight = _$$_REQUIRE(_dependencyMap[11], "TouchableHighlight");

  var View = _$$_REQUIRE(_dependencyMap[12], "View");

  var WebSocketInterceptor = _$$_REQUIRE(_dependencyMap[13], "WebSocketInterceptor");

  var XHRInterceptor = _$$_REQUIRE(_dependencyMap[14], "XHRInterceptor");

  var LISTVIEW_CELL_HEIGHT = 15;
  var nextXHRId = 0;

  function getStringByValue(value) {
    if (value === undefined) {
      return 'undefined';
    }

    if (typeof value === 'object') {
      return JSON.stringify(value);
    }

    if (typeof value === 'string' && value.length > 500) {
      return String(value).substr(0, 500).concat('\n***TRUNCATED TO 500 CHARACTERS***');
    }

    return value;
  }

  function getTypeShortName(type) {
    if (type === 'XMLHttpRequest') {
      return 'XHR';
    } else if (type === 'WebSocket') {
      return 'WS';
    }

    return '';
  }

  function keyExtractor(request) {
    return String(request.id);
  }

  var NetworkOverlay = function (_React$Component) {
    _inherits(NetworkOverlay, _React$Component);

    var _super = _createSuper(NetworkOverlay);

    function NetworkOverlay() {
      var _this;

      _classCallCheck(this, NetworkOverlay);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._requestsListViewScrollMetrics = {
        offset: 0,
        visibleLength: 0,
        contentLength: 0
      };
      _this._socketIdMap = {};
      _this._xhrIdMap = {};
      _this.state = {
        detailRowId: null,
        requests: []
      };

      _this._renderItem = function (_ref) {
        var item = _ref.item,
            index = _ref.index;
        var tableRowViewStyle = [styles.tableRow, index % 2 === 1 ? styles.tableRowOdd : styles.tableRowEven, index === _this.state.detailRowId && styles.tableRowPressed];
        var urlCellViewStyle = styles.urlCellView;
        var methodCellViewStyle = styles.methodCellView;
        return React.createElement(TouchableHighlight, {
          onPress: function onPress() {
            _this._pressRow(index);
          },
          __self: _assertThisInitialized(_this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 338,
            columnNumber: 7
          }
        }, React.createElement(View, {
          __self: _assertThisInitialized(_this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 342,
            columnNumber: 9
          }
        }, React.createElement(View, {
          style: tableRowViewStyle,
          __self: _assertThisInitialized(_this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 343,
            columnNumber: 11
          }
        }, React.createElement(View, {
          style: urlCellViewStyle,
          __self: _assertThisInitialized(_this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 344,
            columnNumber: 13
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __self: _assertThisInitialized(_this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 345,
            columnNumber: 15
          }
        }, item.url)), React.createElement(View, {
          style: methodCellViewStyle,
          __self: _assertThisInitialized(_this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 349,
            columnNumber: 13
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __self: _assertThisInitialized(_this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 350,
            columnNumber: 15
          }
        }, getTypeShortName(item.type))))));
      };

      _this._indicateAdditionalRequests = function () {
        if (_this._requestsListView) {
          var distanceFromEndThreshold = LISTVIEW_CELL_HEIGHT * 2;
          var _this$_requestsListVi = _this._requestsListViewScrollMetrics,
              offset = _this$_requestsListVi.offset,
              visibleLength = _this$_requestsListVi.visibleLength,
              contentLength = _this$_requestsListVi.contentLength;
          var distanceFromEnd = contentLength - visibleLength - offset;
          var isCloseToEnd = distanceFromEnd <= distanceFromEndThreshold;

          if (isCloseToEnd) {
            _this._requestsListView.scrollToEnd();
          } else {
            _this._requestsListView.flashScrollIndicators();
          }
        }
      };

      _this._captureRequestsListView = function (listRef) {
        _this._requestsListView = listRef;
      };

      _this._requestsListViewOnScroll = function (e) {
        _this._requestsListViewScrollMetrics.offset = e.nativeEvent.contentOffset.y;
        _this._requestsListViewScrollMetrics.visibleLength = e.nativeEvent.layoutMeasurement.height;
        _this._requestsListViewScrollMetrics.contentLength = e.nativeEvent.contentSize.height;
      };

      _this._scrollDetailToTop = function () {
        if (_this._detailScrollView) {
          _this._detailScrollView.scrollTo({
            y: 0,
            animated: false
          });
        }
      };

      _this._closeButtonClicked = function () {
        _this.setState({
          detailRowId: null
        });
      };

      return _this;
    }

    _createClass(NetworkOverlay, [{
      key: "_enableXHRInterception",
      value: function _enableXHRInterception() {
        var _this2 = this;

        if (XHRInterceptor.isInterceptorEnabled()) {
          return;
        }

        XHRInterceptor.setOpenCallback(function (method, url, xhr) {
          xhr._index = nextXHRId++;
          var xhrIndex = _this2.state.requests.length;
          _this2._xhrIdMap[xhr._index] = xhrIndex;
          var _xhr = {
            id: xhrIndex,
            type: 'XMLHttpRequest',
            method: method,
            url: url
          };

          _this2.setState({
            requests: _this2.state.requests.concat(_xhr)
          }, _this2._indicateAdditionalRequests);
        });
        XHRInterceptor.setRequestHeaderCallback(function (header, value, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          _this2.setState(function (_ref2) {
            var requests = _ref2.requests;
            var networkRequestInfo = requests[xhrIndex];

            if (!networkRequestInfo.requestHeaders) {
              networkRequestInfo.requestHeaders = {};
            }

            networkRequestInfo.requestHeaders[header] = value;
            return {
              requests: requests
            };
          });
        });
        XHRInterceptor.setSendCallback(function (data, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          _this2.setState(function (_ref3) {
            var requests = _ref3.requests;
            var networkRequestInfo = requests[xhrIndex];
            networkRequestInfo.dataSent = data;
            return {
              requests: requests
            };
          });
        });
        XHRInterceptor.setHeaderReceivedCallback(function (type, size, responseHeaders, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          _this2.setState(function (_ref4) {
            var requests = _ref4.requests;
            var networkRequestInfo = requests[xhrIndex];
            networkRequestInfo.responseContentType = type;
            networkRequestInfo.responseSize = size;
            networkRequestInfo.responseHeaders = responseHeaders;
            return {
              requests: requests
            };
          });
        });
        XHRInterceptor.setResponseCallback(function (status, timeout, response, responseURL, responseType, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          _this2.setState(function (_ref5) {
            var requests = _ref5.requests;
            var networkRequestInfo = requests[xhrIndex];
            networkRequestInfo.status = status;
            networkRequestInfo.timeout = timeout;
            networkRequestInfo.response = response;
            networkRequestInfo.responseURL = responseURL;
            networkRequestInfo.responseType = responseType;
            return {
              requests: requests
            };
          });
        });
        XHRInterceptor.enableInterception();
      }
    }, {
      key: "_enableWebSocketInterception",
      value: function _enableWebSocketInterception() {
        var _this3 = this;

        if (WebSocketInterceptor.isInterceptorEnabled()) {
          return;
        }

        WebSocketInterceptor.setConnectCallback(function (url, protocols, options, socketId) {
          var socketIndex = _this3.state.requests.length;
          _this3._socketIdMap[socketId] = socketIndex;
          var _webSocket = {
            id: socketIndex,
            type: 'WebSocket',
            url: url,
            protocols: protocols
          };

          _this3.setState({
            requests: _this3.state.requests.concat(_webSocket)
          }, _this3._indicateAdditionalRequests);
        });
        WebSocketInterceptor.setCloseCallback(function (statusCode, closeReason, socketId) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          if (statusCode !== null && closeReason !== null) {
            _this3.setState(function (_ref6) {
              var requests = _ref6.requests;
              var networkRequestInfo = requests[socketIndex];
              networkRequestInfo.status = statusCode;
              networkRequestInfo.closeReason = closeReason;
              return {
                requests: requests
              };
            });
          }
        });
        WebSocketInterceptor.setSendCallback(function (data, socketId) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3.setState(function (_ref7) {
            var requests = _ref7.requests;
            var networkRequestInfo = requests[socketIndex];

            if (!networkRequestInfo.messages) {
              networkRequestInfo.messages = '';
            }

            networkRequestInfo.messages += 'Sent: ' + JSON.stringify(data) + '\n';
            return {
              requests: requests
            };
          });
        });
        WebSocketInterceptor.setOnMessageCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3.setState(function (_ref8) {
            var requests = _ref8.requests;
            var networkRequestInfo = requests[socketIndex];

            if (!networkRequestInfo.messages) {
              networkRequestInfo.messages = '';
            }

            networkRequestInfo.messages += 'Received: ' + JSON.stringify(message) + '\n';
            return {
              requests: requests
            };
          });
        });
        WebSocketInterceptor.setOnCloseCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3.setState(function (_ref9) {
            var requests = _ref9.requests;
            var networkRequestInfo = requests[socketIndex];
            networkRequestInfo.serverClose = message;
            return {
              requests: requests
            };
          });
        });
        WebSocketInterceptor.setOnErrorCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3.setState(function (_ref10) {
            var requests = _ref10.requests;
            var networkRequestInfo = requests[socketIndex];
            networkRequestInfo.serverError = message;
            return {
              requests: requests
            };
          });
        });
        WebSocketInterceptor.enableInterception();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._enableXHRInterception();

        this._enableWebSocketInterception();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        XHRInterceptor.disableInterception();
        WebSocketInterceptor.disableInterception();
      }
    }, {
      key: "_renderItemDetail",
      value: function _renderItemDetail(id) {
        var _this4 = this;

        var requestItem = this.state.requests[id];
        var details = Object.keys(requestItem).map(function (key) {
          if (key === 'id') {
            return;
          }

          return React.createElement(View, {
            style: styles.detailViewRow,
            key: key,
            __self: _this4,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 367,
              columnNumber: 9
            }
          }, React.createElement(Text, {
            style: [styles.detailViewText, styles.detailKeyCellView],
            __self: _this4,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 368,
              columnNumber: 11
            }
          }, key), React.createElement(Text, {
            style: [styles.detailViewText, styles.detailValueCellView],
            __self: _this4,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 371,
              columnNumber: 11
            }
          }, getStringByValue(requestItem[key])));
        });
        return React.createElement(View, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 379,
            columnNumber: 7
          }
        }, React.createElement(TouchableHighlight, {
          style: styles.closeButton,
          onPress: this._closeButtonClicked,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 380,
            columnNumber: 9
          }
        }, React.createElement(View, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 383,
            columnNumber: 11
          }
        }, React.createElement(Text, {
          style: styles.closeButtonText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 384,
            columnNumber: 13
          }
        }, "v"))), React.createElement(ScrollView, {
          style: styles.detailScrollView,
          ref: function ref(scrollRef) {
            return _this4._detailScrollView = scrollRef;
          },
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 387,
            columnNumber: 9
          }
        }, details));
      }
    }, {
      key: "_pressRow",
      value: function _pressRow(rowId) {
        this.setState({
          detailRowId: rowId
        }, this._scrollDetailToTop);
      }
    }, {
      key: "_getRequestIndexByXHRID",
      value: function _getRequestIndexByXHRID(index) {
        if (index === undefined) {
          return -1;
        }

        var xhrIndex = this._xhrIdMap[index];

        if (xhrIndex === undefined) {
          return -1;
        } else {
          return xhrIndex;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state = this.state,
            requests = _this$state.requests,
            detailRowId = _this$state.detailRowId;
        return React.createElement(View, {
          style: styles.container,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 463,
            columnNumber: 7
          }
        }, detailRowId != null && this._renderItemDetail(detailRowId), React.createElement(View, {
          style: styles.listViewTitle,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 465,
            columnNumber: 9
          }
        }, requests.length > 0 && React.createElement(View, {
          style: styles.tableRow,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 467,
            columnNumber: 13
          }
        }, React.createElement(View, {
          style: styles.urlTitleCellView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 468,
            columnNumber: 15
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 469,
            columnNumber: 17
          }
        }, "URL")), React.createElement(View, {
          style: styles.methodTitleCellView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 473,
            columnNumber: 15
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 474,
            columnNumber: 17
          }
        }, "Type")))), React.createElement(FlatList, {
          ref: this._captureRequestsListView,
          onScroll: this._requestsListViewOnScroll,
          style: styles.listView,
          data: requests,
          renderItem: this._renderItem,
          keyExtractor: keyExtractor,
          extraData: this.state,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 482,
            columnNumber: 9
          }
        }));
      }
    }]);

    return NetworkOverlay;
  }(React.Component);

  var styles = StyleSheet.create({
    container: {
      paddingTop: 10,
      paddingBottom: 10,
      paddingLeft: 5,
      paddingRight: 5
    },
    listViewTitle: {
      height: 20
    },
    listView: {
      flex: 1,
      height: 60
    },
    tableRow: {
      flexDirection: 'row',
      flex: 1,
      height: LISTVIEW_CELL_HEIGHT
    },
    tableRowEven: {
      backgroundColor: '#555'
    },
    tableRowOdd: {
      backgroundColor: '#000'
    },
    tableRowPressed: {
      backgroundColor: '#3B5998'
    },
    cellText: {
      color: 'white',
      fontSize: 12
    },
    methodTitleCellView: {
      height: 18,
      borderColor: '#DCD7CD',
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#444',
      flex: 1
    },
    urlTitleCellView: {
      height: 18,
      borderColor: '#DCD7CD',
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      backgroundColor: '#444',
      flex: 5,
      paddingLeft: 3
    },
    methodCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      flex: 1
    },
    urlCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      flex: 5,
      paddingLeft: 3
    },
    detailScrollView: {
      flex: 1,
      height: 180,
      marginTop: 5,
      marginBottom: 5
    },
    detailKeyCellView: {
      flex: 1.3
    },
    detailValueCellView: {
      flex: 2
    },
    detailViewRow: {
      flexDirection: 'row',
      paddingHorizontal: 3
    },
    detailViewText: {
      color: 'white',
      fontSize: 11
    },
    closeButtonText: {
      color: 'white',
      fontSize: 10
    },
    closeButton: {
      marginTop: 5,
      backgroundColor: '#888',
      justifyContent: 'center',
      alignItems: 'center'
    }
  });
  module.exports = NetworkOverlay;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_NetworkOverlay.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_assertThisInitialized.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_Lists_FlatList.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Components_ScrollView_ScrollView.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_Touchable_TouchableHighlight.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_WebSocket_WebSocketInterceptor.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Network_XHRInterceptor.js"],"node_modules/react-native/Libraries/Inspector/NetworkOverlay.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var RCTWebSocketModule = _$$_REQUIRE(_dependencyMap[0], "NativeModules").WebSocketModule;

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[1], "NativeEventEmitter");

  var base64 = _$$_REQUIRE(_dependencyMap[2], "base64-js");

  var originalRCTWebSocketConnect = RCTWebSocketModule.connect;
  var originalRCTWebSocketSend = RCTWebSocketModule.send;
  var originalRCTWebSocketSendBinary = RCTWebSocketModule.sendBinary;
  var originalRCTWebSocketClose = RCTWebSocketModule.close;
  var eventEmitter;
  var subscriptions;
  var closeCallback;
  var sendCallback;
  var connectCallback;
  var onOpenCallback;
  var onMessageCallback;
  var onErrorCallback;
  var onCloseCallback;
  var _isInterceptorEnabled = false;
  var WebSocketInterceptor = {
    setCloseCallback: function setCloseCallback(callback) {
      closeCallback = callback;
    },
    setSendCallback: function setSendCallback(callback) {
      sendCallback = callback;
    },
    setConnectCallback: function setConnectCallback(callback) {
      connectCallback = callback;
    },
    setOnOpenCallback: function setOnOpenCallback(callback) {
      onOpenCallback = callback;
    },
    setOnMessageCallback: function setOnMessageCallback(callback) {
      onMessageCallback = callback;
    },
    setOnErrorCallback: function setOnErrorCallback(callback) {
      onErrorCallback = callback;
    },
    setOnCloseCallback: function setOnCloseCallback(callback) {
      onCloseCallback = callback;
    },
    isInterceptorEnabled: function isInterceptorEnabled() {
      return _isInterceptorEnabled;
    },
    _unregisterEvents: function _unregisterEvents() {
      subscriptions.forEach(function (e) {
        return e.remove();
      });
      subscriptions = [];
    },
    _registerEvents: function _registerEvents() {
      subscriptions = [eventEmitter.addListener('websocketMessage', function (ev) {
        if (onMessageCallback) {
          onMessageCallback(ev.id, ev.type === 'binary' ? WebSocketInterceptor._arrayBufferToString(ev.data) : ev.data);
        }
      }), eventEmitter.addListener('websocketOpen', function (ev) {
        if (onOpenCallback) {
          onOpenCallback(ev.id);
        }
      }), eventEmitter.addListener('websocketClosed', function (ev) {
        if (onCloseCallback) {
          onCloseCallback(ev.id, {
            code: ev.code,
            reason: ev.reason
          });
        }
      }), eventEmitter.addListener('websocketFailed', function (ev) {
        if (onErrorCallback) {
          onErrorCallback(ev.id, {
            message: ev.message
          });
        }
      })];
    },
    enableInterception: function enableInterception() {
      if (_isInterceptorEnabled) {
        return;
      }

      eventEmitter = new NativeEventEmitter(RCTWebSocketModule);

      WebSocketInterceptor._registerEvents();

      RCTWebSocketModule.connect = function (url, protocols, options, socketId) {
        if (connectCallback) {
          connectCallback(url, protocols, options, socketId);
        }

        originalRCTWebSocketConnect.apply(this, arguments);
      };

      RCTWebSocketModule.send = function (data, socketId) {
        if (sendCallback) {
          sendCallback(data, socketId);
        }

        originalRCTWebSocketSend.apply(this, arguments);
      };

      RCTWebSocketModule.sendBinary = function (data, socketId) {
        if (sendCallback) {
          sendCallback(WebSocketInterceptor._arrayBufferToString(data), socketId);
        }

        originalRCTWebSocketSendBinary.apply(this, arguments);
      };

      RCTWebSocketModule.close = function () {
        if (closeCallback) {
          if (arguments.length === 3) {
            closeCallback(arguments[0], arguments[1], arguments[2]);
          } else {
            closeCallback(null, null, arguments[0]);
          }
        }

        originalRCTWebSocketClose.apply(this, arguments);
      };

      _isInterceptorEnabled = true;
    },
    _arrayBufferToString: function _arrayBufferToString(data) {
      var value = base64.toByteArray(data).buffer;

      if (value === undefined || value === null) {
        return '(no value)';
      }

      if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && value instanceof ArrayBuffer) {
        return "ArrayBuffer {" + String(Array.from(new Uint8Array(value))) + "}";
      }

      return value;
    },
    disableInterception: function disableInterception() {
      if (!_isInterceptorEnabled) {
        return;
      }

      _isInterceptorEnabled = false;
      RCTWebSocketModule.send = originalRCTWebSocketSend;
      RCTWebSocketModule.sendBinary = originalRCTWebSocketSendBinary;
      RCTWebSocketModule.close = originalRCTWebSocketClose;
      RCTWebSocketModule.connect = originalRCTWebSocketConnect;
      connectCallback = null;
      closeCallback = null;
      sendCallback = null;
      onOpenCallback = null;
      onMessageCallback = null;
      onCloseCallback = null;
      onErrorCallback = null;

      WebSocketInterceptor._unregisterEvents();
    }
  };
  module.exports = WebSocketInterceptor;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_WebSocket_WebSocketInterceptor.js",["node_modules_react-native_Libraries_BatchedBridge_NativeModules.js","node_modules_react-native_Libraries_EventEmitter_NativeEventEmitter.js","node_modules_base64-js_index.js"],"node_modules/react-native/Libraries/WebSocket/WebSocketInterceptor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var XMLHttpRequest = _$$_REQUIRE(_dependencyMap[0], "XMLHttpRequest");

  var originalXHROpen = XMLHttpRequest.prototype.open;
  var originalXHRSend = XMLHttpRequest.prototype.send;
  var originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
  var openCallback;
  var sendCallback;
  var requestHeaderCallback;
  var headerReceivedCallback;
  var responseCallback;
  var _isInterceptorEnabled = false;
  var XHRInterceptor = {
    setOpenCallback: function setOpenCallback(callback) {
      openCallback = callback;
    },
    setSendCallback: function setSendCallback(callback) {
      sendCallback = callback;
    },
    setHeaderReceivedCallback: function setHeaderReceivedCallback(callback) {
      headerReceivedCallback = callback;
    },
    setResponseCallback: function setResponseCallback(callback) {
      responseCallback = callback;
    },
    setRequestHeaderCallback: function setRequestHeaderCallback(callback) {
      requestHeaderCallback = callback;
    },
    isInterceptorEnabled: function isInterceptorEnabled() {
      return _isInterceptorEnabled;
    },
    enableInterception: function enableInterception() {
      if (_isInterceptorEnabled) {
        return;
      }

      XMLHttpRequest.prototype.open = function (method, url) {
        if (openCallback) {
          openCallback(method, url, this);
        }

        originalXHROpen.apply(this, arguments);
      };

      XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
        if (requestHeaderCallback) {
          requestHeaderCallback(header, value, this);
        }

        originalXHRSetRequestHeader.apply(this, arguments);
      };

      XMLHttpRequest.prototype.send = function (data) {
        var _this = this;

        if (sendCallback) {
          sendCallback(data, this);
        }

        if (this.addEventListener) {
          this.addEventListener('readystatechange', function () {
            if (!_isInterceptorEnabled) {
              return;
            }

            if (_this.readyState === _this.HEADERS_RECEIVED) {
              var contentTypeString = _this.getResponseHeader('Content-Type');

              var contentLengthString = _this.getResponseHeader('Content-Length');

              var responseContentType, responseSize;

              if (contentTypeString) {
                responseContentType = contentTypeString.split(';')[0];
              }

              if (contentLengthString) {
                responseSize = parseInt(contentLengthString, 10);
              }

              if (headerReceivedCallback) {
                headerReceivedCallback(responseContentType, responseSize, _this.getAllResponseHeaders(), _this);
              }
            }

            if (_this.readyState === _this.DONE) {
              if (responseCallback) {
                responseCallback(_this.status, _this.timeout, _this.response, _this.responseURL, _this.responseType, _this);
              }
            }
          }, false);
        }

        originalXHRSend.apply(this, arguments);
      };

      _isInterceptorEnabled = true;
    },
    disableInterception: function disableInterception() {
      if (!_isInterceptorEnabled) {
        return;
      }

      _isInterceptorEnabled = false;
      XMLHttpRequest.prototype.send = originalXHRSend;
      XMLHttpRequest.prototype.open = originalXHROpen;
      XMLHttpRequest.prototype.setRequestHeader = originalXHRSetRequestHeader;
      responseCallback = null;
      openCallback = null;
      sendCallback = null;
      headerReceivedCallback = null;
      requestHeaderCallback = null;
    }
  };
  module.exports = XHRInterceptor;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Network_XHRInterceptor.js",["node_modules_react-native_Libraries_Network_XMLHttpRequest.js"],"node_modules/react-native/Libraries/Network/XHRInterceptor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/Inspector/PerformanceOverlay.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var PerformanceLogger = _$$_REQUIRE(_dependencyMap[5], "PerformanceLogger");

  var React = _$$_REQUIRE(_dependencyMap[6], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[7], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[8], "Text");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var PerformanceOverlay = function (_React$Component) {
    _inherits(PerformanceOverlay, _React$Component);

    var _super = _createSuper(PerformanceOverlay);

    function PerformanceOverlay() {
      _classCallCheck(this, PerformanceOverlay);

      return _super.apply(this, arguments);
    }

    _createClass(PerformanceOverlay, [{
      key: "render",
      value: function render() {
        var perfLogs = PerformanceLogger.getTimespans();
        var items = [];

        for (var key in perfLogs) {
          if (perfLogs[key].totalTime) {
            var unit = key === 'BundleSize' ? 'b' : 'ms';
            items.push(React.createElement(View, {
              style: styles.row,
              key: key,
              __self: this,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 28,
                columnNumber: 11
              }
            }, React.createElement(Text, {
              style: [styles.text, styles.label],
              __self: this,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 29,
                columnNumber: 13
              }
            }, key), React.createElement(Text, {
              style: [styles.text, styles.totalTime],
              __self: this,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 30,
                columnNumber: 13
              }
            }, perfLogs[key].totalTime + unit)));
          }
        }

        return React.createElement(View, {
          style: styles.container,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 38,
            columnNumber: 12
          }
        }, items);
      }
    }]);

    return PerformanceOverlay;
  }(React.Component);

  var styles = StyleSheet.create({
    container: {
      height: 100,
      paddingTop: 10
    },
    label: {
      flex: 1
    },
    row: {
      flexDirection: 'row',
      paddingHorizontal: 10
    },
    text: {
      color: 'white',
      fontSize: 12
    },
    totalTime: {
      paddingRight: 100
    }
  });
  module.exports = PerformanceOverlay;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Inspector_PerformanceOverlay.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_Utilities_PerformanceLogger.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_View_View.js"],"node_modules/react-native/Libraries/Inspector/PerformanceOverlay.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/slicedToArray");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxList.js";

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Dimensions = _$$_REQUIRE(_dependencyMap[7], "Dimensions");

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var FlatList = _$$_REQUIRE(_dependencyMap[9], "FlatList");

  var SafeAreaView = _$$_REQUIRE(_dependencyMap[10], "SafeAreaView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[11], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[12], "View");

  var YellowBoxButton = _$$_REQUIRE(_dependencyMap[13], "YellowBoxButton");

  var YellowBoxInspector = _$$_REQUIRE(_dependencyMap[14], "YellowBoxInspector");

  var YellowBoxListRow = _$$_REQUIRE(_dependencyMap[15], "YellowBoxListRow");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[16], "YellowBoxStyle");

  var VIEWPORT_RATIO = 0.5;
  var MAX_ITEMS = Math.floor(Dimensions.get('window').height * VIEWPORT_RATIO / (YellowBoxListRow.GUTTER + YellowBoxListRow.HEIGHT));

  var YellowBoxList = function (_React$Component) {
    _inherits(YellowBoxList, _React$Component);

    var _super = _createSuper(YellowBoxList);

    function YellowBoxList() {
      var _this;

      _classCallCheck(this, YellowBoxList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        selectedCategory: null
      };

      _this._handleInspectorDismiss = function () {
        var category = _this.state.selectedCategory;

        if (category == null) {
          return;
        }

        _this.setState({
          selectedCategory: null
        }, function () {
          _this.props.onDismiss(category);
        });
      };

      _this._handleInspectorMinimize = function () {
        _this.setState({
          selectedCategory: null
        });
      };

      _this._handleRowPress = function (category) {
        _this.setState({
          selectedCategory: category
        });
      };

      return _this;
    }

    _createClass(YellowBoxList, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var selectedWarnings = this.state.selectedCategory == null ? null : this.props.registry.get(this.state.selectedCategory);

        if (selectedWarnings != null) {
          return React.createElement(View, {
            style: StyleSheet.absoluteFill,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 56,
              columnNumber: 9
            }
          }, React.createElement(YellowBoxInspector, {
            onDismiss: this._handleInspectorDismiss,
            onMinimize: this._handleInspectorMinimize,
            warnings: selectedWarnings,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 57,
              columnNumber: 11
            }
          }));
        }

        var items = [];

        for (var _iterator = _createForOfIteratorHelperLoose(this.props.registry), _step; !(_step = _iterator()).done;) {
          var _ref = _step.value;

          var _ref2 = _slicedToArray(_ref, 2);

          var _category = _ref2[0];
          var warnings = _ref2[1];
          items.unshift({
            category: _category,
            warnings: warnings
          });
        }

        var listStyle = {
          height: Math.min(items.length, MAX_ITEMS + 0.5) * (YellowBoxListRow.GUTTER + YellowBoxListRow.HEIGHT)
        };
        return items.length === 0 ? null : React.createElement(View, {
          style: styles.list,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 79,
            columnNumber: 7
          }
        }, React.createElement(View, {
          pointerEvents: "box-none",
          style: styles.dismissAll,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 80,
            columnNumber: 9
          }
        }, React.createElement(YellowBoxButton, {
          hitSlop: {
            bottom: 4,
            left: 4,
            right: 4,
            top: 4
          },
          label: "Dismiss All",
          onPress: this.props.onDismissAll,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 81,
            columnNumber: 11
          }
        })), React.createElement(FlatList, {
          data: items,
          keyExtractor: function keyExtractor(item) {
            return item.category;
          },
          renderItem: function renderItem(_ref3) {
            var item = _ref3.item;
            return React.createElement(YellowBoxListRow, _extends({}, item, {
              onPress: _this2._handleRowPress,
              __self: _this2,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 91,
                columnNumber: 13
              }
            }));
          },
          scrollEnabled: items.length > MAX_ITEMS,
          scrollsToTop: false,
          style: listStyle,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 87,
            columnNumber: 9
          }
        }), React.createElement(SafeAreaView, {
          style: styles.safeArea,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 97,
            columnNumber: 9
          }
        }));
      }
    }]);

    return YellowBoxList;
  }(React.Component);

  var styles = StyleSheet.create({
    list: {
      bottom: 0,
      position: 'absolute',
      width: '100%'
    },
    dismissAll: {
      bottom: '100%',
      flexDirection: 'row',
      justifyContent: 'flex-end',
      paddingBottom: 4,
      paddingEnd: 4,
      position: 'absolute',
      width: '100%'
    },
    safeArea: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95),
      marginTop: StyleSheet.hairlineWidth
    }
  });
  module.exports = YellowBoxList;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxList.js",["node_modules_@babel_runtime_helpers_extends.js","node_modules_@babel_runtime_helpers_slicedToArray.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_Utilities_Dimensions.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Lists_FlatList.js","node_modules_react-native_Libraries_Components_SafeAreaView_SafeAreaView.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxButton.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspector.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxListRow.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxList.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[0], "requireNativeComponent");

  module.exports = requireNativeComponent('RCTSafeAreaView');
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Components_SafeAreaView_RCTSafeAreaViewNativeComponent.js",["node_modules_react-native_Libraries_ReactNative_requireNativeComponent.js"],"node_modules/react-native/Libraries/Components/SafeAreaView/RCTSafeAreaViewNativeComponent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _this = this,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxButton.js";

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[1], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[2], "Text");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[3], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[4], "YellowBoxStyle");

  var YellowBoxButton = function YellowBoxButton(props) {
    return React.createElement(YellowBoxPressable, {
      hitSlop: props.hitSlop,
      onPress: props.onPress,
      style: styles.root,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 28,
        columnNumber: 3
      }
    }, React.createElement(Text, {
      numberOfLines: 1,
      style: styles.label,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 5
      }
    }, props.label));
  };

  var styles = StyleSheet.create({
    root: {
      borderRadius: 14,
      height: 28,
      justifyContent: 'center',
      paddingHorizontal: 12
    },
    label: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 16
    }
  });
  module.exports = YellowBoxButton;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxButton.js",["node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxPressable.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxButton.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxPressable.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[6], "StyleSheet");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[7], "TouchableWithoutFeedback");

  var View = _$$_REQUIRE(_dependencyMap[8], "View");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[9], "YellowBoxStyle");

  var YellowBoxPressable = function (_React$Component) {
    _inherits(YellowBoxPressable, _React$Component);

    var _super = _createSuper(YellowBoxPressable);

    function YellowBoxPressable() {
      var _this;

      _classCallCheck(this, YellowBoxPressable);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        pressed: false
      };

      _this._handlePressIn = function () {
        _this.setState({
          pressed: true
        });
      };

      _this._handlePressOut = function () {
        _this.setState({
          pressed: false
        });
      };

      return _this;
    }

    _createClass(YellowBoxPressable, [{
      key: "render",
      value: function render() {
        var content = React.createElement(View, {
          style: StyleSheet.compose({
            backgroundColor: this.state.pressed ? this.props.backgroundColor.pressed : this.props.backgroundColor.default
          }, this.props.style),
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 52,
            columnNumber: 7
          }
        }, this.props.children);
        return this.props.onPress == null ? content : React.createElement(TouchableWithoutFeedback, {
          hitSlop: this.props.hitSlop,
          onPress: this.props.onPress,
          onPressIn: this._handlePressIn,
          onPressOut: this._handlePressOut,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67,
            columnNumber: 7
          }
        }, content);
      }
    }]);

    return YellowBoxPressable;
  }(React.Component);

  YellowBoxPressable.defaultProps = {
    backgroundColor: {
      default: YellowBoxStyle.getBackgroundColor(0.95),
      pressed: YellowBoxStyle.getHighlightColor(1)
    }
  };
  module.exports = YellowBoxPressable;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxPressable.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Components_Touchable_TouchableWithoutFeedback.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxPressable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var YellowBoxStyle = {
    getBackgroundColor: function getBackgroundColor(opacity) {
      return "rgba(250, 186, 48, " + opacity + ")";
    },
    getDividerColor: function getDividerColor(opacity) {
      return "rgba(255, 255, 255, " + opacity + ")";
    },
    getHighlightColor: function getHighlightColor(opacity) {
      return "rgba(252, 176, 29, " + opacity + ")";
    },
    getTextColor: function getTextColor(opacity) {
      return "rgba(255, 255, 255, " + opacity + ")";
    }
  };
  module.exports = YellowBoxStyle;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js",[],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxStyle.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspector.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Platform = _$$_REQUIRE(_dependencyMap[5], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[6], "React");

  var ScrollView = _$$_REQUIRE(_dependencyMap[7], "ScrollView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[8], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[9], "Text");

  var View = _$$_REQUIRE(_dependencyMap[10], "View");

  var YellowBoxCategory = _$$_REQUIRE(_dependencyMap[11], "YellowBoxCategory");

  var YellowBoxInspectorFooter = _$$_REQUIRE(_dependencyMap[12], "YellowBoxInspectorFooter");

  var YellowBoxInspectorHeader = _$$_REQUIRE(_dependencyMap[13], "YellowBoxInspectorHeader");

  var YellowBoxInspectorSourceMapStatus = _$$_REQUIRE(_dependencyMap[14], "YellowBoxInspectorSourceMapStatus");

  var YellowBoxInspectorStackFrame = _$$_REQUIRE(_dependencyMap[15], "YellowBoxInspectorStackFrame");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[16], "YellowBoxStyle");

  var openFileInEditor = _$$_REQUIRE(_dependencyMap[17], "openFileInEditor");

  var YellowBoxInspector = function (_React$Component) {
    _inherits(YellowBoxInspector, _React$Component);

    var _super = _createSuper(YellowBoxInspector);

    function YellowBoxInspector() {
      var _this;

      _classCallCheck(this, YellowBoxInspector);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        selectedIndex: 0
      };

      _this._handleRetrySymbolication = function () {
        _this._cancelSymbolication();

        _this.forceUpdate(function () {
          var warning = _this.props.warnings[_this.state.selectedIndex];
          _this._symbolication = warning.retrySymbolicate(function () {
            _this.forceUpdate();
          });
        });
      };

      _this._handleSelectIndex = function (selectedIndex) {
        _this.setState({
          selectedIndex: selectedIndex
        });
      };

      return _this;
    }

    _createClass(YellowBoxInspector, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var warnings = this.props.warnings;
        var selectedIndex = this.state.selectedIndex;
        var warning = warnings[selectedIndex];
        return React.createElement(View, {
          style: styles.root,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 55,
            columnNumber: 7
          }
        }, React.createElement(YellowBoxInspectorHeader, {
          onSelectIndex: this._handleSelectIndex,
          selectedIndex: selectedIndex,
          warnings: warnings,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 56,
            columnNumber: 9
          }
        }), React.createElement(ScrollView, {
          contentContainerStyle: styles.bodyContent,
          key: selectedIndex,
          style: styles.body,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 61,
            columnNumber: 9
          }
        }, React.createElement(View, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 65,
            columnNumber: 11
          }
        }, React.createElement(View, {
          style: styles.bodyHeading,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 66,
            columnNumber: 13
          }
        }, React.createElement(Text, {
          style: styles.bodyHeadingText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67,
            columnNumber: 15
          }
        }, "Warning")), React.createElement(Text, {
          style: styles.bodyText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 69,
            columnNumber: 13
          }
        }, YellowBoxCategory.render(warning.message, styles.substitutionText))), React.createElement(View, {
          style: styles.bodySection,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 76,
            columnNumber: 11
          }
        }, React.createElement(View, {
          style: styles.bodyHeading,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 77,
            columnNumber: 13
          }
        }, React.createElement(Text, {
          style: styles.bodyHeadingText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 78,
            columnNumber: 15
          }
        }, "Stack"), React.createElement(YellowBoxInspectorSourceMapStatus, {
          onPress: warning.symbolicated.status === 'FAILED' ? this._handleRetrySymbolication : null,
          status: warning.symbolicated.status,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 79,
            columnNumber: 15
          }
        })), warning.getAvailableStack().map(function (frame, index) {
          return React.createElement(YellowBoxInspectorStackFrame, {
            key: index,
            frame: frame,
            onPress: warning.symbolicated.status === 'COMPLETE' ? function () {
              openFileInEditor(frame.file, frame.lineNumber);
            } : null,
            __self: _this2,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 89,
              columnNumber: 15
            }
          });
        }))), React.createElement(YellowBoxInspectorFooter, {
          onDismiss: this.props.onDismiss,
          onMinimize: this.props.onMinimize,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 103,
            columnNumber: 9
          }
        }));
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._handleSymbolication();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (prevProps.warnings !== this.props.warnings || prevState.selectedIndex !== this.state.selectedIndex) {
          this._cancelSymbolication();

          this._handleSymbolication();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._cancelSymbolication();
      }
    }, {
      key: "_handleSymbolication",
      value: function _handleSymbolication() {
        var _this3 = this;

        var warning = this.props.warnings[this.state.selectedIndex];

        if (warning.symbolicated.status !== 'COMPLETE') {
          this._symbolication = warning.symbolicate(function () {
            _this3.forceUpdate();
          });
        }
      }
    }, {
      key: "_cancelSymbolication",
      value: function _cancelSymbolication() {
        if (this._symbolication != null) {
          this._symbolication.abort();

          this._symbolication = null;
        }
      }
    }]);

    return YellowBoxInspector;
  }(React.Component);

  var styles = StyleSheet.create({
    root: {
      elevation: Platform.OS === 'android' ? Number.MAX_SAFE_INTEGER : undefined,
      height: '100%'
    },
    body: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95),
      borderBottomColor: YellowBoxStyle.getDividerColor(0.95),
      borderBottomWidth: StyleSheet.hairlineWidth,
      borderTopColor: YellowBoxStyle.getDividerColor(0.95),
      borderTopWidth: StyleSheet.hairlineWidth,
      flex: 1
    },
    bodyContent: {
      paddingVertical: 12
    },
    bodyHeading: {
      alignItems: 'center',
      flexDirection: 'row',
      marginBottom: 6,
      paddingHorizontal: 12
    },
    bodyHeadingText: {
      color: YellowBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 20,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 28
    },
    bodyText: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18,
      paddingHorizontal: 12
    },
    substitutionText: {
      color: YellowBoxStyle.getTextColor(0.6)
    },
    bodySection: {
      marginTop: 20
    }
  });
  module.exports = YellowBoxInspector;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspector.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_Utilities_Platform.android.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Components_ScrollView_ScrollView.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxCategory.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorFooter.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorHeader.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorSourceMapStatus.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorStackFrame.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_openFileInEditor.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/toConsumableArray");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/Data/YellowBoxCategory.js";

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var React = _$$_REQUIRE(_dependencyMap[1], "React");

  var Text = _$$_REQUIRE(_dependencyMap[2], "Text");

  var UTFSequence = _$$_REQUIRE(_dependencyMap[3], "UTFSequence");

  var stringifySafe = _$$_REQUIRE(_dependencyMap[4], "stringifySafe");

  var SUBSTITUTION = UTFSequence.BOM + '%s';
  var YellowBoxCategory = {
    parse: function parse(args) {
      var categoryParts = [];
      var contentParts = [];
      var substitutionOffsets = [];

      var remaining = _toConsumableArray(args);

      if (typeof remaining[0] === 'string') {
        var formatString = String(remaining.shift());
        var formatStringParts = formatString.split('%s');
        var substitutionCount = formatStringParts.length - 1;
        var substitutions = remaining.splice(0, substitutionCount);
        var categoryString = '';
        var contentString = '';
        var substitutionIndex = 0;

        for (var _iterator = _createForOfIteratorHelperLoose(formatStringParts), _step; !(_step = _iterator()).done;) {
          var formatStringPart = _step.value;
          categoryString += formatStringPart;
          contentString += formatStringPart;

          if (substitutionIndex < substitutionCount) {
            if (substitutionIndex < substitutions.length) {
              var substitution = stringifySafe(substitutions[substitutionIndex]);
              substitutionOffsets.push({
                length: substitution.length,
                offset: contentString.length
              });
              categoryString += SUBSTITUTION;
              contentString += substitution;
            } else {
              substitutionOffsets.push({
                length: 2,
                offset: contentString.length
              });
              categoryString += '%s';
              contentString += '%s';
            }

            substitutionIndex++;
          }
        }

        categoryParts.push(categoryString);
        contentParts.push(contentString);
      }

      var remainingArgs = remaining.map(stringifySafe);
      categoryParts.push.apply(categoryParts, _toConsumableArray(remainingArgs));
      contentParts.push.apply(contentParts, _toConsumableArray(remainingArgs));
      return {
        category: categoryParts.join(' '),
        message: {
          content: contentParts.join(' '),
          substitutions: substitutionOffsets
        }
      };
    },
    render: function render(_ref, substitutionStyle) {
      var _this = this;

      var content = _ref.content,
          substitutions = _ref.substitutions;
      var elements = [];
      var lastOffset = substitutions.reduce(function (prevOffset, substitution, index) {
        var key = String(index);

        if (substitution.offset > prevOffset) {
          var prevPart = content.substr(prevOffset, substitution.offset - prevOffset);
          elements.push(React.createElement(Text, {
            key: key,
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 119,
              columnNumber: 25
            }
          }, prevPart));
        }

        var substititionPart = content.substr(substitution.offset, substitution.length);
        elements.push(React.createElement(Text, {
          key: key + '.5',
          style: substitutionStyle,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 127,
            columnNumber: 11
          }
        }, substititionPart));
        return substitution.offset + substitution.length;
      }, 0);

      if (lastOffset < content.length) {
        var lastPart = content.substr(lastOffset);
        elements.push(React.createElement(Text, {
          key: "-1",
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 139,
            columnNumber: 21
          }
        }, lastPart));
      }

      return elements;
    }
  };
  module.exports = YellowBoxCategory;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxCategory.js",["node_modules_@babel_runtime_helpers_toConsumableArray.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_UTFSequence.js","node_modules_react-native_Libraries_Utilities_stringifySafe.js"],"node_modules/react-native/Libraries/YellowBox/Data/YellowBoxCategory.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _this = this,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorFooter.js";

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  var SafeAreaView = _$$_REQUIRE(_dependencyMap[1], "SafeAreaView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[2], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[3], "Text");

  var View = _$$_REQUIRE(_dependencyMap[4], "View");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[5], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[6], "YellowBoxStyle");

  var YellowBoxInspectorFooter = function YellowBoxInspectorFooter(props) {
    return React.createElement(View, {
      style: styles.root,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 27,
        columnNumber: 3
      }
    }, React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: 'transparent',
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: props.onMinimize,
      style: styles.button,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 28,
        columnNumber: 5
      }
    }, React.createElement(View, {
      style: styles.content,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 35,
        columnNumber: 7
      }
    }, React.createElement(Text, {
      style: styles.label,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 36,
        columnNumber: 9
      }
    }, "Minimize")), React.createElement(SafeAreaView, {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 38,
        columnNumber: 7
      }
    })), React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: 'transparent',
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: props.onDismiss,
      style: styles.button,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 5
      }
    }, React.createElement(View, {
      style: styles.content,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 47,
        columnNumber: 7
      }
    }, React.createElement(Text, {
      style: styles.label,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 48,
        columnNumber: 9
      }
    }, "Dismiss")), React.createElement(SafeAreaView, {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 50,
        columnNumber: 7
      }
    })));
  };

  var styles = StyleSheet.create({
    root: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95),
      flexDirection: 'row'
    },
    button: {
      flex: 1
    },
    content: {
      alignItems: 'center',
      height: 48,
      justifyContent: 'center'
    },
    label: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    }
  });
  module.exports = YellowBoxInspectorFooter;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorFooter.js",["node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Components_SafeAreaView_SafeAreaView.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxPressable.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorFooter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _this = this,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorHeader.js";

  var Image = _$$_REQUIRE(_dependencyMap[0], "Image");

  var Platform = _$$_REQUIRE(_dependencyMap[1], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[2], "React");

  var SafeAreaView = _$$_REQUIRE(_dependencyMap[3], "SafeAreaView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[4], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[5], "Text");

  var View = _$$_REQUIRE(_dependencyMap[6], "View");

  var YellowBoxImageSource = _$$_REQUIRE(_dependencyMap[7], "YellowBoxImageSource");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[8], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[9], "YellowBoxStyle");

  var YellowBoxInspectorHeader = function YellowBoxInspectorHeader(props) {
    var prevIndex = props.selectedIndex - 1;
    var nextIndex = props.selectedIndex + 1;
    var titleText = props.warnings.length === 1 ? 'Single Occurrence' : "Occurrence " + (props.selectedIndex + 1) + " of " + props.warnings.length;
    return React.createElement(SafeAreaView, {
      style: styles.root,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 5
      }
    }, React.createElement(View, {
      style: styles.header,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 7
      }
    }, React.createElement(YellowBoxInspectorHeaderButton, {
      disabled: props.warnings[prevIndex] == null,
      image: YellowBoxImageSource.chevronLeft,
      onPress: function onPress() {
        return props.onSelectIndex(prevIndex);
      },
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 44,
        columnNumber: 9
      }
    }), React.createElement(View, {
      style: styles.headerTitle,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 49,
        columnNumber: 9
      }
    }, React.createElement(Text, {
      style: styles.headerTitleText,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 50,
        columnNumber: 11
      }
    }, titleText)), React.createElement(YellowBoxInspectorHeaderButton, {
      disabled: props.warnings[nextIndex] == null,
      image: YellowBoxImageSource.chevronRight,
      onPress: function onPress() {
        return props.onSelectIndex(nextIndex);
      },
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 52,
        columnNumber: 9
      }
    })));
  };

  var YellowBoxInspectorHeaderButton = function YellowBoxInspectorHeaderButton(props) {
    return React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: 'transparent',
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: props.disabled ? null : props.onPress,
      style: styles.headerButton,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 69,
        columnNumber: 3
      }
    }, props.disabled ? null : React.createElement(Image, {
      source: {
        height: 16,
        uri: props.image,
        width: 16
      },
      style: styles.headerButtonImage,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 77,
        columnNumber: 7
      }
    }));
  };

  var styles = StyleSheet.create({
    root: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95)
    },
    header: {
      flexDirection: 'row',
      height: Platform.select({
        android: 48,
        ios: 44
      })
    },
    headerButton: {
      alignItems: 'center',
      aspectRatio: 1,
      justifyContent: 'center'
    },
    headerButtonImage: {
      tintColor: YellowBoxStyle.getTextColor(1)
    },
    headerTitle: {
      alignItems: 'center',
      flex: 1,
      justifyContent: 'center'
    },
    headerTitleText: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 16,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    }
  });
  module.exports = YellowBoxInspectorHeader;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorHeader.js",["node_modules_react-native_Libraries_Image_Image.android.js","node_modules_react-native_Libraries_Utilities_Platform.android.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_Components_SafeAreaView_SafeAreaView.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxImageSource.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxPressable.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorHeader.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PixelRatio = _$$_REQUIRE(_dependencyMap[0], "PixelRatio");

  var scale = PixelRatio.get();
  /**
   * We use inline images for YellowBox in order to avoid display latency due to
   * resource contention with symbolicating stack traces.
   *
   * The following steps were used to create these:
   *
   *   1. Download SVG files from: https://feathericons.com
   *   2. Rasterize SVG files to PNG files at 16dp, 36dp, and 48dp.
   *   3. Convert to Base64: https://www.google.com/search?q=base64+image+encoder
   *
   * @see https://github.com/feathericons/feather
   * @copyright 2013-2017 Cole Bemis
   * @license MIT
   */

  var YellowBoxImageSource = {
    alertTriangle: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAB60lEQVRoge2Z3W3DIBSFj9oFPAIjZARGyAiMkBHuJh4hI2QEj5AR3Me+tQ91JALHmD8bKvmTkCr5Auc6/kzUACcnRXzuvL4GoAB8Afjeea9qXADcAfw4475c65orgBl++NeYl5ouUQiHt5tQTRJuwB6b5zLY49QVGn7I0bo+kuv60IQbuHf5CWCIqOkCgX93maia1MkRAUMo+OI+AvUPp7a50EzcUCBF6psJrUkYiZgnZJ7eId8mMeIyhpW5hyLw72LKCXsl86VqwgAKceKapW5e/nZpJnSsuHaTM7muyDq7C63JprJS69YxhNTpSlkpKeLGNHCo0EJChcSNaQA4SGiFtBMXJFSI3YVOPXFB6kMoUl9NaE0Wl4h5KQ0AOwqde+KmNrCL0EKCxJ64qQ0AlYVWSBfXZusgW6Oa0Dni2hiEv0qsoci+yUJrsoikLlKAkP11ygK54taiSOgb/O5b/DMqS+gBZeLWJlnoEX7XwQkBDPIktlEkz7hWrEmxZG4M5L9GXYTk0qxwcopKxa3VABN6cosM/C5LxTUof4ReMKHf1nRlaSnuGsGM7kfU4w8RF5Bz4aNlokLe/HQ/ngl9/Qih4L9k3h4hA1+S3odxu3Q77Hl4r1Hg75n6D01M2Difbp02Mi3ZTk5OLH4BUyEtOlDYuK0AAAAASUVORK5CYII=' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABVklEQVRYheWX4U3DMBBGH4gBMoJHyAgeoSNkAxjBG5QNOkJHCGzQDcoGZQP4gY3Oqe1cEscS4pNOqs9Jvqvv6ZrCf9fDhnutD4A3H810Br4mcW5l7hLmIdze5mZi+OJD5syeBYzC6CjyR5Ef9zI/CJMb0Im9zufC/qG2eQdchcGQuGYQ+9dJgZvl0B2xbJGrZW6IIevFXp9YVwcyB540syJfFcgSeJb0cVcDcg68XAFQCUhH+ShLBcBGIA158LQFqIB8zBRwEp9fgctcxQld/L2pZxZVAk/KkucjaDGQmoknrz35KEE2sABIRxm8tVIBaZgHb61UQOYmXk7aFgQVJ6QWPCnLAriYAVILnpTxD7yh/9EZiIEE4m+y29uMkGy1nQ6i9wYFRB5PwKdYP/v1msmnUe89gn695bG0iqjdXeMiRu9599csvGKZ0jlu0Ac/7d2rxX9Q37HW6QfX/ZguAAAAAElFTkSuQmCC' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAvUlEQVQ4jbWT4Q3CIBCFP40DdANxg24gIzhKuwEjuIFxAkcwTtARGicoG+iPXlMCB8UfvoQc4e7ePV4A/ogWuMlqc0W7AsEo0QMNcPplugMmwMia5KwKWkNIuIkHq3wLXGQ/Sq4IC3wkLpOfmZyKeEpIEKsDYB8VN0Afkfpg30uNiycbdKcNqXEOxdBEWoEAoqta8uZ0iqqkxwGDUrSFAXAHZpOWd/+ubD5Kz335Cx1wZna4Bh54AddauVl8ARfCLO9Xq7xGAAAAAElFTkSuQmCC',
    check: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAqElEQVRoge3YTQ7CIBRF4bPUu/8JS6gTSaqilh95vuR+CaO2cGgYNAUzMzOzFgHlPhRaMkDAcRoltKaTeIxPtQHxGn+Q5AgJx8cQjo8hHB9DOP76Yiu/RcTmN18WLiQCjs3zBkYXVGOeLWd+xcIr5pgyEzDz7FIjISPP/FRPUM+9W4nvYVfuCSXeB3669ldEOzRFfCUSx1cicXwlEsdXIvEPKDMzM7PMbtugw3XTpNA2AAAAAElFTkSuQmCC' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAf0lEQVRYhe2UvQ2AIBQGL3EBR3AESkv3bxxFN8DmWUgwvkI+En1X0cBd+IMg+DuDyDMCs413kfMiX4EMbD3l8oCaPIU85B4mYLEF5XJscrYFPRGvb/sZ4IlocubJGdH0wj1FSG77XYT0qdUi5O+8jOjyyZQRUnkZ0UUeBMF3OQC/0VsyGlxligAAAABJRU5ErkJggg==' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVQ4jWNgGJHAgIGBIYESze8ZGBjWU6L5PAMDgwBNNCdAFZJt83qoQmRDSHK2AFQhzBCy/IxsCNkBJsDAwLAfiknWPBIBAETPFeuA4fr6AAAAAElFTkSuQmCC',
    chevronLeft: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAgElEQVRoge3YMQ6DQBAEwRYvnf8nPAECbAnkyATsrt0lXUyPdAE6kCRJ/yXA+jopLbkhwHY6a2nNl8I1ftSA8Bm/MeQKBeNrBONrBONrBONrhMHxcPwOlMUvT32oszD8CoEj+giO6CE4oofgiB7Cj44Y86zyFoYPgOFPi5Ik6WwHji+QVIOyhqgAAAAASUVORK5CYII=' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAaUlEQVRYhe3WsQ2AMAwAwRcs5LEYg3HpYANoQKKgcEEUI/6adM5LbgySfmZsNDeACdiApdEfaQGswH6+Xd1jugc9xYQxxhjz9RhaxwxvDuul3MrAqDyjsozKKnWgXUqdsJcAZgqsTFJ5B7gjUNw0n0HHAAAAAElFTkSuQmCC' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVQ4jWNgGPKAmUh1AQwMDBIMDAwPyLEkgYGB4T/UELI1J9BdcwCxmpnIMZ1YkECsK+hmCNZoZCHCgAUMDAwfoHg4AgDJuQ/bcLyV+QAAAABJRU5ErkJggg==',
    chevronRight: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAeElEQVRoge3YMQ6AIBQE0Ykn3fs3HEEbC6MdFp+v8xJaspNQAZIkqbcA4zwpXTJpAPvlpHTNhHtAu4jwDDCiQjBiDcGINQQj1hCMWEN4Boy3l25vL/iL0PgJBcfXCI6vERxfIzi+Rmg8Hj7wrdL+Yys0/1qUJEmzDvSAkFQ8EOdJAAAAAElFTkSuQmCC' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAZElEQVRYhe3WsQmAQAxA0Y8ulLEcw3HtdANtBNvzCJjD/5pUgQ9pApJ+Zu7YCWABDmDLzemzA+c94+MW4AkqExUY1caoVka1GibqlSm7qJJSJzPGGGMylYqBgi9sACtFYiQN7wKC6VDcJ7tlpQAAAABJRU5ErkJggg==' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANUlEQVQ4jWNgGLbAgYGBIYASAwIYGBj+MzAwJFBiSMLQMISJEpMptp2mmimORgcGChPSEAIAHGENPH8gqdYAAAAASUVORK5CYII=',
    loader: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABXElEQVRoge2a3W3DMAyEr+0CHkGjaISOcKN4k6zQETpCR+gGzgbpQ10kcamIpKQ6avQBBPxg3pHwL2UDg/8LASxrcNdKnCwATmssrUyeWgnju/DmXs8tRP+Sh2kgAJga1rFlWj2rcMD5YqQh77QJLbzIORjyRIJQCJW5ngYo5AVlrsgkCGqbsDbAhFfxqZsSZibP0oDXQ43HQPsg82i7sBoR+VcJq2YxKcPo0IoJLRZXmYGC6ezQmQUdVqhPBVH/CNBTSMkLVlzjA8Bbocb7GoPBoADi+umZilYzbrG/JrnljOvy734iu4To/BQaDB6Rl4LciPPF9Lmjhgvi+s7w6tCIGw3WKS0P8fvWNjt0ZkGHFeq7CQXTbkZKGg2JOxrqPUZ3s6ziNdju38IjS/dLi0EQpDLX2gDQYHEX6Hx5/YcA+6H0NgAYPnCMj3x7Mxq4wTGx3Q1E578aDDR8AX0mOGD6BEN/AAAAAElFTkSuQmCC' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABN0lEQVRYhe2WzU3EMBCFP34KyJEjJaQDXAIlJJ24BSow2wEdhHSwJSwd7JHbcmC0mOxMnDiWDIInWbHkN29exo4n8IvRAEFGU8OAA04yulyR60Jm7msbyIZloAMGwBfI4UWrWxM08LW/weC4iOMNTog4g0awKjBG827GxBwC3996NHizAifsSrTRmlsZm23CT9adktyXSq6ZUPdxgiXnZzW8CLcLuC3lvqA/gCt5NtjlPQL7TP0Wu1HtRRu4PO3T4TKTz2kG+AG9IN6CR/Su9iojBw69egfghWgL/pGCp+JFVPUqTjWjlsuqeAo1o6rt2C8QcNiV0UxoHPMieojmz0CfMKyhl1hN84xbI3gnz5Ftp7kH3iT5LsFdDUf6pzSJ6r2glIFDbuDNhqRH4I7Pvv4EvG/QqocP2Jh/xzzX/zUAAAAASUVORK5CYII=' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAsklEQVQ4jaWTYRHCMAyFP7gJmIQ6oChgEpBQKXMwC3MADpAAEiphDuBHC4QuDRu8u9ylyWtem7Rgw2X7GT1wsghb4beAVzhtsfYyJgs44AoEQzBkjrMId1HkKPwyZ6oMSnxYsnk1NqT7yMo34Fzhd9meGJvs7Hh3NhqCLXDI/rT0lKsR+KOJgc9RdaRRarkZvELogYsi8HqxjUhGYE+aQg1jzketwFTZXHbbEpjB8eU7PwAbLiJz46707gAAAABJRU5ErkJggg=='
  };
  module.exports = YellowBoxImageSource;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxImageSource.js",["node_modules_react-native_Libraries_Utilities_PixelRatio.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxImageSource.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorSourceMapStatus.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Animated = _$$_REQUIRE(_dependencyMap[5], "Animated");

  var Easing = _$$_REQUIRE(_dependencyMap[6], "Easing");

  var React = _$$_REQUIRE(_dependencyMap[7], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[8], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[9], "Text");

  var YellowBoxImageSource = _$$_REQUIRE(_dependencyMap[10], "YellowBoxImageSource");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[11], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[12], "YellowBoxStyle");

  var YellowBoxInspectorSourceMapStatus = function (_React$Component) {
    _inherits(YellowBoxInspectorSourceMapStatus, _React$Component);

    var _super = _createSuper(YellowBoxInspectorSourceMapStatus);

    function YellowBoxInspectorSourceMapStatus() {
      var _this;

      _classCallCheck(this, YellowBoxInspectorSourceMapStatus);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        animation: null,
        rotate: null
      };
      return _this;
    }

    _createClass(YellowBoxInspectorSourceMapStatus, [{
      key: "render",
      value: function render() {
        var image;

        switch (this.props.status) {
          case 'COMPLETE':
            image = YellowBoxImageSource.check;
            break;

          case 'FAILED':
            image = YellowBoxImageSource.alertTriangle;
            break;

          case 'PENDING':
            image = YellowBoxImageSource.loader;
            break;
        }

        return image == null ? null : React.createElement(YellowBoxPressable, {
          backgroundColor: {
            default: YellowBoxStyle.getTextColor(0.8),
            pressed: YellowBoxStyle.getTextColor(0.6)
          },
          hitSlop: {
            bottom: 8,
            left: 8,
            right: 8,
            top: 8
          },
          onPress: this.props.onPress,
          style: StyleSheet.compose(styles.root, this.props.status === 'PENDING' ? styles.pending : null),
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 57,
            columnNumber: 7
          }
        }, React.createElement(Animated.Image, {
          source: {
            height: 16,
            uri: image,
            width: 16
          },
          style: StyleSheet.compose(styles.image, this.state.rotate == null ? null : {
            transform: [{
              rotate: this.state.rotate
            }]
          }),
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 68,
            columnNumber: 9
          }
        }), React.createElement(Text, {
          style: styles.text,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 77,
            columnNumber: 9
          }
        }, "Source Map"));
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._updateAnimation();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._updateAnimation();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.state.animation != null) {
          this.state.animation.stop();
        }
      }
    }, {
      key: "_updateAnimation",
      value: function _updateAnimation() {
        if (this.props.status === 'PENDING') {
          if (this.state.animation == null) {
            var animated = new Animated.Value(0);
            var animation = Animated.loop(Animated.timing(animated, {
              duration: 2000,
              easing: Easing.linear,
              toValue: 1,
              useNativeDriver: true
            }));
            this.setState({
              animation: animation,
              rotate: animated.interpolate({
                inputRange: [0, 1],
                outputRange: ['0deg', '360deg']
              })
            }, function () {
              animation.start();
            });
          }
        } else {
          if (this.state.animation != null) {
            this.state.animation.stop();
            this.setState({
              animation: null,
              rotate: null
            });
          }
        }
      }
    }]);

    return YellowBoxInspectorSourceMapStatus;
  }(React.Component);

  var styles = StyleSheet.create({
    root: {
      alignItems: 'center',
      borderRadius: 12,
      flexDirection: 'row',
      height: 24,
      paddingHorizontal: 8
    },
    pending: {
      backgroundColor: YellowBoxStyle.getTextColor(0.6)
    },
    image: {
      marginEnd: 4,
      tintColor: YellowBoxStyle.getBackgroundColor(1)
    },
    text: {
      color: YellowBoxStyle.getBackgroundColor(1),
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 16
    }
  });
  module.exports = YellowBoxInspectorSourceMapStatus;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorSourceMapStatus.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_Animated_src_Animated.js","node_modules_react-native_Libraries_Animated_src_Easing.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxImageSource.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxPressable.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorSourceMapStatus.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _this = this,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorStackFrame.js";

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[1], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[2], "Text");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[3], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[4], "YellowBoxStyle");

  var YellowBoxInspectorStackFrame = function YellowBoxInspectorStackFrame(props) {
    var frame = props.frame,
        onPress = props.onPress;
    return React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: YellowBoxStyle.getBackgroundColor(0),
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: onPress,
      style: styles.frame,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 31,
        columnNumber: 5
      }
    }, React.createElement(Text, {
      style: styles.frameName,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 38,
        columnNumber: 7
      }
    }, frame.methodName), React.createElement(Text, {
      ellipsizeMode: "middle",
      numberOfLines: 1,
      style: styles.frameLocation,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 7
      }
    }, getFrameLocation(frame.file) + ":" + frame.lineNumber + (frame.column == null ? '' : ':' + frame.column)));
  };

  var getFrameLocation = function getFrameLocation(uri) {
    var queryIndex = uri.indexOf('?');
    var query = queryIndex < 0 ? '' : uri.substr(queryIndex);
    var path = queryIndex < 0 ? uri : uri.substr(0, queryIndex);
    var file = path.substr(path.lastIndexOf('/') + 1);
    return file + query;
  };

  var styles = StyleSheet.create({
    frame: {
      paddingHorizontal: 12,
      paddingVertical: 4
    },
    frameName: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    },
    frameLocation: {
      color: YellowBoxStyle.getTextColor(0.7),
      fontSize: 12,
      fontWeight: '300',
      includeFontPadding: false,
      lineHeight: 16
    }
  });
  module.exports = YellowBoxInspectorStackFrame;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxInspectorStackFrame.js",["node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxPressable.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxInspectorStackFrame.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/node_modules/react-native/Libraries/YellowBox/UI/YellowBoxListRow.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[6], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[7], "Text");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[8], "YellowBoxPressable");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var YellowBoxCategory = _$$_REQUIRE(_dependencyMap[10], "YellowBoxCategory");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[11], "YellowBoxStyle");

  var YellowBoxWarning = _$$_REQUIRE(_dependencyMap[12], "YellowBoxWarning");

  var YellowBoxListRow = function (_React$Component) {
    _inherits(YellowBoxListRow, _React$Component);

    var _super = _createSuper(YellowBoxListRow);

    function YellowBoxListRow() {
      var _this;

      _classCallCheck(this, YellowBoxListRow);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this._handlePress = function () {
        _this.props.onPress(_this.props.category);
      };

      return _this;
    }

    _createClass(YellowBoxListRow, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps) {
        var prevProps = this.props;
        return prevProps.category !== nextProps.category || prevProps.onPress !== nextProps.onPress || prevProps.warnings.length !== nextProps.warnings.length || prevProps.warnings.some(function (prevWarning, index) {
          return prevWarning !== nextProps[index];
        });
      }
    }, {
      key: "render",
      value: function render() {
        var warnings = this.props.warnings;
        return React.createElement(YellowBoxPressable, {
          onPress: this._handlePress,
          style: styles.root,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 50,
            columnNumber: 7
          }
        }, React.createElement(View, {
          style: styles.content,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 51,
            columnNumber: 9
          }
        }, warnings.length < 2 ? null : React.createElement(Text, {
          style: styles.metaText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 53,
            columnNumber: 13
          }
        }, '(' + warnings.length + ') '), React.createElement(Text, {
          numberOfLines: 2,
          style: styles.bodyText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 55,
            columnNumber: 11
          }
        }, YellowBoxCategory.render(warnings[warnings.length - 1].message, styles.substitutionText))));
      }
    }]);

    return YellowBoxListRow;
  }(React.Component);

  YellowBoxListRow.GUTTER = StyleSheet.hairlineWidth;
  YellowBoxListRow.HEIGHT = 48;
  var styles = StyleSheet.create({
    root: {
      height: YellowBoxListRow.HEIGHT,
      justifyContent: 'center',
      marginTop: YellowBoxListRow.GUTTER,
      paddingHorizontal: 12
    },
    content: {
      alignItems: 'flex-start',
      flexDirection: 'row'
    },
    bodyText: {
      color: YellowBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    },
    metaText: {
      color: YellowBoxStyle.getTextColor(0.5),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    },
    substitutionText: {
      color: YellowBoxStyle.getTextColor(0.6)
    }
  });
  module.exports = YellowBoxListRow;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxListRow.js",["node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react-native_Libraries_react-native_React.js","node_modules_react-native_Libraries_StyleSheet_StyleSheet.js","node_modules_react-native_Libraries_Text_Text.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxPressable.js","node_modules_react-native_Libraries_Components_View_View.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxCategory.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_UI_YellowBoxStyle.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxWarning.js"],"node_modules/react-native/Libraries/YellowBox/UI/YellowBoxListRow.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var YellowBoxCategory = _$$_REQUIRE(_dependencyMap[3], "YellowBoxCategory");

  var YellowBoxSymbolication = _$$_REQUIRE(_dependencyMap[4], "YellowBoxSymbolication");

  var parseErrorStack = _$$_REQUIRE(_dependencyMap[5], "parseErrorStack");

  var YellowBoxWarning = function () {
    function YellowBoxWarning(message, stack) {
      _classCallCheck(this, YellowBoxWarning);

      this.symbolicated = {
        error: null,
        stack: null,
        status: 'NONE'
      };
      this.message = message;
      this.stack = stack;
    }

    _createClass(YellowBoxWarning, [{
      key: "getAvailableStack",
      value: function getAvailableStack() {
        return this.symbolicated.status === 'COMPLETE' ? this.symbolicated.stack : this.stack;
      }
    }, {
      key: "retrySymbolicate",
      value: function retrySymbolicate(callback) {
        YellowBoxSymbolication.delete(this.stack);
        return this.symbolicate(callback);
      }
    }, {
      key: "symbolicate",
      value: function symbolicate(callback) {
        var _this = this;

        var aborted = false;

        if (this.symbolicated.status !== 'COMPLETE') {
          var updateStatus = function updateStatus(error, stack) {
            if (error != null) {
              _this.symbolicated = {
                error: error,
                stack: null,
                status: 'FAILED'
              };
            } else if (stack != null) {
              _this.symbolicated = {
                error: null,
                stack: stack,
                status: 'COMPLETE'
              };
            } else {
              _this.symbolicated = {
                error: null,
                stack: null,
                status: 'PENDING'
              };
            }

            if (!aborted) {
              callback();
            }
          };

          updateStatus(null, null);
          YellowBoxSymbolication.symbolicate(this.stack).then(function (stack) {
            updateStatus(null, stack);
          }, function (error) {
            updateStatus(error, null);
          });
        }

        return {
          abort: function abort() {
            aborted = true;
          }
        };
      }
    }], [{
      key: "parse",
      value: function parse(_ref) {
        var args = _ref.args,
            framesToPop = _ref.framesToPop;
        return _extends({}, YellowBoxCategory.parse(args), {
          stack: createStack({
            framesToPop: framesToPop + 1
          })
        });
      }
    }]);

    return YellowBoxWarning;
  }();

  function createStack(_ref2) {
    var framesToPop = _ref2.framesToPop;
    var error = new Error();
    error.framesToPop = framesToPop + 1;
    return parseErrorStack(error);
  }

  module.exports = YellowBoxWarning;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxWarning.js",["node_modules_@babel_runtime_helpers_extends.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxCategory.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxSymbolication.js","node_modules_react-native_Libraries_Core_Devtools_parseErrorStack.js"],"node_modules/react-native/Libraries/YellowBox/Data/YellowBoxWarning.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var symbolicateStackTrace = _$$_REQUIRE(_dependencyMap[0], "symbolicateStackTrace");

  var cache = new Map();
  var YellowBoxSymbolication = {
    delete: function _delete(stack) {
      cache.delete(getCacheKey(stack));
    },
    symbolicate: function symbolicate(stack) {
      var key = getCacheKey(stack);
      var promise = cache.get(key);

      if (promise == null) {
        promise = symbolicateStackTrace(stack).then(sanitize);
        cache.set(key, promise);
      }

      return promise;
    }
  };

  var getCacheKey = function getCacheKey(stack) {
    return JSON.stringify(stack);
  };

  var sanitize = function sanitize(maybeStack) {
    if (!Array.isArray(maybeStack)) {
      throw new Error('Expected stack to be an array.');
    }

    var stack = [];

    for (var _iterator = _createForOfIteratorHelperLoose(maybeStack), _step; !(_step = _iterator()).done;) {
      var maybeFrame = _step.value;

      if (typeof maybeFrame !== 'object' || maybeFrame == null) {
        throw new Error('Expected each stack frame to be an object.');
      }

      if (typeof maybeFrame.column !== 'number' && maybeFrame.column != null) {
        throw new Error('Expected stack frame `column` to be a nullable number.');
      }

      if (typeof maybeFrame.file !== 'string') {
        throw new Error('Expected stack frame `file` to be a string.');
      }

      if (typeof maybeFrame.lineNumber !== 'number') {
        throw new Error('Expected stack frame `lineNumber` to be a number.');
      }

      if (typeof maybeFrame.methodName !== 'string') {
        throw new Error('Expected stack frame `methodName` to be a string.');
      }

      stack.push({
        column: maybeFrame.column,
        file: maybeFrame.file,
        lineNumber: maybeFrame.lineNumber,
        methodName: maybeFrame.methodName
      });
    }

    return stack;
  };

  module.exports = YellowBoxSymbolication;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxSymbolication.js",["system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Core_Devtools_symbolicateStackTrace.js"],"node_modules/react-native/Libraries/YellowBox/Data/YellowBoxSymbolication.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/toConsumableArray");

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/slicedToArray");

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var YellowBoxWarning = _$$_REQUIRE(_dependencyMap[2], "YellowBoxWarning");

  var observers = new Set();
  var ignorePatterns = new Set();
  var registry = new Map();
  var disabled = false;
  var projection = new Map();
  var updateTimeout = null;

  function isWarningIgnored(warning) {
    for (var _iterator = _createForOfIteratorHelperLoose(ignorePatterns), _step; !(_step = _iterator()).done;) {
      var pattern = _step.value;

      if (warning.message.content.includes(pattern)) {
        return true;
      }
    }

    return false;
  }

  function handleUpdate() {
    projection = new Map();

    if (!disabled) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(registry), _step2; !(_step2 = _iterator2()).done;) {
        var _ref = _step2.value;

        var _ref2 = _slicedToArray(_ref, 2);

        var category = _ref2[0];
        var warnings = _ref2[1];
        var filtered = warnings.filter(function (warning) {
          return !isWarningIgnored(warning);
        });

        if (filtered.length > 0) {
          projection.set(category, filtered);
        }
      }
    }

    if (updateTimeout == null) {
      updateTimeout = setImmediate(function () {
        updateTimeout = null;

        for (var _iterator3 = _createForOfIteratorHelperLoose(observers), _step3; !(_step3 = _iterator3()).done;) {
          var _ref3 = _step3.value;
          var observer = _ref3.observer;
          observer(projection);
        }
      });
    }
  }

  var YellowBoxRegistry = {
    add: function add(_ref4) {
      var args = _ref4.args,
          framesToPop = _ref4.framesToPop;

      if (typeof args[0] === 'string' && args[0].startsWith('(ADVICE)')) {
        return;
      }

      var _YellowBoxWarning$par = YellowBoxWarning.parse({
        args: args,
        framesToPop: framesToPop + 1
      }),
          category = _YellowBoxWarning$par.category,
          message = _YellowBoxWarning$par.message,
          stack = _YellowBoxWarning$par.stack;

      var warnings = registry.get(category);

      if (warnings == null) {
        warnings = [];
      }

      warnings = [].concat(_toConsumableArray(warnings), [new YellowBoxWarning(message, stack)]);
      registry.delete(category);
      registry.set(category, warnings);
      handleUpdate();
    },
    delete: function _delete(category) {
      if (registry.has(category)) {
        registry.delete(category);
        handleUpdate();
      }
    },
    clear: function clear() {
      if (registry.size > 0) {
        registry.clear();
        handleUpdate();
      }
    },
    addIgnorePatterns: function addIgnorePatterns(patterns) {
      var newPatterns = patterns.filter(function (pattern) {
        return !ignorePatterns.has(pattern);
      });

      if (newPatterns.length === 0) {
        return;
      }

      for (var _iterator4 = _createForOfIteratorHelperLoose(newPatterns), _step4; !(_step4 = _iterator4()).done;) {
        var pattern = _step4.value;
        ignorePatterns.add(pattern);
      }

      handleUpdate();
    },
    setDisabled: function setDisabled(value) {
      if (value === disabled) {
        return;
      }

      disabled = value;
      handleUpdate();
    },
    isDisabled: function isDisabled() {
      return disabled;
    },
    observe: function observe(observer) {
      var subscription = {
        observer: observer
      };
      observers.add(subscription);
      observer(projection);
      return {
        unsubscribe: function unsubscribe() {
          observers.delete(subscription);
        }
      };
    }
  };
  module.exports = YellowBoxRegistry;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxRegistry.js",["node_modules_@babel_runtime_helpers_toConsumableArray.js","node_modules_@babel_runtime_helpers_slicedToArray.js","system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_YellowBox_Data_YellowBoxWarning.js"],"node_modules/react-native/Libraries/YellowBox/Data/YellowBoxRegistry.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var EventValidator = {
    addValidation: function addValidation(emitter, types) {
      var eventTypes = Object.keys(types);
      var emitterWithValidation = Object.create(emitter);

      _extends(emitterWithValidation, {
        emit: function emit(type, a, b, c, d, e, _) {
          assertAllowsEventType(type, eventTypes);
          return emitter.emit.call(this, type, a, b, c, d, e, _);
        }
      });

      return emitterWithValidation;
    }
  };

  function assertAllowsEventType(type, allowedTypes) {
    if (allowedTypes.indexOf(type) === -1) {
      throw new TypeError(errorMessageFor(type, allowedTypes));
    }
  }

  function errorMessageFor(type, allowedTypes) {
    var message = 'Unknown event type "' + type + '". ';

    if (__DEV__) {
      message += recommendationFor(type, allowedTypes);
    }

    message += 'Known event types: ' + allowedTypes.join(', ') + '.';
    return message;
  }

  if (__DEV__) {
    var recommendationFor = function recommendationFor(type, allowedTypes) {
      var closestTypeRecommendation = closestTypeFor(type, allowedTypes);

      if (isCloseEnough(closestTypeRecommendation, type)) {
        return 'Did you mean "' + closestTypeRecommendation.type + '"? ';
      } else {
        return '';
      }
    };

    var closestTypeFor = function closestTypeFor(type, allowedTypes) {
      var typeRecommendations = allowedTypes.map(typeRecommendationFor.bind(this, type));
      return typeRecommendations.sort(recommendationSort)[0];
    };

    var typeRecommendationFor = function typeRecommendationFor(type, recommendedType) {
      return {
        type: recommendedType,
        distance: damerauLevenshteinDistance(type, recommendedType)
      };
    };

    var recommendationSort = function recommendationSort(recommendationA, recommendationB) {
      if (recommendationA.distance < recommendationB.distance) {
        return -1;
      } else if (recommendationA.distance > recommendationB.distance) {
        return 1;
      } else {
        return 0;
      }
    };

    var isCloseEnough = function isCloseEnough(closestType, actualType) {
      return closestType.distance / actualType.length < 0.334;
    };

    var damerauLevenshteinDistance = function damerauLevenshteinDistance(a, b) {
      var i, j;
      var d = [];

      for (i = 0; i <= a.length; i++) {
        d[i] = [i];
      }

      for (j = 1; j <= b.length; j++) {
        d[0][j] = j;
      }

      for (i = 1; i <= a.length; i++) {
        for (j = 1; j <= b.length; j++) {
          var cost = a.charAt(i - 1) === b.charAt(j - 1) ? 0 : 1;
          d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);

          if (i > 1 && j > 1 && a.charAt(i - 1) === b.charAt(j - 2) && a.charAt(i - 2) === b.charAt(j - 1)) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
          }
        }
      }

      return d[a.length][b.length];
    };
  }

  module.exports = EventValidator;
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_vendor_emitter_EventValidator.js",["node_modules_@babel_runtime_helpers_extends.js"],"node_modules/react-native/Libraries/vendor/emitter/EventValidator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  if (__DEV__) {
    (function () {
      "use strict";

      _$$_REQUIRE(_dependencyMap[1], "InitializeCore");

      var ReactNativeViewConfigRegistry = _$$_REQUIRE(_dependencyMap[2], "ReactNativeViewConfigRegistry");

      var UIManager = _$$_REQUIRE(_dependencyMap[3], "UIManager");

      var React = _$$_REQUIRE(_dependencyMap[4], "react");

      var deepDiffer = _$$_REQUIRE(_dependencyMap[5], "deepDiffer");

      var flattenStyle = _$$_REQUIRE(_dependencyMap[6], "flattenStyle");

      var deepFreezeAndThrowOnMutationInDev = _$$_REQUIRE(_dependencyMap[7], "deepFreezeAndThrowOnMutationInDev");

      var TextInputState = _$$_REQUIRE(_dependencyMap[8], "TextInputState");

      var FabricUIManager = _$$_REQUIRE(_dependencyMap[9], "FabricUIManager");

      var checkPropTypes = _$$_REQUIRE(_dependencyMap[10], "prop-types/checkPropTypes");

      var tracing = _$$_REQUIRE(_dependencyMap[11], "scheduler/tracing");

      var scheduler = _$$_REQUIRE(_dependencyMap[12], "scheduler");

      var ExceptionsManager = _$$_REQUIRE(_dependencyMap[13], "ExceptionsManager");

      var validateFormat = function validateFormat() {};

      {
        validateFormat = function validateFormat(format) {
          if (format === undefined) {
            throw new Error("invariant requires an error message argument");
          }
        };
      }

      function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);

        if (!condition) {
          var error = void 0;

          if (format === undefined) {
            error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function () {
              return args[argIndex++];
            }));
            error.name = "Invariant Violation";
          }

          error.framesToPop = 1;
          throw error;
        }
      }

      var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);

        try {
          func.apply(context, funcArgs);
        } catch (error) {
          this.onError(error);
        }
      };

      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");

          var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            invariant(typeof document !== "undefined", "The `document` global was defined when React was initialized, but is not " + "defined anymore. This can happen in a test environment if a component " + "schedules an update from an asynchronous callback, but the test has already " + "finished running. To solve this, you can either unmount the component at " + "the end of your test (and ensure that any asynchronous operations get " + "canceled in `componentWillUnmount`), or you can change the test itself " + "to be asynchronous.");
            var evt = document.createEvent("Event");
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            var funcArgs = Array.prototype.slice.call(arguments, 3);

            function callCallback() {
              fakeNode.removeEventListener(evtType, callCallback, false);

              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }

              func.apply(context, funcArgs);
              didError = false;
            }

            var error = void 0;
            var didSetError = false;
            var isCrossOriginError = false;

            function handleWindowError(event) {
              error = event.error;
              didSetError = true;

              if (error === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }

              if (event.defaultPrevented) {
                if (error != null && typeof error === "object") {
                  try {
                    error._suppressLogging = true;
                  } catch (inner) {}
                }
              }
            }

            var evtType = "react-" + (name ? name : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);

            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }

            if (didError) {
              if (!didSetError) {
                error = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
              } else if (isCrossOriginError) {
                error = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://fb.me/react-crossorigin-error for more information.");
              }

              this.onError(error);
            }

            window.removeEventListener("error", handleWindowError);
          };

          invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function onError(error) {
          hasError = true;
          caughtError = error;
        }
      };

      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }

      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);

        if (hasError) {
          var error = clearCaughtError();

          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error;
          }
        }
      }

      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error;
        }
      }

      function hasCaughtError() {
        return hasError;
      }

      function clearCaughtError() {
        if (hasError) {
          var error = caughtError;
          hasError = false;
          caughtError = null;
          return error;
        } else {
          invariant(false, "clearCaughtError was called but no error was captured. This error " + "is likely caused by a bug in React. Please file an issue.");
        }
      }

      var eventPluginOrder = null;
      var namesToPlugins = {};

      function recomputePluginOrdering() {
        if (!eventPluginOrder) {
          return;
        }

        for (var pluginName in namesToPlugins) {
          var pluginModule = namesToPlugins[pluginName];
          var pluginIndex = eventPluginOrder.indexOf(pluginName);
          invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName);

          if (plugins[pluginIndex]) {
            continue;
          }

          invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName);
          plugins[pluginIndex] = pluginModule;
          var publishedEvents = pluginModule.eventTypes;

          for (var eventName in publishedEvents) {
            invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
          }
        }
      }

      function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
        invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName);
        eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

        if (phasedRegistrationNames) {
          for (var phaseName in phasedRegistrationNames) {
            if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
              var phasedRegistrationName = phasedRegistrationNames[phaseName];
              publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
            }
          }

          return true;
        } else if (dispatchConfig.registrationName) {
          publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
          return true;
        }

        return false;
      }

      function publishRegistrationName(registrationName, pluginModule, eventName) {
        invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName);
        registrationNameModules[registrationName] = pluginModule;
        registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
        }
      }

      var plugins = [];
      var eventNameDispatchConfigs = {};
      var registrationNameModules = {};
      var registrationNameDependencies = {};

      function injectEventPluginOrder(injectedEventPluginOrder) {
        invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.");
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      }

      function injectEventPluginsByName(injectedNamesToPlugins) {
        var isOrderingDirty = false;

        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }

          var pluginModule = injectedNamesToPlugins[pluginName];

          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
            invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName);
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }

        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      }

      var warningWithoutStack = function warningWithoutStack() {};

      {
        warningWithoutStack = function warningWithoutStack(condition, format) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          if (format === undefined) {
            throw new Error("`warningWithoutStack(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (args.length > 8) {
            throw new Error("warningWithoutStack() currently supports at most 8 arguments.");
          }

          if (condition) {
            return;
          }

          if (typeof console !== "undefined") {
            var argsWithFormat = args.map(function (item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console.error, console, argsWithFormat);
          }

          try {
            var argIndex = 0;
            var message = "Warning: " + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            throw new Error(message);
          } catch (x) {}
        };
      }
      var warningWithoutStack$1 = warningWithoutStack;
      var getFiberCurrentPropsFromNode = null;
      var getInstanceFromNode = null;
      var getNodeFromInstance = null;

      function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
        getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
        getInstanceFromNode = getInstanceFromNodeImpl;
        getNodeFromInstance = getNodeFromInstanceImpl;
        {
          !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, "EventPluginUtils.setComponentTree(...): Injected " + "module is missing getNodeFromInstance or getInstanceFromNode.") : void 0;
        }
      }

      var validateEventDispatches = void 0;
      {
        validateEventDispatches = function validateEventDispatches(event) {
          var dispatchListeners = event._dispatchListeners;
          var dispatchInstances = event._dispatchInstances;
          var listenersIsArr = Array.isArray(dispatchListeners);
          var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
          var instancesIsArr = Array.isArray(dispatchInstances);
          var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
          !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, "EventPluginUtils: Invalid `event`.") : void 0;
        };
      }

      function executeDispatch(event, listener, inst) {
        var type = event.type || "unknown-event";
        event.currentTarget = getNodeFromInstance(inst);
        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
      }

      function executeDispatchesInOrder(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
          }
        } else if (dispatchListeners) {
          executeDispatch(event, dispatchListeners, dispatchInstances);
        }

        event._dispatchListeners = null;
        event._dispatchInstances = null;
      }

      function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            if (dispatchListeners[i](event, dispatchInstances[i])) {
              return dispatchInstances[i];
            }
          }
        } else if (dispatchListeners) {
          if (dispatchListeners(event, dispatchInstances)) {
            return dispatchInstances;
          }
        }

        return null;
      }

      function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        event._dispatchInstances = null;
        event._dispatchListeners = null;
        return ret;
      }

      function executeDirectDispatch(event) {
        {
          validateEventDispatches(event);
        }
        var dispatchListener = event._dispatchListeners;
        var dispatchInstance = event._dispatchInstances;
        invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
        event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
        var res = dispatchListener ? dispatchListener(event) : null;
        event.currentTarget = null;
        event._dispatchListeners = null;
        event._dispatchInstances = null;
        return res;
      }

      function hasDispatches(event) {
        return !!event._dispatchListeners;
      }

      function accumulateInto(current, next) {
        invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          if (Array.isArray(next)) {
            current.push.apply(current, next);
            return current;
          }

          current.push(next);
          return current;
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      function forEachAccumulated(arr, cb, scope) {
        if (Array.isArray(arr)) {
          arr.forEach(cb, scope);
        } else if (arr) {
          cb.call(scope, arr);
        }
      }

      var eventQueue = null;

      var executeDispatchesAndRelease = function executeDispatchesAndRelease(event) {
        if (event) {
          executeDispatchesInOrder(event);

          if (!event.isPersistent()) {
            event.constructor.release(event);
          }
        }
      };

      var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
        return executeDispatchesAndRelease(e);
      };

      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }

      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
            return !!(props.disabled && isInteractive(type));

          default:
            return false;
        }
      }

      var injection = {
        injectEventPluginOrder: injectEventPluginOrder,
        injectEventPluginsByName: injectEventPluginsByName
      };

      function getListener(inst, registrationName) {
        var listener = void 0;
        var stateNode = inst.stateNode;

        if (!stateNode) {
          return null;
        }

        var props = getFiberCurrentPropsFromNode(stateNode);

        if (!props) {
          return null;
        }

        listener = props[registrationName];

        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }

        invariant(!listener || typeof listener === "function", "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
        return listener;
      }

      function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = null;

        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];

          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);

            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }

        return events;
      }

      function runEventsInBatch(events) {
        if (events !== null) {
          eventQueue = accumulateInto(eventQueue, events);
        }

        var processingEventQueue = eventQueue;
        eventQueue = null;

        if (!processingEventQueue) {
          return;
        }

        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.");
        rethrowCaughtError();
      }

      function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        runEventsInBatch(events);
      }

      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;
      var DehydratedSuspenseComponent = 18;

      function getParent(inst) {
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);

        if (inst) {
          return inst;
        }

        return null;
      }

      function getLowestCommonAncestor(instA, instB) {
        var depthA = 0;

        for (var tempA = instA; tempA; tempA = getParent(tempA)) {
          depthA++;
        }

        var depthB = 0;

        for (var tempB = instB; tempB; tempB = getParent(tempB)) {
          depthB++;
        }

        while (depthA - depthB > 0) {
          instA = getParent(instA);
          depthA--;
        }

        while (depthB - depthA > 0) {
          instB = getParent(instB);
          depthB--;
        }

        var depth = depthA;

        while (depth--) {
          if (instA === instB || instA === instB.alternate) {
            return instA;
          }

          instA = getParent(instA);
          instB = getParent(instB);
        }

        return null;
      }

      function isAncestor(instA, instB) {
        while (instB) {
          if (instA === instB || instA === instB.alternate) {
            return true;
          }

          instB = getParent(instB);
        }

        return false;
      }

      function getParentInstance(inst) {
        return getParent(inst);
      }

      function traverseTwoPhase(inst, fn, arg) {
        var path = [];

        while (inst) {
          path.push(inst);
          inst = getParent(inst);
        }

        var i = void 0;

        for (i = path.length; i-- > 0;) {
          fn(path[i], "captured", arg);
        }

        for (i = 0; i < path.length; i++) {
          fn(path[i], "bubbled", arg);
        }
      }

      function listenerAtPhase(inst, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(inst, registrationName);
      }

      function accumulateDirectionalDispatches(inst, phase, event) {
        {
          !inst ? warningWithoutStack$1(false, "Dispatching inst must not be null") : void 0;
        }
        var listener = listenerAtPhase(inst, event, phase);

        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }

      function accumulateTwoPhaseDispatchesSingle(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          var targetInst = event._targetInst;
          var parentInst = targetInst ? getParentInstance(targetInst) : null;
          traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateDispatches(inst, ignoredDirection, event) {
        if (inst && event && event.dispatchConfig.registrationName) {
          var registrationName = event.dispatchConfig.registrationName;
          var listener = getListener(inst, registrationName);

          if (listener) {
            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
          }
        }
      }

      function accumulateDirectDispatchesSingle(event) {
        if (event && event.dispatchConfig.registrationName) {
          accumulateDispatches(event._targetInst, null, event);
        }
      }

      function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
      }

      function accumulateTwoPhaseDispatchesSkipTarget(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
      }

      function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle);
      }

      var EVENT_POOL_SIZE = 10;
      var EventInterface = {
        type: null,
        target: null,
        currentTarget: function currentTarget() {
          return null;
        },
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function timeStamp(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: null,
        isTrusted: null
      };

      function functionThatReturnsTrue() {
        return true;
      }

      function functionThatReturnsFalse() {
        return false;
      }

      function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
        {
          delete this.nativeEvent;
          delete this.preventDefault;
          delete this.stopPropagation;
          delete this.isDefaultPrevented;
          delete this.isPropagationStopped;
        }
        this.dispatchConfig = dispatchConfig;
        this._targetInst = targetInst;
        this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;

        for (var propName in Interface) {
          if (!Interface.hasOwnProperty(propName)) {
            continue;
          }

          {
            delete this[propName];
          }
          var normalize = Interface[propName];

          if (normalize) {
            this[propName] = normalize(nativeEvent);
          } else {
            if (propName === "target") {
              this.target = nativeEventTarget;
            } else {
              this[propName] = nativeEvent[propName];
            }
          }
        }

        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

        if (defaultPrevented) {
          this.isDefaultPrevented = functionThatReturnsTrue;
        } else {
          this.isDefaultPrevented = functionThatReturnsFalse;
        }

        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }

      _extends(SyntheticEvent.prototype, {
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.preventDefault) {
            event.preventDefault();
          } else if (typeof event.returnValue !== "unknown") {
            event.returnValue = false;
          }

          this.isDefaultPrevented = functionThatReturnsTrue;
        },
        stopPropagation: function stopPropagation() {
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.stopPropagation) {
            event.stopPropagation();
          } else if (typeof event.cancelBubble !== "unknown") {
            event.cancelBubble = true;
          }

          this.isPropagationStopped = functionThatReturnsTrue;
        },
        persist: function persist() {
          this.isPersistent = functionThatReturnsTrue;
        },
        isPersistent: functionThatReturnsFalse,
        destructor: function destructor() {
          var Interface = this.constructor.Interface;

          for (var propName in Interface) {
            {
              Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
            }
          }

          this.dispatchConfig = null;
          this._targetInst = null;
          this.nativeEvent = null;
          this.isDefaultPrevented = functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          this._dispatchListeners = null;
          this._dispatchInstances = null;
          {
            Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
            Object.defineProperty(this, "isDefaultPrevented", getPooledWarningPropertyDefinition("isDefaultPrevented", functionThatReturnsFalse));
            Object.defineProperty(this, "isPropagationStopped", getPooledWarningPropertyDefinition("isPropagationStopped", functionThatReturnsFalse));
            Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", function () {}));
            Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", function () {}));
          }
        }
      });

      SyntheticEvent.Interface = EventInterface;

      SyntheticEvent.extend = function (Interface) {
        var Super = this;

        var E = function E() {};

        E.prototype = Super.prototype;
        var prototype = new E();

        function Class() {
          return Super.apply(this, arguments);
        }

        _extends(prototype, Class.prototype);

        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.Interface = _extends({}, Super.Interface, Interface);
        Class.extend = Super.extend;
        addEventPoolingTo(Class);
        return Class;
      };

      addEventPoolingTo(SyntheticEvent);

      function getPooledWarningPropertyDefinition(propName, getVal) {
        var isFunction = typeof getVal === "function";
        return {
          configurable: true,
          set: set,
          get: get$$1
        };

        function set(val) {
          var action = isFunction ? "setting the method" : "setting the property";
          warn(action, "This is effectively a no-op");
          return val;
        }

        function get$$1() {
          var action = isFunction ? "accessing the method" : "accessing the property";
          var result = isFunction ? "This is a no-op function" : "This is set to null";
          warn(action, result);
          return getVal;
        }

        function warn(action, result) {
          var warningCondition = false;
          !warningCondition ? warningWithoutStack$1(false, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + "If you must keep the original synthetic event around, use event.persist(). " + "See https://fb.me/react-event-pooling for more information.", action, propName, result) : void 0;
        }
      }

      function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
        var EventConstructor = this;

        if (EventConstructor.eventPool.length) {
          var instance = EventConstructor.eventPool.pop();
          EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
          return instance;
        }

        return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
      }

      function releasePooledEvent(event) {
        var EventConstructor = this;
        invariant(event instanceof EventConstructor, "Trying to release an event instance into a pool of a different type.");
        event.destructor();

        if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
          EventConstructor.eventPool.push(event);
        }
      }

      function addEventPoolingTo(EventConstructor) {
        EventConstructor.eventPool = [];
        EventConstructor.getPooled = getPooledEvent;
        EventConstructor.release = releasePooledEvent;
      }

      var ResponderSyntheticEvent = SyntheticEvent.extend({
        touchHistory: function touchHistory(nativeEvent) {
          return null;
        }
      });
      var TOP_TOUCH_START = "topTouchStart";
      var TOP_TOUCH_MOVE = "topTouchMove";
      var TOP_TOUCH_END = "topTouchEnd";
      var TOP_TOUCH_CANCEL = "topTouchCancel";
      var TOP_SCROLL = "topScroll";
      var TOP_SELECTION_CHANGE = "topSelectionChange";

      function isStartish(topLevelType) {
        return topLevelType === TOP_TOUCH_START;
      }

      function isMoveish(topLevelType) {
        return topLevelType === TOP_TOUCH_MOVE;
      }

      function isEndish(topLevelType) {
        return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;
      }

      var startDependencies = [TOP_TOUCH_START];
      var moveDependencies = [TOP_TOUCH_MOVE];
      var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];
      var MAX_TOUCH_BANK = 20;
      var touchBank = [];
      var touchHistory = {
        touchBank: touchBank,
        numberActiveTouches: 0,
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };

      function timestampForTouch(touch) {
        return touch.timeStamp || touch.timestamp;
      }

      function createTouchRecord(touch) {
        return {
          touchActive: true,
          startPageX: touch.pageX,
          startPageY: touch.pageY,
          startTimeStamp: timestampForTouch(touch),
          currentPageX: touch.pageX,
          currentPageY: touch.pageY,
          currentTimeStamp: timestampForTouch(touch),
          previousPageX: touch.pageX,
          previousPageY: touch.pageY,
          previousTimeStamp: timestampForTouch(touch)
        };
      }

      function resetTouchRecord(touchRecord, touch) {
        touchRecord.touchActive = true;
        touchRecord.startPageX = touch.pageX;
        touchRecord.startPageY = touch.pageY;
        touchRecord.startTimeStamp = timestampForTouch(touch);
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchRecord.previousPageX = touch.pageX;
        touchRecord.previousPageY = touch.pageY;
        touchRecord.previousTimeStamp = timestampForTouch(touch);
      }

      function getTouchIdentifier(_ref) {
        var identifier = _ref.identifier;
        invariant(identifier != null, "Touch object is missing identifier.");
        {
          !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, "Touch identifier %s is greater than maximum supported %s which causes " + "performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK) : void 0;
        }
        return identifier;
      }

      function recordTouchStart(touch) {
        var identifier = getTouchIdentifier(touch);
        var touchRecord = touchBank[identifier];

        if (touchRecord) {
          resetTouchRecord(touchRecord, touch);
        } else {
          touchBank[identifier] = createTouchRecord(touch);
        }

        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      }

      function recordTouchMove(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = true;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch move without a touch start.\n" + "Touch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function recordTouchEnd(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = false;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch end without a touch start.\n" + "Touch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function printTouch(touch) {
        return JSON.stringify({
          identifier: touch.identifier,
          pageX: touch.pageX,
          pageY: touch.pageY,
          timestamp: timestampForTouch(touch)
        });
      }

      function printTouchBank() {
        var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));

        if (touchBank.length > MAX_TOUCH_BANK) {
          printed += " (original size: " + touchBank.length + ")";
        }

        return printed;
      }

      var ResponderTouchHistoryStore = {
        recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
          if (isMoveish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchMove);
          } else if (isStartish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchStart);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
            }
          } else if (isEndish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchEnd);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              for (var i = 0; i < touchBank.length; i++) {
                var touchTrackToCheck = touchBank[i];

                if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
                  touchHistory.indexOfSingleActiveTouch = i;
                  break;
                }
              }

              {
                var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
                !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, "Cannot find single active touch.") : void 0;
              }
            }
          }
        },
        touchHistory: touchHistory
      };

      function accumulate(current, next) {
        invariant(next != null, "accumulate(...): Accumulated items must be not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          return current.concat(next);
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      var responderInst = null;
      var trackedTouchCount = 0;

      var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
        var oldResponderInst = responderInst;
        responderInst = nextResponderInst;

        if (ResponderEventPlugin.GlobalResponderHandler !== null) {
          ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
        }
      };

      var eventTypes$1 = {
        startShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onStartShouldSetResponder",
            captured: "onStartShouldSetResponderCapture"
          },
          dependencies: startDependencies
        },
        scrollShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onScrollShouldSetResponder",
            captured: "onScrollShouldSetResponderCapture"
          },
          dependencies: [TOP_SCROLL]
        },
        selectionChangeShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onSelectionChangeShouldSetResponder",
            captured: "onSelectionChangeShouldSetResponderCapture"
          },
          dependencies: [TOP_SELECTION_CHANGE]
        },
        moveShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onMoveShouldSetResponder",
            captured: "onMoveShouldSetResponderCapture"
          },
          dependencies: moveDependencies
        },
        responderStart: {
          registrationName: "onResponderStart",
          dependencies: startDependencies
        },
        responderMove: {
          registrationName: "onResponderMove",
          dependencies: moveDependencies
        },
        responderEnd: {
          registrationName: "onResponderEnd",
          dependencies: endDependencies
        },
        responderRelease: {
          registrationName: "onResponderRelease",
          dependencies: endDependencies
        },
        responderTerminationRequest: {
          registrationName: "onResponderTerminationRequest",
          dependencies: []
        },
        responderGrant: {
          registrationName: "onResponderGrant",
          dependencies: []
        },
        responderReject: {
          registrationName: "onResponderReject",
          dependencies: []
        },
        responderTerminate: {
          registrationName: "onResponderTerminate",
          dependencies: []
        }
      };

      function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;
        var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);
        var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
        var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
        shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

        if (skipOverBubbleShouldSetFrom) {
          accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
        } else {
          accumulateTwoPhaseDispatches(shouldSetEvent);
        }

        var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);

        if (!shouldSetEvent.isPersistent()) {
          shouldSetEvent.constructor.release(shouldSetEvent);
        }

        if (!wantsResponderInst || wantsResponderInst === responderInst) {
          return null;
        }

        var extracted = void 0;
        var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);
        grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
        accumulateDirectDispatches(grantEvent);
        var blockHostResponder = executeDirectDispatch(grantEvent) === true;

        if (responderInst) {
          var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);
          terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(terminationRequestEvent);
          var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);

          if (!terminationRequestEvent.isPersistent()) {
            terminationRequestEvent.constructor.release(terminationRequestEvent);
          }

          if (shouldSwitch) {
            var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
            terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(terminateEvent);
            extracted = accumulate(extracted, [grantEvent, terminateEvent]);
            changeResponder(wantsResponderInst, blockHostResponder);
          } else {
            var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);
            rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(rejectEvent);
            extracted = accumulate(extracted, rejectEvent);
          }
        } else {
          extracted = accumulate(extracted, grantEvent);
          changeResponder(wantsResponderInst, blockHostResponder);
        }

        return extracted;
      }

      function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
        return topLevelInst && (topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));
      }

      function noResponderTouches(nativeEvent) {
        var touches = nativeEvent.touches;

        if (!touches || touches.length === 0) {
          return true;
        }

        for (var i = 0; i < touches.length; i++) {
          var activeTouch = touches[i];
          var target = activeTouch.target;

          if (target !== null && target !== undefined && target !== 0) {
            var targetInst = getInstanceFromNode(target);

            if (isAncestor(responderInst, targetInst)) {
              return false;
            }
          }
        }

        return true;
      }

      var ResponderEventPlugin = {
        _getResponder: function _getResponder() {
          return responderInst;
        },
        eventTypes: eventTypes$1,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (isStartish(topLevelType)) {
            trackedTouchCount += 1;
          } else if (isEndish(topLevelType)) {
            if (trackedTouchCount >= 0) {
              trackedTouchCount -= 1;
            } else {
              console.error("Ended a touch event which was not counted in `trackedTouchCount`.");
              return null;
            }
          }

          ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);
          var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;
          var isResponderTouchStart = responderInst && isStartish(topLevelType);
          var isResponderTouchMove = responderInst && isMoveish(topLevelType);
          var isResponderTouchEnd = responderInst && isEndish(topLevelType);
          var incrementalTouch = isResponderTouchStart ? eventTypes$1.responderStart : isResponderTouchMove ? eventTypes$1.responderMove : isResponderTouchEnd ? eventTypes$1.responderEnd : null;

          if (incrementalTouch) {
            var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
            gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(gesture);
            extracted = accumulate(extracted, gesture);
          }

          var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;
          var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
          var finalTouch = isResponderTerminate ? eventTypes$1.responderTerminate : isResponderRelease ? eventTypes$1.responderRelease : null;

          if (finalTouch) {
            var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
            finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(finalEvent);
            extracted = accumulate(extracted, finalEvent);
            changeResponder(null);
          }

          return extracted;
        },
        GlobalResponderHandler: null,
        injection: {
          injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
            ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
          }
        }
      };
      var ReactNativeBridgeEventPlugin = {
        eventTypes: ReactNativeViewConfigRegistry.eventTypes,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (targetInst == null) {
            return null;
          }

          var bubbleDispatchConfig = ReactNativeViewConfigRegistry.customBubblingEventTypes[topLevelType];
          var directDispatchConfig = ReactNativeViewConfigRegistry.customDirectEventTypes[topLevelType];
          invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
          var event = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);

          if (bubbleDispatchConfig) {
            accumulateTwoPhaseDispatches(event);
          } else if (directDispatchConfig) {
            accumulateDirectDispatches(event);
          } else {
            return null;
          }

          return event;
        }
      };
      var ReactNativeEventPluginOrder = ["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"];
      injection.injectEventPluginOrder(ReactNativeEventPluginOrder);
      injection.injectEventPluginsByName({
        ResponderEventPlugin: ResponderEventPlugin,
        ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
      });

      function getInstanceFromInstance(instanceHandle) {
        return instanceHandle;
      }

      function getTagFromInstance(inst) {
        var tag = inst.stateNode.canonical._nativeTag;
        invariant(tag, "All native instances should have a tag.");
        return tag;
      }

      function getFiberCurrentPropsFromNode$1(inst) {
        return inst.canonical.currentProps;
      }

      var ReactFabricGlobalResponderHandler = {
        onChange: function onChange(from, to, blockNativeResponder) {
          if (to !== null) {
            var tag = to.stateNode.canonical._nativeTag;
            UIManager.setJSResponder(tag, blockNativeResponder);
          } else {
            UIManager.clearJSResponder();
          }
        }
      };
      setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromInstance, getTagFromInstance);
      ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactFabricGlobalResponderHandler);

      function get$1(key) {
        return key._reactInternalFiber;
      }

      function set(key, value) {
        key._reactInternalFiber = value;
      }

      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

      if (!ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher")) {
        ReactSharedInternals.ReactCurrentDispatcher = {
          current: null
        };
      }

      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }

        return null;
      }

      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;

      function refineResolvedLazyComponent(lazyComponent) {
        return lazyComponent._status === Resolved ? lazyComponent._result : null;
      }

      function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }

      function getComponentName(type) {
        if (type == null) {
          return null;
        }

        {
          if (typeof type.tag === "number") {
            warningWithoutStack$1(false, "Received an unexpected object in getComponentName(). " + "This is likely a bug in React. Please file an issue.");
          }
        }

        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }

        if (typeof type === "string") {
          return type;
        }

        switch (type) {
          case REACT_CONCURRENT_MODE_TYPE:
            return "ConcurrentMode";

          case REACT_FRAGMENT_TYPE:
            return "Fragment";

          case REACT_PORTAL_TYPE:
            return "Portal";

          case REACT_PROFILER_TYPE:
            return "Profiler";

          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";

          case REACT_SUSPENSE_TYPE:
            return "Suspense";
        }

        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return "Context.Consumer";

            case REACT_PROVIDER_TYPE:
              return "Context.Provider";

            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");

            case REACT_MEMO_TYPE:
              return getComponentName(type.type);

            case REACT_LAZY_TYPE:
              {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);

                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
              }
          }
        }

        return null;
      }

      var NoEffect = 0;
      var PerformedWork = 1;
      var Placement = 2;
      var Update = 4;
      var PlacementAndUpdate = 6;
      var Deletion = 8;
      var ContentReset = 16;
      var Callback = 32;
      var DidCapture = 64;
      var Ref = 128;
      var Snapshot = 256;
      var Passive = 512;
      var LifecycleEffectMask = 932;
      var HostEffectMask = 1023;
      var Incomplete = 1024;
      var ShouldCapture = 2048;
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var MOUNTING = 1;
      var MOUNTED = 2;
      var UNMOUNTED = 3;

      function isFiberMountedImpl(fiber) {
        var node = fiber;

        if (!fiber.alternate) {
          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }

          while (node.return) {
            node = node.return;

            if ((node.effectTag & Placement) !== NoEffect) {
              return MOUNTING;
            }
          }
        } else {
          while (node.return) {
            node = node.return;
          }
        }

        if (node.tag === HostRoot) {
          return MOUNTED;
        }

        return UNMOUNTED;
      }

      function isFiberMounted(fiber) {
        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function isMounted(component) {
        {
          var owner = ReactCurrentOwner$1.current;

          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component") : void 0;
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get$1(component);

        if (!fiber) {
          return false;
        }

        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function assertIsMounted(fiber) {
        invariant(isFiberMountedImpl(fiber) === MOUNTED, "Unable to find node on an unmounted component.");
      }

      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;

        if (!alternate) {
          var state = isFiberMountedImpl(fiber);
          invariant(state !== UNMOUNTED, "Unable to find node on an unmounted component.");

          if (state === MOUNTING) {
            return null;
          }

          return fiber;
        }

        var a = fiber;
        var b = alternate;

        while (true) {
          var parentA = a.return;
          var parentB = parentA ? parentA.alternate : null;

          if (!parentA || !parentB) {
            break;
          }

          if (parentA.child === parentB.child) {
            var child = parentA.child;

            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }

              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }

              child = child.sibling;
            }

            invariant(false, "Unable to find node on an unmounted component.");
          }

          if (a.return !== b.return) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;

            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }

              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }

              _child = _child.sibling;
            }

            if (!didFindChild) {
              _child = parentB.child;

              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }

                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }

                _child = _child.sibling;
              }

              invariant(didFindChild, "Child was not found in either parent set. This indicates a bug " + "in React related to the return pointer. Please file an issue.");
            }
          }

          invariant(a.alternate === b, "Return fibers should always be each others' alternates. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        invariant(a.tag === HostRoot, "Unable to find node on an unmounted component.");

        if (a.stateNode.current === a) {
          return fiber;
        }

        return alternate;
      }

      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);

        if (!currentParent) {
          return null;
        }

        var node = currentParent;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          } else if (node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === currentParent) {
            return null;
          }

          while (!node.sibling) {
            if (!node.return || node.return === currentParent) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }

        return null;
      }

      function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
        return function () {
          if (!callback) {
            return undefined;
          }

          if (typeof context.__isMounted === "boolean") {
            if (!context.__isMounted) {
              return undefined;
            }
          }

          return callback.apply(context, arguments);
        };
      }

      function throwOnStylesProp(component, props) {
        if (props.styles !== undefined) {
          var owner = component._owner || null;
          var name = component.constructor.displayName;
          var msg = "`styles` is not a supported property of `" + name + "`, did " + "you mean `style` (singular)?";

          if (owner && owner.constructor && owner.constructor.displayName) {
            msg += "\n\nCheck the `" + owner.constructor.displayName + "` parent " + " component.";
          }

          throw new Error(msg);
        }
      }

      function warnForStyleProps(props, validAttributes) {
        for (var key in validAttributes.style) {
          if (!(validAttributes[key] || props[key] === undefined)) {
            console.error("You are setting the style `{ " + key + ": ... }` as a prop. You " + "should nest it in a style object. " + "E.g. `{ style: { " + key + ": ... } }`");
          }
        }
      }

      var emptyObject = {};
      var removedKeys = null;
      var removedKeyCount = 0;

      function defaultDiffer(prevProp, nextProp) {
        if (typeof nextProp !== "object" || nextProp === null) {
          return true;
        } else {
          return deepDiffer(prevProp, nextProp);
        }
      }

      function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
        if (Array.isArray(node)) {
          var i = node.length;

          while (i-- && removedKeyCount > 0) {
            restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
          }
        } else if (node && removedKeyCount > 0) {
          var obj = node;

          for (var propKey in removedKeys) {
            if (!removedKeys[propKey]) {
              continue;
            }

            var nextProp = obj[propKey];

            if (nextProp === undefined) {
              continue;
            }

            var attributeConfig = validAttributes[propKey];

            if (!attributeConfig) {
              continue;
            }

            if (typeof nextProp === "function") {
              nextProp = true;
            }

            if (typeof nextProp === "undefined") {
              nextProp = null;
            }

            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            removedKeys[propKey] = false;
            removedKeyCount--;
          }
        }
      }

      function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {
        var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
        var i = void 0;

        for (i = 0; i < minLength; i++) {
          updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);
        }

        for (; i < prevArray.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);
        }

        for (; i < nextArray.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);
        }

        return updatePayload;
      }

      function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
        if (!updatePayload && prevProp === nextProp) {
          return updatePayload;
        }

        if (!prevProp || !nextProp) {
          if (nextProp) {
            return addNestedProperty(updatePayload, nextProp, validAttributes);
          }

          if (prevProp) {
            return clearNestedProperty(updatePayload, prevProp, validAttributes);
          }

          return updatePayload;
        }

        if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {
          return diffProperties(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
          return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp)) {
          return diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes);
        }

        return diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);
      }

      function addNestedProperty(updatePayload, nextProp, validAttributes) {
        if (!nextProp) {
          return updatePayload;
        }

        if (!Array.isArray(nextProp)) {
          return addProperties(updatePayload, nextProp, validAttributes);
        }

        for (var i = 0; i < nextProp.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
        }

        return updatePayload;
      }

      function clearNestedProperty(updatePayload, prevProp, validAttributes) {
        if (!prevProp) {
          return updatePayload;
        }

        if (!Array.isArray(prevProp)) {
          return clearProperties(updatePayload, prevProp, validAttributes);
        }

        for (var i = 0; i < prevProp.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
        }

        return updatePayload;
      }

      function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
        var attributeConfig = void 0;
        var nextProp = void 0;
        var prevProp = void 0;

        for (var propKey in nextProps) {
          attributeConfig = validAttributes[propKey];

          if (!attributeConfig) {
            continue;
          }

          prevProp = prevProps[propKey];
          nextProp = nextProps[propKey];

          if (typeof nextProp === "function") {
            nextProp = true;

            if (typeof prevProp === "function") {
              prevProp = true;
            }
          }

          if (typeof nextProp === "undefined") {
            nextProp = null;

            if (typeof prevProp === "undefined") {
              prevProp = null;
            }
          }

          if (removedKeys) {
            removedKeys[propKey] = false;
          }

          if (updatePayload && updatePayload[propKey] !== undefined) {
            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            continue;
          }

          if (prevProp === nextProp) {
            continue;
          }

          if (typeof attributeConfig !== "object") {
            if (defaultDiffer(prevProp, nextProp)) {
              (updatePayload || (updatePayload = {}))[propKey] = nextProp;
            }
          } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === "function" ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));

            if (shouldUpdate) {
              var _nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;

              (updatePayload || (updatePayload = {}))[propKey] = _nextValue;
            }
          } else {
            removedKeys = null;
            removedKeyCount = 0;
            updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);

            if (removedKeyCount > 0 && updatePayload) {
              restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);
              removedKeys = null;
            }
          }
        }

        for (var _propKey in prevProps) {
          if (nextProps[_propKey] !== undefined) {
            continue;
          }

          attributeConfig = validAttributes[_propKey];

          if (!attributeConfig) {
            continue;
          }

          if (updatePayload && updatePayload[_propKey] !== undefined) {
            continue;
          }

          prevProp = prevProps[_propKey];

          if (prevProp === undefined) {
            continue;
          }

          if (typeof attributeConfig !== "object" || typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            (updatePayload || (updatePayload = {}))[_propKey] = null;

            if (!removedKeys) {
              removedKeys = {};
            }

            if (!removedKeys[_propKey]) {
              removedKeys[_propKey] = true;
              removedKeyCount++;
            }
          } else {
            updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);
          }
        }

        return updatePayload;
      }

      function addProperties(updatePayload, props, validAttributes) {
        return diffProperties(updatePayload, emptyObject, props, validAttributes);
      }

      function clearProperties(updatePayload, prevProps, validAttributes) {
        return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);
      }

      function create(props, validAttributes) {
        return addProperties(null, props, validAttributes);
      }

      function diff(prevProps, nextProps, validAttributes) {
        return diffProperties(null, prevProps, nextProps, validAttributes);
      }

      var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
      var now$1 = hasNativePerformanceNow ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };
      var scheduledCallback = null;
      var frameDeadline = 0;

      function setTimeoutCallback() {
        frameDeadline = now$1() + 5;
        var callback = scheduledCallback;
        scheduledCallback = null;

        if (callback !== null) {
          callback();
        }
      }

      function scheduleDeferredCallback$1(callback, options) {
        scheduledCallback = callback;
        var timeoutId = setTimeout(setTimeoutCallback, 1);
        return timeoutId;
      }

      function cancelDeferredCallback$1(callbackID) {
        scheduledCallback = null;
        clearTimeout(callbackID);
      }

      function shouldYield$1() {
        return frameDeadline <= now$1();
      }

      var debugRenderPhaseSideEffects = false;
      var debugRenderPhaseSideEffectsForStrictMode = false;
      var enableUserTimingAPI = true;
      var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
      var warnAboutDeprecatedLifecycles = false;
      var enableProfilerTimer = true;
      var enableSchedulerTracing = true;
      var enableSuspenseServerRenderer = false;
      var warnAboutDeprecatedSetNativeProps = false;
      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;

      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);

        if (!internalInstance) {
          return;
        }

        invariant(typeof restoreImpl === "function", "setRestoreImplementation() needs to be called to handle a target for controlled " + "events. This error is likely caused by a bug in React. Please file an issue.");
        var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
        restoreImpl(internalInstance.stateNode, internalInstance.type, props);
      }

      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }

      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }

        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);

        if (queuedTargets) {
          for (var i = 0; i < queuedTargets.length; i++) {
            restoreStateOfTarget(queuedTargets[i]);
          }
        }
      }

      var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {
        return fn(bookkeeping);
      };

      var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};

      var isBatching = false;

      function batchedUpdates(fn, bookkeeping) {
        if (isBatching) {
          return fn(bookkeeping);
        }

        isBatching = true;

        try {
          return _batchedUpdatesImpl(fn, bookkeeping);
        } finally {
          isBatching = false;
          var controlledComponentsHavePendingUpdates = needsStateRestore();

          if (controlledComponentsHavePendingUpdates) {
            _flushInteractiveUpdatesImpl();

            restoreStateIfNeeded();
          }
        }
      }

      function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
        _batchedUpdatesImpl = batchedUpdatesImpl;
        _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
      }

      function dispatchEvent(target, topLevelType, nativeEvent) {
        var targetFiber = target;
        batchedUpdates(function () {
          runExtractedEventsInBatch(topLevelType, targetFiber, nativeEvent, nativeEvent.target);
        });
      }

      function shim() {
        invariant(false, "The current renderer does not support mutation. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsMutation = false;
      var appendChild$1 = shim;
      var appendChildToContainer = shim;
      var commitTextUpdate = shim;
      var commitMount = shim;
      var commitUpdate = shim;
      var insertBefore = shim;
      var insertInContainerBefore = shim;
      var removeChild = shim;
      var removeChildFromContainer = shim;
      var resetTextContent = shim;
      var hideInstance = shim;
      var hideTextInstance = shim;
      var unhideInstance = shim;
      var unhideTextInstance = shim;

      function shim$1() {
        invariant(false, "The current renderer does not support hydration. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsHydration = false;
      var canHydrateInstance = shim$1;
      var canHydrateTextInstance = shim$1;
      var canHydrateSuspenseInstance = shim$1;
      var isSuspenseInstancePending = shim$1;
      var isSuspenseInstanceFallback = shim$1;
      var registerSuspenseInstanceRetry = shim$1;
      var getNextHydratableSibling = shim$1;
      var getFirstHydratableChild = shim$1;
      var hydrateInstance = shim$1;
      var hydrateTextInstance = shim$1;
      var getNextHydratableInstanceAfterSuspenseInstance = shim$1;
      var clearSuspenseBoundary = shim$1;
      var clearSuspenseBoundaryFromContainer = shim$1;
      var didNotMatchHydratedContainerTextInstance = shim$1;
      var didNotMatchHydratedTextInstance = shim$1;
      var didNotHydrateContainerInstance = shim$1;
      var didNotHydrateInstance = shim$1;
      var didNotFindHydratableContainerInstance = shim$1;
      var didNotFindHydratableContainerTextInstance = shim$1;
      var didNotFindHydratableContainerSuspenseInstance = shim$1;
      var didNotFindHydratableInstance = shim$1;
      var didNotFindHydratableTextInstance = shim$1;
      var didNotFindHydratableSuspenseInstance = shim$1;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var nextReactTag = 2;

      if (FabricUIManager.registerEventHandler) {
        FabricUIManager.registerEventHandler(dispatchEvent);
      }

      var ReactFabricHostComponent = function () {
        function ReactFabricHostComponent(tag, viewConfig, props) {
          _classCallCheck(this, ReactFabricHostComponent);

          this._nativeTag = tag;
          this.viewConfig = viewConfig;
          this.currentProps = props;
        }

        ReactFabricHostComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(this._nativeTag);
        };

        ReactFabricHostComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(this._nativeTag);
        };

        ReactFabricHostComponent.prototype.measure = function measure(callback) {
          UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactFabricHostComponent.prototype.measureInWindow = function measureInWindow(callback) {
          UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactFabricHostComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        };

        ReactFabricHostComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
          {
            if (warnAboutDeprecatedSetNativeProps) {
              warningWithoutStack$1(false, "Warning: Calling ref.setNativeProps(nativeProps) " + "is deprecated and will be removed in a future release. " + "Use the setNativeProps export from the react-native package instead." + "\n\timport {setNativeProps} from 'react-native';\n\tsetNativeProps(ref, nativeProps);\n");
            }

            warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
          }
          var updatePayload = create(nativeProps, this.viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, updatePayload);
          }
        };

        return ReactFabricHostComponent;
      }();

      function appendInitialChild(parentInstance, child) {
        FabricUIManager.appendChild(parentInstance.node, child.node);
      }

      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var tag = nextReactTag;
        nextReactTag += 2;
        var viewConfig = ReactNativeViewConfigRegistry.get(type);
        {
          for (var key in viewConfig.validAttributes) {
            if (props.hasOwnProperty(key)) {
              deepFreezeAndThrowOnMutationInDev(props[key]);
            }
          }
        }
        invariant(type !== "RCTView" || !hostContext.isInAParentText, "Nesting of <View> within <Text> is not currently supported.");
        var updatePayload = create(props, viewConfig.validAttributes);
        var node = FabricUIManager.createNode(tag, viewConfig.uiViewClassName, rootContainerInstance, updatePayload, internalInstanceHandle);
        var component = new ReactFabricHostComponent(tag, viewConfig, props);
        return {
          node: node,
          canonical: component
        };
      }

      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        invariant(hostContext.isInAParentText, "Text strings must be rendered within a <Text> component.");
        var tag = nextReactTag;
        nextReactTag += 2;
        var node = FabricUIManager.createNode(tag, "RCTRawText", rootContainerInstance, {
          text: text
        }, internalInstanceHandle);
        return {
          node: node
        };
      }

      function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {
        return false;
      }

      function getRootHostContext(rootContainerInstance) {
        return {
          isInAParentText: false
        };
      }

      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        var prevIsInAParentText = parentHostContext.isInAParentText;
        var isInAParentText = type === "AndroidTextInput" || type === "RCTMultilineTextInputView" || type === "RCTSinglelineTextInputView" || type === "RCTText" || type === "RCTVirtualText";

        if (prevIsInAParentText !== isInAParentText) {
          return {
            isInAParentText: isInAParentText
          };
        } else {
          return parentHostContext;
        }
      }

      function getPublicInstance(instance) {
        return instance.canonical;
      }

      function prepareForCommit(containerInfo) {}

      function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
        var viewConfig = instance.canonical.viewConfig;
        var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);
        instance.canonical.currentProps = newProps;
        return updatePayload;
      }

      function resetAfterCommit(containerInfo) {}

      function shouldDeprioritizeSubtree(type, props) {
        return false;
      }

      function shouldSetTextContent(type, props) {
        return false;
      }

      var isPrimaryRenderer = false;
      var now$$1 = now$1;
      var scheduleDeferredCallback$$1 = scheduleDeferredCallback$1;
      var cancelDeferredCallback$$1 = cancelDeferredCallback$1;
      var shouldYield$$1 = shouldYield$1;
      var scheduleTimeout = setTimeout;
      var cancelTimeout = clearTimeout;
      var noTimeout = -1;
      var schedulePassiveEffects = scheduleDeferredCallback$$1;
      var cancelPassiveEffects = cancelDeferredCallback$$1;
      var supportsPersistence = true;

      function cloneInstance(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle, keepChildren, recyclableInstance) {
        var node = instance.node;
        var clone = void 0;

        if (keepChildren) {
          if (updatePayload !== null) {
            clone = FabricUIManager.cloneNodeWithNewProps(node, updatePayload);
          } else {
            clone = FabricUIManager.cloneNode(node);
          }
        } else {
          if (updatePayload !== null) {
            clone = FabricUIManager.cloneNodeWithNewChildrenAndProps(node, updatePayload);
          } else {
            clone = FabricUIManager.cloneNodeWithNewChildren(node);
          }
        }

        return {
          node: clone,
          canonical: instance.canonical
        };
      }

      function cloneHiddenInstance(instance, type, props, internalInstanceHandle) {
        var viewConfig = instance.canonical.viewConfig;
        var node = instance.node;
        var updatePayload = create({
          style: {
            display: "none"
          }
        }, viewConfig.validAttributes);
        return {
          node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
          canonical: instance.canonical
        };
      }

      function cloneUnhiddenInstance(instance, type, props, internalInstanceHandle) {
        var viewConfig = instance.canonical.viewConfig;
        var node = instance.node;
        var updatePayload = diff(_extends({}, props, {
          style: [props.style, {
            display: "none"
          }]
        }), props, viewConfig.validAttributes);
        return {
          node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
          canonical: instance.canonical
        };
      }

      function createHiddenTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        throw new Error("Not yet implemented.");
      }

      function createContainerChildSet(container) {
        return FabricUIManager.createChildSet(container);
      }

      function appendChildToContainerChildSet(childSet, child) {
        FabricUIManager.appendChildToSet(childSet, child.node);
      }

      function finalizeContainerChildren(container, newChildren) {
        FabricUIManager.completeRoot(container, newChildren);
      }

      var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        var sourceInfo = "";

        if (source) {
          var path = source.fileName;
          var fileName = path.replace(BEFORE_SLASH_RE, "");
          {
            if (/^index\./.test(fileName)) {
              var match = path.match(BEFORE_SLASH_RE);

              if (match) {
                var pathBeforeSlash = match[1];

                if (pathBeforeSlash) {
                  var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                  fileName = folderName + "/" + fileName;
                }
              }
            }
          }
          sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
        } else if (ownerName) {
          sourceInfo = " (created by " + ownerName + ")";
        }

        return "\n    in " + (name || "Unknown") + sourceInfo;
      };

      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

      function describeFiber(fiber) {
        switch (fiber.tag) {
          case HostRoot:
          case HostPortal:
          case HostText:
          case Fragment:
          case ContextProvider:
          case ContextConsumer:
            return "";

          default:
            var owner = fiber._debugOwner;
            var source = fiber._debugSource;
            var name = getComponentName(fiber.type);
            var ownerName = null;

            if (owner) {
              ownerName = getComponentName(owner.type);
            }

            return describeComponentFrame(name, source, ownerName);
        }
      }

      function getStackByFiberInDevAndProd(workInProgress) {
        var info = "";
        var node = workInProgress;

        do {
          info += describeFiber(node);
          node = node.return;
        } while (node);

        return info;
      }

      var current = null;
      var phase = null;

      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null) {
            return null;
          }

          var owner = current._debugOwner;

          if (owner !== null && typeof owner !== "undefined") {
            return getComponentName(owner.type);
          }
        }
        return null;
      }

      function getCurrentFiberStackInDev() {
        {
          if (current === null) {
            return "";
          }

          return getStackByFiberInDevAndProd(current);
        }
        return "";
      }

      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current = null;
          phase = null;
        }
      }

      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
          current = fiber;
          phase = null;
        }
      }

      function setCurrentPhase(lifeCyclePhase) {
        {
          phase = lifeCyclePhase;
        }
      }

      var reactEmoji = "\u269B";
      var warningEmoji = "\u26D4";
      var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
      var currentFiber = null;
      var currentPhase = null;
      var currentPhaseFiber = null;
      var isCommitting = false;
      var hasScheduledUpdateInCurrentCommit = false;
      var hasScheduledUpdateInCurrentPhase = false;
      var commitCountInCurrentWorkLoop = 0;
      var effectCountInCurrentCommit = 0;
      var isWaitingForCallback = false;
      var labelsInCurrentCommit = new Set();

      var formatMarkName = function formatMarkName(markName) {
        return reactEmoji + " " + markName;
      };

      var formatLabel = function formatLabel(label, warning) {
        var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
        var suffix = warning ? " Warning: " + warning : "";
        return "" + prefix + label + suffix;
      };

      var beginMark = function beginMark(markName) {
        performance.mark(formatMarkName(markName));
      };

      var clearMark = function clearMark(markName) {
        performance.clearMarks(formatMarkName(markName));
      };

      var endMark = function endMark(label, markName, warning) {
        var formattedMarkName = formatMarkName(markName);
        var formattedLabel = formatLabel(label, warning);

        try {
          performance.measure(formattedLabel, formattedMarkName);
        } catch (err) {}

        performance.clearMarks(formattedMarkName);
        performance.clearMeasures(formattedLabel);
      };

      var getFiberMarkName = function getFiberMarkName(label, debugID) {
        return label + " (#" + debugID + ")";
      };

      var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
        if (phase === null) {
          return componentName + " [" + (isMounted ? "update" : "mount") + "]";
        } else {
          return componentName + "." + phase;
        }
      };

      var beginFiberMark = function beginFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);

        if (isCommitting && labelsInCurrentCommit.has(label)) {
          return false;
        }

        labelsInCurrentCommit.add(label);
        var markName = getFiberMarkName(label, debugID);
        beginMark(markName);
        return true;
      };

      var clearFiberMark = function clearFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        clearMark(markName);
      };

      var endFiberMark = function endFiberMark(fiber, phase, warning) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        endMark(label, markName, warning);
      };

      var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
        switch (fiber.tag) {
          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case Fragment:
          case ContextProvider:
          case ContextConsumer:
          case Mode:
            return true;

          default:
            return false;
        }
      };

      var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
        if (currentPhase !== null && currentPhaseFiber !== null) {
          clearFiberMark(currentPhaseFiber, currentPhase);
        }

        currentPhaseFiber = null;
        currentPhase = null;
        hasScheduledUpdateInCurrentPhase = false;
      };

      var pauseTimers = function pauseTimers() {
        var fiber = currentFiber;

        while (fiber) {
          if (fiber._debugIsCurrentlyTiming) {
            endFiberMark(fiber, null, null);
          }

          fiber = fiber.return;
        }
      };

      var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
        if (fiber.return !== null) {
          resumeTimersRecursively(fiber.return);
        }

        if (fiber._debugIsCurrentlyTiming) {
          beginFiberMark(fiber, null);
        }
      };

      var resumeTimers = function resumeTimers() {
        if (currentFiber !== null) {
          resumeTimersRecursively(currentFiber);
        }
      };

      function recordEffect() {
        if (enableUserTimingAPI) {
          effectCountInCurrentCommit++;
        }
      }

      function recordScheduleUpdate() {
        if (enableUserTimingAPI) {
          if (isCommitting) {
            hasScheduledUpdateInCurrentCommit = true;
          }

          if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
            hasScheduledUpdateInCurrentPhase = true;
          }
        }
      }

      function startRequestCallbackTimer() {
        if (enableUserTimingAPI) {
          if (supportsUserTiming && !isWaitingForCallback) {
            isWaitingForCallback = true;
            beginMark("(Waiting for async callback...)");
          }
        }
      }

      function stopRequestCallbackTimer(didExpire, expirationTime) {
        if (enableUserTimingAPI) {
          if (supportsUserTiming) {
            isWaitingForCallback = false;
            var warning = didExpire ? "React was blocked by main thread" : null;
            endMark("(Waiting for async callback... will force flush in " + expirationTime + " ms)", "(Waiting for async callback...)", warning);
          }
        }
      }

      function startWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber;

          if (!beginFiberMark(fiber, null)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = true;
        }
      }

      function cancelWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          clearFiberMark(fiber, null);
        }
      }

      function stopWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          endFiberMark(fiber, null, null);
        }
      }

      function stopFailedWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          var warning = fiber.tag === SuspenseComponent || fiber.tag === DehydratedSuspenseComponent ? "Rendering was suspended" : "An error was thrown inside this error boundary";
          endFiberMark(fiber, null, warning);
        }
      }

      function startPhaseTimer(fiber, phase) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          clearPendingPhaseMeasurement();

          if (!beginFiberMark(fiber, phase)) {
            return;
          }

          currentPhaseFiber = fiber;
          currentPhase = phase;
        }
      }

      function stopPhaseTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          if (currentPhase !== null && currentPhaseFiber !== null) {
            var warning = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
            endFiberMark(currentPhaseFiber, currentPhase, warning);
          }

          currentPhase = null;
          currentPhaseFiber = null;
        }
      }

      function startWorkLoopTimer(nextUnitOfWork) {
        if (enableUserTimingAPI) {
          currentFiber = nextUnitOfWork;

          if (!supportsUserTiming) {
            return;
          }

          commitCountInCurrentWorkLoop = 0;
          beginMark("(React Tree Reconciliation)");
          resumeTimers();
        }
      }

      function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (interruptedBy !== null) {
            if (interruptedBy.tag === HostRoot) {
              warning = "A top-level update interrupted the previous render";
            } else {
              var componentName = getComponentName(interruptedBy.type) || "Unknown";
              warning = "An update to " + componentName + " interrupted the previous render";
            }
          } else if (commitCountInCurrentWorkLoop > 1) {
            warning = "There were cascading updates";
          }

          commitCountInCurrentWorkLoop = 0;
          var label = didCompleteRoot ? "(React Tree Reconciliation: Completed Root)" : "(React Tree Reconciliation: Yielded)";
          pauseTimers();
          endMark(label, "(React Tree Reconciliation)", warning);
        }
      }

      function startCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          isCommitting = true;
          hasScheduledUpdateInCurrentCommit = false;
          labelsInCurrentCommit.clear();
          beginMark("(Committing Changes)");
        }
      }

      function stopCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (hasScheduledUpdateInCurrentCommit) {
            warning = "Lifecycle hook scheduled a cascading update";
          } else if (commitCountInCurrentWorkLoop > 0) {
            warning = "Caused by a cascading update in earlier commit";
          }

          hasScheduledUpdateInCurrentCommit = false;
          commitCountInCurrentWorkLoop++;
          isCommitting = false;
          labelsInCurrentCommit.clear();
          endMark("(Committing Changes)", "(Committing Changes)", warning);
        }
      }

      function startCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Snapshot Effects)");
        }
      }

      function stopCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Snapshot Effects: " + count + " Total)", "(Committing Snapshot Effects)", null);
        }
      }

      function startCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Host Effects)");
        }
      }

      function stopCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
        }
      }

      function startCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Calling Lifecycle Methods)");
        }
      }

      function stopCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
        }
      }

      var valueStack = [];
      var fiberStack = void 0;
      {
        fiberStack = [];
      }
      var index = -1;

      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }

      function pop(cursor, fiber) {
        if (index < 0) {
          {
            warningWithoutStack$1(false, "Unexpected pop.");
          }
          return;
        }

        {
          if (fiber !== fiberStack[index]) {
            warningWithoutStack$1(false, "Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }

      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }

      function checkThatStackIsEmpty() {
        {
          if (index !== -1) {
            warningWithoutStack$1(false, "Expected an empty stack. Something was not reset properly.");
          }
        }
      }

      function resetStackAfterFatalErrorInDev() {
        {
          index = -1;
          valueStack.length = 0;
          fiberStack.length = 0;
        }
      }

      var warnedAboutMissingGetChildContext = void 0;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;

      function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
        if (didPushOwnContextIfProvider && isContextProvider(Component)) {
          return previousContext;
        }

        return contextStackCursor.current;
      }

      function cacheContext(workInProgress, unmaskedContext, maskedContext) {
        var instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
      }

      function getMaskedContext(workInProgress, unmaskedContext) {
        var type = workInProgress.type;
        var contextTypes = type.contextTypes;

        if (!contextTypes) {
          return emptyContextObject;
        }

        var instance = workInProgress.stateNode;

        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
          return instance.__reactInternalMemoizedMaskedChildContext;
        }

        var context = {};

        for (var key in contextTypes) {
          context[key] = unmaskedContext[key];
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(contextTypes, context, "context", name, getCurrentFiberStackInDev);
        }

        if (instance) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return context;
      }

      function hasContextChanged() {
        return didPerformWorkStackCursor.current;
      }

      function isContextProvider(type) {
        var childContextTypes = type.childContextTypes;
        return childContextTypes !== null && childContextTypes !== undefined;
      }

      function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function pushTopLevelContextObject(fiber, context, didChange) {
        invariant(contextStackCursor.current === emptyContextObject, "Unexpected context found on stack. " + "This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
      }

      function processChildContext(fiber, type, parentContext) {
        var instance = fiber.stateNode;
        var childContextTypes = type.childContextTypes;

        if (typeof instance.getChildContext !== "function") {
          {
            var componentName = getComponentName(type) || "Unknown";

            if (!warnedAboutMissingGetChildContext[componentName]) {
              warnedAboutMissingGetChildContext[componentName] = true;
              warningWithoutStack$1(false, "%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
            }
          }
          return parentContext;
        }

        var childContext = void 0;
        {
          setCurrentPhase("getChildContext");
        }
        startPhaseTimer(fiber, "getChildContext");
        childContext = instance.getChildContext();
        stopPhaseTimer();
        {
          setCurrentPhase(null);
        }

        for (var contextKey in childContext) {
          invariant(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || "Unknown", contextKey);
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(childContextTypes, childContext, "child context", name, getCurrentFiberStackInDev);
        }
        return _extends({}, parentContext, childContext);
      }

      function pushContextProvider(workInProgress) {
        var instance = workInProgress.stateNode;
        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        return true;
      }

      function invalidateContextProvider(workInProgress, type, didChange) {
        var instance = workInProgress.stateNode;
        invariant(instance, "Expected to have an instance by this point. " + "This error is likely caused by a bug in React. Please file an issue.");

        if (didChange) {
          var mergedContext = processChildContext(workInProgress, type, previousContext);
          instance.__reactInternalMemoizedMergedChildContext = mergedContext;
          pop(didPerformWorkStackCursor, workInProgress);
          pop(contextStackCursor, workInProgress);
          push(contextStackCursor, mergedContext, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        } else {
          pop(didPerformWorkStackCursor, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        }
      }

      function findCurrentUnmaskedContext(fiber) {
        invariant(isFiberMounted(fiber) && fiber.tag === ClassComponent, "Expected subtree parent to be a mounted class component. " + "This error is likely caused by a bug in React. Please file an issue.");
        var node = fiber;

        do {
          switch (node.tag) {
            case HostRoot:
              return node.stateNode.context;

            case ClassComponent:
              {
                var Component = node.type;

                if (isContextProvider(Component)) {
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                }

                break;
              }
          }

          node = node.return;
        } while (node !== null);

        invariant(false, "Found unexpected detached subtree parent. " + "This error is likely caused by a bug in React. Please file an issue.");
      }

      var onCommitFiberRoot = null;
      var onCommitFiberUnmount = null;
      var hasLoggedError = false;

      function catchErrors(fn) {
        return function (arg) {
          try {
            return fn(arg);
          } catch (err) {
            if (true && !hasLoggedError) {
              hasLoggedError = true;
              warningWithoutStack$1(false, "React DevTools encountered an error: %s", err);
            }
          }
        };
      }

      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";

      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }

        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook.isDisabled) {
          return true;
        }

        if (!hook.supportsFiber) {
          {
            warningWithoutStack$1(false, "The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://fb.me/react-devtools");
          }
          return true;
        }

        try {
          var rendererID = hook.inject(internals);
          onCommitFiberRoot = catchErrors(function (root) {
            return hook.onCommitFiberRoot(rendererID, root);
          });
          onCommitFiberUnmount = catchErrors(function (fiber) {
            return hook.onCommitFiberUnmount(rendererID, fiber);
          });
        } catch (err) {
          {
            warningWithoutStack$1(false, "React DevTools encountered an error: %s.", err);
          }
        }

        return true;
      }

      function onCommitRoot(root) {
        if (typeof onCommitFiberRoot === "function") {
          onCommitFiberRoot(root);
        }
      }

      function onCommitUnmount(fiber) {
        if (typeof onCommitFiberUnmount === "function") {
          onCommitFiberUnmount(fiber);
        }
      }

      var maxSigned31BitInt = 1073741823;
      var NoWork = 0;
      var Never = 1;
      var Sync = maxSigned31BitInt;
      var UNIT_SIZE = 10;
      var MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;

      function msToExpirationTime(ms) {
        return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);
      }

      function expirationTimeToMs(expirationTime) {
        return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
      }

      function ceiling(num, precision) {
        return ((num / precision | 0) + 1) * precision;
      }

      function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
        return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
      }

      var LOW_PRIORITY_EXPIRATION = 5000;
      var LOW_PRIORITY_BATCH_SIZE = 250;

      function computeAsyncExpiration(currentTime) {
        return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
      }

      var HIGH_PRIORITY_EXPIRATION = 500;
      var HIGH_PRIORITY_BATCH_SIZE = 100;

      function computeInteractiveExpiration(currentTime) {
        return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
      }

      var NoContext = 0;
      var ConcurrentMode = 1;
      var StrictMode = 2;
      var ProfileMode = 4;
      var hasBadMapPolyfill = void 0;
      {
        hasBadMapPolyfill = false;

        try {
          var nonExtensibleObject = Object.preventExtensions({});
          var testMap = new Map([[nonExtensibleObject, null]]);
          var testSet = new Set([nonExtensibleObject]);
          testMap.set(0, 0);
          testSet.add(0);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      var debugCounter = void 0;
      {
        debugCounter = 1;
      }

      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.contextDependencies = null;
        this.mode = mode;
        this.effectTag = NoEffect;
        this.nextEffect = null;
        this.firstEffect = null;
        this.lastEffect = null;
        this.expirationTime = NoWork;
        this.childExpirationTime = NoWork;
        this.alternate = null;

        if (enableProfilerTimer) {
          this.actualDuration = Number.NaN;
          this.actualStartTime = Number.NaN;
          this.selfBaseDuration = Number.NaN;
          this.treeBaseDuration = Number.NaN;
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }

        {
          this._debugID = debugCounter++;
          this._debugSource = null;
          this._debugOwner = null;
          this._debugIsCurrentlyTiming = false;

          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }

      var createFiber = function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };

      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }

      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined;
      }

      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== undefined && Component !== null) {
          var $$typeof = Component.$$typeof;

          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }

          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }

        return IndeterminateComponent;
      }

      function createWorkInProgress(current, pendingProps, expirationTime) {
        var workInProgress = current.alternate;

        if (workInProgress === null) {
          workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
          workInProgress.elementType = current.elementType;
          workInProgress.type = current.type;
          workInProgress.stateNode = current.stateNode;
          {
            workInProgress._debugID = current._debugID;
            workInProgress._debugSource = current._debugSource;
            workInProgress._debugOwner = current._debugOwner;
          }
          workInProgress.alternate = current;
          current.alternate = workInProgress;
        } else {
          workInProgress.pendingProps = pendingProps;
          workInProgress.effectTag = NoEffect;
          workInProgress.nextEffect = null;
          workInProgress.firstEffect = null;
          workInProgress.lastEffect = null;

          if (enableProfilerTimer) {
            workInProgress.actualDuration = 0;
            workInProgress.actualStartTime = -1;
          }
        }

        workInProgress.childExpirationTime = current.childExpirationTime;
        workInProgress.expirationTime = current.expirationTime;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.contextDependencies = current.contextDependencies;
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;

        if (enableProfilerTimer) {
          workInProgress.selfBaseDuration = current.selfBaseDuration;
          workInProgress.treeBaseDuration = current.treeBaseDuration;
        }

        return workInProgress;
      }

      function createHostRootFiber(isConcurrent) {
        var mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;

        if (enableProfilerTimer && isDevToolsPresent) {
          mode |= ProfileMode;
        }

        return createFiber(HostRoot, null, null, mode);
      }

      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
        var fiber = void 0;
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;

        if (typeof type === "function") {
          if (shouldConstruct(type)) {
            fiberTag = ClassComponent;
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);

            case REACT_CONCURRENT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | ConcurrentMode | StrictMode, expirationTime, key);

            case REACT_STRICT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | StrictMode, expirationTime, key);

            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, expirationTime, key);

            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, expirationTime, key);

            default:
              {
                if (typeof type === "object" && type !== null) {
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = ContextProvider;
                      break getTag;

                    case REACT_CONTEXT_TYPE:
                      fiberTag = ContextConsumer;
                      break getTag;

                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = ForwardRef;
                      break getTag;

                    case REACT_MEMO_TYPE:
                      fiberTag = MemoComponent;
                      break getTag;

                    case REACT_LAZY_TYPE:
                      fiberTag = LazyComponent;
                      resolvedType = null;
                      break getTag;
                  }
                }

                var info = "";
                {
                  if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                    info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
                  }

                  var ownerName = owner ? getComponentName(owner.type) : null;

                  if (ownerName) {
                    info += "\n\nCheck the render method of `" + ownerName + "`.";
                  }
                }
                invariant(false, "Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + "but got: %s.%s", type == null ? type : typeof type, info);
              }
          }
        }

        fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromElement(element, mode, expirationTime) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }

      function createFiberFromFragment(elements, mode, expirationTime, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
        {
          if (typeof pendingProps.id !== "string" || typeof pendingProps.onRender !== "function") {
            warningWithoutStack$1(false, 'Profiler must specify an "id" string and "onRender" function as props');
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.type = REACT_PROFILER_TYPE;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromMode(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(Mode, pendingProps, key, mode);
        var type = (mode & ConcurrentMode) === NoContext ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        var type = REACT_SUSPENSE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromText(content, mode, expirationTime) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoContext);
        fiber.elementType = "DELETED";
        fiber.type = "DELETED";
        return fiber;
      }

      function createFiberFromPortal(portal, mode, expirationTime) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.expirationTime = expirationTime;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return fiber;
      }

      function assignFiberPropertiesInDEV(target, source) {
        if (target === null) {
          target = createFiber(IndeterminateComponent, null, null, NoContext);
        }

        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.contextDependencies = source.contextDependencies;
        target.mode = source.mode;
        target.effectTag = source.effectTag;
        target.nextEffect = source.nextEffect;
        target.firstEffect = source.firstEffect;
        target.lastEffect = source.lastEffect;
        target.expirationTime = source.expirationTime;
        target.childExpirationTime = source.childExpirationTime;
        target.alternate = source.alternate;

        if (enableProfilerTimer) {
          target.actualDuration = source.actualDuration;
          target.actualStartTime = source.actualStartTime;
          target.selfBaseDuration = source.selfBaseDuration;
          target.treeBaseDuration = source.treeBaseDuration;
        }

        target._debugID = source._debugID;
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
        return target;
      }

      function createFiberRoot(containerInfo, isConcurrent, hydrate) {
        var uninitializedFiber = createHostRootFiber(isConcurrent);
        var root = void 0;

        if (enableSchedulerTracing) {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            pingCache: null,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null,
            interactionThreadID: tracing.unstable_getThreadID(),
            memoizedInteractions: new Set(),
            pendingInteractionMap: new Map()
          };
        } else {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            pingCache: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null
          };
        }

        uninitializedFiber.stateNode = root;
        return root;
      }

      var lowPriorityWarning = function lowPriorityWarning() {};

      {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message = "Warning: " + format.replace(/%s/g, function () {
            return args[argIndex++];
          });

          if (typeof console !== "undefined") {
            console.warn(message);
          }

          try {
            throw new Error(message);
          } catch (x) {}
        };

        lowPriorityWarning = function lowPriorityWarning(condition, format) {
          if (format === undefined) {
            throw new Error("`lowPriorityWarning(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
          }
        };
      }
      var lowPriorityWarning$1 = lowPriorityWarning;
      var ReactStrictModeWarnings = {
        discardPendingWarnings: function discardPendingWarnings() {},
        flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},
        flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
        recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},
        recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
        recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
        flushLegacyContextWarning: function flushLegacyContextWarning() {}
      };
      {
        var LIFECYCLE_SUGGESTIONS = {
          UNSAFE_componentWillMount: "componentDidMount",
          UNSAFE_componentWillReceiveProps: "static getDerivedStateFromProps",
          UNSAFE_componentWillUpdate: "componentDidUpdate"
        };
        var pendingComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUnsafeLifecycleWarnings = new Map();
        var pendingLegacyContextWarning = new Map();
        var didWarnAboutDeprecatedLifecycles = new Set();
        var didWarnAboutUnsafeLifecycles = new Set();
        var didWarnAboutLegacyContext = new Set();

        var setToSortedString = function setToSortedString(set) {
          var array = [];
          set.forEach(function (value) {
            array.push(value);
          });
          return array.sort().join(", ");
        };

        ReactStrictModeWarnings.discardPendingWarnings = function () {
          pendingComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUnsafeLifecycleWarnings = new Map();
          pendingLegacyContextWarning = new Map();
        };

        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
          pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
            var lifecyclesWarningMessages = [];
            Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
              var lifecycleWarnings = lifecycleWarningsMap[lifecycle];

              if (lifecycleWarnings.length > 0) {
                var componentNames = new Set();
                lifecycleWarnings.forEach(function (fiber) {
                  componentNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                var formatted = lifecycle.replace("UNSAFE_", "");
                var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
                var sortedComponentNames = setToSortedString(componentNames);
                lifecyclesWarningMessages.push(formatted + ": Please update the following components to use " + (suggestion + " instead: " + sortedComponentNames));
              }
            });

            if (lifecyclesWarningMessages.length > 0) {
              var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
              warningWithoutStack$1(false, "Unsafe lifecycle methods were found within a strict-mode tree:%s" + "\n\n%s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, lifecyclesWarningMessages.join("\n\n"));
            }
          });
          pendingUnsafeLifecycleWarnings = new Map();
        };

        var findStrictRoot = function findStrictRoot(fiber) {
          var maybeStrictRoot = null;
          var node = fiber;

          while (node !== null) {
            if (node.mode & StrictMode) {
              maybeStrictRoot = node;
            }

            node = node.return;
          }

          return maybeStrictRoot;
        };

        ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
          if (pendingComponentWillMountWarnings.length > 0) {
            var uniqueNames = new Set();
            pendingComponentWillMountWarnings.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            lowPriorityWarning$1(false, "componentWillMount is deprecated and will be removed in the next major version. " + "Use componentDidMount instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillMount." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", sortedNames);
            pendingComponentWillMountWarnings = [];
          }

          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            var _uniqueNames = new Set();

            pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
              _uniqueNames.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames = setToSortedString(_uniqueNames);

            lowPriorityWarning$1(false, "componentWillReceiveProps is deprecated and will be removed in the next major version. " + "Use static getDerivedStateFromProps instead." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames);
            pendingComponentWillReceivePropsWarnings = [];
          }

          if (pendingComponentWillUpdateWarnings.length > 0) {
            var _uniqueNames2 = new Set();

            pendingComponentWillUpdateWarnings.forEach(function (fiber) {
              _uniqueNames2.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames2 = setToSortedString(_uniqueNames2);

            lowPriorityWarning$1(false, "componentWillUpdate is deprecated and will be removed in the next major version. " + "Use componentDidUpdate instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillUpdate." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames2);
            pendingComponentWillUpdateWarnings = [];
          }
        };

        ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
          if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
            return;
          }

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
        };

        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }

          var warningsForRoot = void 0;

          if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
            warningsForRoot = {
              UNSAFE_componentWillMount: [],
              UNSAFE_componentWillReceiveProps: [],
              UNSAFE_componentWillUpdate: []
            };
            pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
          } else {
            warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
          }

          var unsafeLifecycles = [];

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillMount");
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillReceiveProps");
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillUpdate");
          }

          if (unsafeLifecycles.length > 0) {
            unsafeLifecycles.forEach(function (lifecycle) {
              warningsForRoot[lifecycle].push(fiber);
            });
          }
        };

        ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }

          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
            if (warningsForRoot === undefined) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }

            warningsForRoot.push(fiber);
          }
        };

        ReactStrictModeWarnings.flushLegacyContextWarning = function () {
          pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
            var uniqueNames = new Set();
            fiberArray.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
            warningWithoutStack$1(false, "Legacy context API has been detected within a strict-mode tree: %s" + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, sortedNames);
          });
        };
      }
      var ReactFiberInstrumentation = {
        debugTool: null
      };
      var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

      function markPendingPriorityLevel(root, expirationTime) {
        root.didError = false;
        var earliestPendingTime = root.earliestPendingTime;

        if (earliestPendingTime === NoWork) {
          root.earliestPendingTime = root.latestPendingTime = expirationTime;
        } else {
          if (earliestPendingTime < expirationTime) {
            root.earliestPendingTime = expirationTime;
          } else {
            var latestPendingTime = root.latestPendingTime;

            if (latestPendingTime > expirationTime) {
              root.latestPendingTime = expirationTime;
            }
          }
        }

        findNextExpirationTimeToWorkOn(expirationTime, root);
      }

      function markCommittedPriorityLevels(root, earliestRemainingTime) {
        root.didError = false;

        if (earliestRemainingTime === NoWork) {
          root.earliestPendingTime = NoWork;
          root.latestPendingTime = NoWork;
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        if (earliestRemainingTime < root.latestPingedTime) {
          root.latestPingedTime = NoWork;
        }

        var latestPendingTime = root.latestPendingTime;

        if (latestPendingTime !== NoWork) {
          if (latestPendingTime > earliestRemainingTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            var earliestPendingTime = root.earliestPendingTime;

            if (earliestPendingTime > earliestRemainingTime) {
              root.earliestPendingTime = root.latestPendingTime;
            }
          }
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestRemainingTime < latestSuspendedTime) {
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        if (earliestRemainingTime > earliestSuspendedTime) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        findNextExpirationTimeToWorkOn(NoWork, root);
      }

      function hasLowerPriorityWork(root, erroredExpirationTime) {
        var latestPendingTime = root.latestPendingTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var latestPingedTime = root.latestPingedTime;
        return latestPendingTime !== NoWork && latestPendingTime < erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime < erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime < erroredExpirationTime;
      }

      function isPriorityLevelSuspended(root, expirationTime) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        return earliestSuspendedTime !== NoWork && expirationTime <= earliestSuspendedTime && expirationTime >= latestSuspendedTime;
      }

      function markSuspendedPriorityLevel(root, suspendedTime) {
        root.didError = false;
        clearPing(root, suspendedTime);
        var earliestPendingTime = root.earliestPendingTime;
        var latestPendingTime = root.latestPendingTime;

        if (earliestPendingTime === suspendedTime) {
          if (latestPendingTime === suspendedTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            root.earliestPendingTime = latestPendingTime;
          }
        } else if (latestPendingTime === suspendedTime) {
          root.latestPendingTime = earliestPendingTime;
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
        } else {
          if (earliestSuspendedTime < suspendedTime) {
            root.earliestSuspendedTime = suspendedTime;
          } else if (latestSuspendedTime > suspendedTime) {
            root.latestSuspendedTime = suspendedTime;
          }
        }

        findNextExpirationTimeToWorkOn(suspendedTime, root);
      }

      function markPingedPriorityLevel(root, pingedTime) {
        root.didError = false;
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime === NoWork || latestPingedTime > pingedTime) {
          root.latestPingedTime = pingedTime;
        }

        findNextExpirationTimeToWorkOn(pingedTime, root);
      }

      function clearPing(root, completedTime) {
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime >= completedTime) {
          root.latestPingedTime = NoWork;
        }
      }

      function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
        var earliestExpirationTime = renderExpirationTime;
        var earliestPendingTime = root.earliestPendingTime;
        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestPendingTime > earliestExpirationTime) {
          earliestExpirationTime = earliestPendingTime;
        }

        if (earliestSuspendedTime > earliestExpirationTime) {
          earliestExpirationTime = earliestSuspendedTime;
        }

        return earliestExpirationTime;
      }

      function didExpireAtExpirationTime(root, currentTime) {
        var expirationTime = root.expirationTime;

        if (expirationTime !== NoWork && currentTime <= expirationTime) {
          root.nextExpirationTimeToWorkOn = currentTime;
        }
      }

      function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var earliestPendingTime = root.earliestPendingTime;
        var latestPingedTime = root.latestPingedTime;
        var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;

        if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime < completedExpirationTime)) {
          nextExpirationTimeToWorkOn = latestSuspendedTime;
        }

        var expirationTime = nextExpirationTimeToWorkOn;

        if (expirationTime !== NoWork && earliestSuspendedTime > expirationTime) {
          expirationTime = earliestSuspendedTime;
        }

        root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
        root.expirationTime = expirationTime;
      }

      var warning = warningWithoutStack$1;
      {
        warning = function warning(condition, format) {
          if (condition) {
            return;
          }

          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();

          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          warningWithoutStack$1.apply(undefined, [false, format + "%s"].concat(args, [stack]));
        };
      }
      var warning$1 = warning;

      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function shallowEqual(objA, objB) {
        if (is(objA, objB)) {
          return true;
        }

        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }

        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);

        if (keysA.length !== keysB.length) {
          return false;
        }

        for (var i = 0; i < keysA.length; i++) {
          if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
          }
        }

        return true;
      }

      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = _extends({}, baseProps);

          var defaultProps = Component.defaultProps;

          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }

          return props;
        }

        return baseProps;
      }

      function readLazyComponentType(lazyComponent) {
        var status = lazyComponent._status;
        var result = lazyComponent._result;

        switch (status) {
          case Resolved:
            {
              var Component = result;
              return Component;
            }

          case Rejected:
            {
              var error = result;
              throw error;
            }

          case Pending:
            {
              var thenable = result;
              throw thenable;
            }

          default:
            {
              lazyComponent._status = Pending;
              var ctor = lazyComponent._ctor;

              var _thenable = ctor();

              _thenable.then(function (moduleObject) {
                if (lazyComponent._status === Pending) {
                  var defaultExport = moduleObject.default;
                  {
                    if (defaultExport === undefined) {
                      warning$1(false, "lazy: Expected the result of a dynamic import() call. " + "Instead received: %s\n\nYour code should look like: \n  " + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    }
                  }
                  lazyComponent._status = Resolved;
                  lazyComponent._result = defaultExport;
                }
              }, function (error) {
                if (lazyComponent._status === Pending) {
                  lazyComponent._status = Rejected;
                  lazyComponent._result = error;
                }
              });

              switch (lazyComponent._status) {
                case Resolved:
                  return lazyComponent._result;

                case Rejected:
                  throw lazyComponent._result;
              }

              lazyComponent._result = _thenable;
              throw _thenable;
            }
        }
      }

      var fakeInternalInstance = {};
      var isArray$1 = Array.isArray;
      var emptyRefsObject = new React.Component().refs;
      var didWarnAboutStateAssignmentForComponent = void 0;
      var didWarnAboutUninitializedState = void 0;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
      var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
      var didWarnAboutUndefinedDerivedState = void 0;
      var warnOnUndefinedDerivedState = void 0;
      var warnOnInvalidCallback = void 0;
      var didWarnAboutDirectlyAssigningPropsToState = void 0;
      var didWarnAboutContextTypeAndContextTypes = void 0;
      var didWarnAboutInvalidateContextType = void 0;
      {
        didWarnAboutStateAssignmentForComponent = new Set();
        didWarnAboutUninitializedState = new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
        didWarnAboutDirectlyAssigningPropsToState = new Set();
        didWarnAboutUndefinedDerivedState = new Set();
        didWarnAboutContextTypeAndContextTypes = new Set();
        didWarnAboutInvalidateContextType = new Set();
        var didWarnOnInvalidCallback = new Set();

        warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }

          var key = callerName + "_" + callback;

          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            warningWithoutStack$1(false, "%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        };

        warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentName(type) || "Component";

            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              warningWithoutStack$1(false, "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
            }
          }
        };

        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function value() {
            invariant(false, "_processChildContext is not available in React 16+. This likely " + "means you have multiple copies of React and are attempting to nest " + "a React 15 tree inside a React 16 tree using " + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + "to make sure you have only one copy of React (and ideally, switch " + "to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }

      function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress.memoizedState;
        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            getDerivedStateFromProps(nextProps, prevState);
          }
        }
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === undefined ? prevState : _extends({}, prevState, partialState);
        workInProgress.memoizedState = memoizedState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
          updateQueue.baseState = memoizedState;
        }
      }

      var classComponentUpdater = {
        isMounted: isMounted,
        enqueueSetState: function enqueueSetState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ReplaceState;
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ForceUpdate;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        }
      };

      function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress.stateNode;

        if (typeof instance.shouldComponentUpdate === "function") {
          startPhaseTimer(workInProgress, "shouldComponentUpdate");
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          stopPhaseTimer();
          {
            !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component") : void 0;
          }
          return shouldUpdate;
        }

        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }

        return true;
      }

      function checkClassInstance(workInProgress, ctor, newProps) {
        var instance = workInProgress.stateNode;
        {
          var name = getComponentName(ctor) || "Component";
          var renderPresent = instance.render;

          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
            } else {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
            }
          }

          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
          !noGetInitialStateOnES6 ? warningWithoutStack$1(false, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name) : void 0;
          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
          !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name) : void 0;
          var noInstancePropTypes = !instance.propTypes;
          !noInstancePropTypes ? warningWithoutStack$1(false, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name) : void 0;
          var noInstanceContextType = !instance.contextType;
          !noInstanceContextType ? warningWithoutStack$1(false, "contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name) : void 0;
          var noInstanceContextTypes = !instance.contextTypes;
          !noInstanceContextTypes ? warningWithoutStack$1(false, "contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name) : void 0;

          if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            warningWithoutStack$1(false, "%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name);
          }

          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== "function";
          !noComponentShouldUpdate ? warningWithoutStack$1(false, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name) : void 0;

          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            warningWithoutStack$1(false, "%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
          }

          var noComponentDidUnmount = typeof instance.componentDidUnmount !== "function";
          !noComponentDidUnmount ? warningWithoutStack$1(false, "%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name) : void 0;
          var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== "function";
          !noComponentDidReceiveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name) : void 0;
          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== "function";
          !noComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name) : void 0;
          var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== "function";
          !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name) : void 0;
          var hasMutatedProps = instance.props !== newProps;
          !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, "%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name) : void 0;
          var noInstanceDefaultProps = !instance.defaultProps;
          !noInstanceDefaultProps ? warningWithoutStack$1(false, "Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name) : void 0;

          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
          }

          var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== "function";
          !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, "%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== "function";
          !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, "%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== "function";
          !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name) : void 0;
          var _state = instance.state;

          if (_state && (typeof _state !== "object" || isArray$1(_state))) {
            warningWithoutStack$1(false, "%s.state: must be set to an object or null", name);
          }

          if (typeof instance.getChildContext === "function") {
            !(typeof ctor.childContextTypes === "object") ? warningWithoutStack$1(false, "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name) : void 0;
          }
        }
      }

      function adoptClassInstance(workInProgress, instance) {
        instance.updater = classComponentUpdater;
        workInProgress.stateNode = instance;
        set(instance, workInProgress);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }

      function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = null;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          {
            if (contextType.$$typeof !== REACT_CONTEXT_TYPE && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              warningWithoutStack$1(false, "%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext(). " + "Did you accidentally pass the Context.Provider instead?", getComponentName(ctor) || "Component");
            }
          }
          context = _readContext(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
        }

        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            new ctor(props, context);
          }
        }
        var instance = new ctor(props, context);
        var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
        adoptClassInstance(workInProgress, instance);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              warningWithoutStack$1(false, "`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }

          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;

            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }

            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }

            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }

            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentName(ctor) || "Component";

              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";

              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                warningWithoutStack$1(false, "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" + "The above lifecycles should be removed. Learn more about this warning here:\n" + "https://fb.me/react-async-component-lifecycle-hooks", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }

        if (isLegacyContextConsumer) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return instance;
      }

      function callComponentWillMount(workInProgress, instance) {
        startPhaseTimer(workInProgress, "componentWillMount");
        var oldState = instance.state;

        if (typeof instance.componentWillMount === "function") {
          instance.componentWillMount();
        }

        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }

        stopPhaseTimer();

        if (oldState !== instance.state) {
          {
            warningWithoutStack$1(false, "%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentName(workInProgress.type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        var oldState = instance.state;
        startPhaseTimer(workInProgress, "componentWillReceiveProps");

        if (typeof instance.componentWillReceiveProps === "function") {
          instance.componentWillReceiveProps(newProps, nextContext);
        }

        if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }

        stopPhaseTimer();

        if (instance.state !== oldState) {
          {
            var componentName = getComponentName(workInProgress.type) || "Component";

            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              warningWithoutStack$1(false, "%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        {
          checkClassInstance(workInProgress, ctor, newProps);
        }
        var instance = workInProgress.stateNode;
        instance.props = newProps;
        instance.state = workInProgress.memoizedState;
        instance.refs = emptyRefsObject;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          instance.context = _readContext(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          instance.context = getMaskedContext(workInProgress, unmaskedContext);
        }

        {
          if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              warningWithoutStack$1(false, "%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
          }

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);
          }
        }
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          instance.state = workInProgress.memoizedState;
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          instance.state = workInProgress.memoizedState;
        }

        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(workInProgress, instance);
          updateQueue = workInProgress.updateQueue;

          if (updateQueue !== null) {
            processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
            instance.state = workInProgress.memoizedState;
          }
        }

        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
      }

      function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = _readContext(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            startPhaseTimer(workInProgress, "componentWillMount");

            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }

            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }
        } else {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = _readContext(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
            startPhaseTimer(workInProgress, "componentWillUpdate");

            if (typeof instance.componentWillUpdate === "function") {
              instance.componentWillUpdate(newProps, newState, nextContext);
            }

            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidUpdate === "function") {
            workInProgress.effectTag |= Update;
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            workInProgress.effectTag |= Snapshot;
          }
        } else {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      var didWarnAboutMaps = void 0;
      var didWarnAboutGenerators = void 0;
      var didWarnAboutStringRefInStrictMode = void 0;
      var ownerHasKeyUseWarning = void 0;
      var ownerHasFunctionTypeWarning = void 0;

      var warnForMissingKey = function warnForMissingKey(child) {};

      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefInStrictMode = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};

        warnForMissingKey = function warnForMissingKey(child) {
          if (child === null || typeof child !== "object") {
            return;
          }

          if (!child._store || child._store.validated || child.key != null) {
            return;
          }

          invariant(typeof child._store === "object", "React Component in warnForMissingKey should have a _store. " + "This error is likely caused by a bug in React. Please file an issue.");
          child._store.validated = true;
          var currentComponentErrorInfo = "Each child in a list should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information." + getCurrentFiberStackInDev();

          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }

          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          warning$1(false, "Each child in a list should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information.");
        };
      }
      var isArray = Array.isArray;

      function coerceRef(returnFiber, current$$1, element) {
        var mixedRef = element.ref;

        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if (returnFiber.mode & StrictMode) {
              var componentName = getComponentName(returnFiber.type) || "Component";

              if (!didWarnAboutStringRefInStrictMode[componentName]) {
                warningWithoutStack$1(false, 'A string ref, "%s", has been found within a strict mode tree. ' + "String refs are a source of potential bugs and should be avoided. " + "We recommend using createRef() instead." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-string-ref", mixedRef, getStackByFiberInDevAndProd(returnFiber));
                didWarnAboutStringRefInStrictMode[componentName] = true;
              }
            }
          }

          if (element._owner) {
            var owner = element._owner;
            var inst = void 0;

            if (owner) {
              var ownerFiber = owner;
              invariant(ownerFiber.tag === ClassComponent, "Function components cannot have refs. " + "Did you mean to use React.forwardRef()?");
              inst = ownerFiber.stateNode;
            }

            invariant(inst, "Missing owner for string ref %s. This error is likely caused by a " + "bug in React. Please file an issue.", mixedRef);
            var stringRef = "" + mixedRef;

            if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === "function" && current$$1.ref._stringRef === stringRef) {
              return current$$1.ref;
            }

            var ref = function ref(value) {
              var refs = inst.refs;

              if (refs === emptyRefsObject) {
                refs = inst.refs = {};
              }

              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };

            ref._stringRef = stringRef;
            return ref;
          } else {
            invariant(typeof mixedRef === "string", "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" + " the following reasons:\n" + "1. You may be adding a ref to a function component\n" + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + "3. You have multiple copies of React loaded\n" + "See https://fb.me/react-refs-must-have-owner for more information.", mixedRef);
          }
        }

        return mixedRef;
      }

      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== "textarea") {
          var addendum = "";
          {
            addendum = " If you meant to render a collection of children, use an array " + "instead." + getCurrentFiberStackInDev();
          }
          invariant(false, "Objects are not valid as a React child (found: %s).%s", Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, addendum);
        }
      }

      function warnOnFunctionType() {
        var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it." + getCurrentFiberStackInDev();

        if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
        warning$1(false, "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
      }

      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }

          var last = returnFiber.lastEffect;

          if (last !== null) {
            last.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
          }

          childToDelete.nextEffect = null;
          childToDelete.effectTag = Deletion;
        }

        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }

          var childToDelete = currentFirstChild;

          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }

          return null;
        }

        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = new Map();
          var existingChild = currentFirstChild;

          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }

            existingChild = existingChild.sibling;
          }

          return existingChildren;
        }

        function useFiber(fiber, pendingProps, expirationTime) {
          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }

        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;

          if (!shouldTrackSideEffects) {
            return lastPlacedIndex;
          }

          var current$$1 = newFiber.alternate;

          if (current$$1 !== null) {
            var oldIndex = current$$1.index;

            if (oldIndex < lastPlacedIndex) {
              newFiber.effectTag = Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          }
        }

        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.effectTag = Placement;
          }

          return newFiber;
        }

        function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateElement(returnFiber, current$$1, element, expirationTime) {
          if (current$$1 !== null && current$$1.elementType === element.type) {
            var existing = useFiber(current$$1, element.props, expirationTime);
            existing.ref = coerceRef(returnFiber, current$$1, element);
            existing.return = returnFiber;
            {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          } else {
            var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
            created.ref = coerceRef(returnFiber, current$$1, element);
            created.return = returnFiber;
            return created;
          }
        }

        function updatePortal(returnFiber, current$$1, portal, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, portal.children || [], expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
          if (current$$1 === null || current$$1.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, fragment, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function createChild(returnFiber, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);

                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }

              case REACT_PORTAL_TYPE:
                {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);

                  _created2.return = returnFiber;
                  return _created2;
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);

              _created3.return = returnFiber;
              return _created3;
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
          var key = oldFiber !== null ? oldFiber.key : null;

          if (typeof newChild === "string" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }

            return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  if (newChild.key === key) {
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                    }

                    return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }

              case REACT_PORTAL_TYPE:
                {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }

              return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                  }

                  return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                }

              case REACT_PORTAL_TYPE:
                {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;

              return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function warnOnInvalidKey(child, knownKeys) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }

            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child);
                var key = child.key;

                if (typeof key !== "string") {
                  break;
                }

                if (knownKeys === null) {
                  knownKeys = new Set();
                  knownKeys.add(key);
                  break;
                }

                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }

                warning$1(false, "Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted — the behavior is unsupported and " + "could change in a future version.", key);
                break;

              default:
                break;
            }
          }
          return knownKeys;
        }

        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
          {
            var knownKeys = null;

            for (var i = 0; i < newChildren.length; i++) {
              var child = newChildren[i];
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;

          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);

              if (!_newFiber) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }

              previousNewFiber = _newFiber;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);

            if (_newFiber2) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }

              previousNewFiber = _newFiber2;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          invariant(typeof iteratorFn === "function", "An object is not an iterable. This error is likely caused by a bug in " + "React. Please file an issue.");
          {
            if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
              !didWarnAboutGenerators ? warning$1(false, "Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.") : void 0;
              didWarnAboutGenerators = true;
            }

            if (newChildrenIterable.entries === iteratorFn) {
              !didWarnAboutMaps ? warning$1(false, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.") : void 0;
              didWarnAboutMaps = true;
            }

            var _newChildren = iteratorFn.call(newChildrenIterable);

            if (_newChildren) {
              var knownKeys = null;

              var _step = _newChildren.next();

              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          invariant(newChildren != null, "An iterable object provided no iterator.");
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();

          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

            if (newFiber === null) {
              if (!oldFiber) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, expirationTime);

              if (_newFiber3 === null) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }

              previousNewFiber = _newFiber3;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);

            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }

              previousNewFiber = _newFiber4;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }

          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
          var key = element.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.elementType === element.type) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
                existing.ref = coerceRef(returnFiber, child, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
            created.return = returnFiber;
            return created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);

            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }

        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
          var key = portal.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || [], expirationTime);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }

          var isObject = typeof newChild === "object" && newChild !== null;

          if (isObject) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
            }
          }

          if (typeof newChild === "string" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
          }

          if (isArray(newChild)) {
            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (getIteratorFn(newChild)) {
            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (isObject) {
            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }

          if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
            switch (returnFiber.tag) {
              case ClassComponent:
                {
                  {
                    var instance = returnFiber.stateNode;

                    if (instance.render._isMockFunction) {
                      break;
                    }
                  }
                }

              case FunctionComponent:
                {
                  var Component = returnFiber.type;
                  invariant(false, "%s(...): Nothing was returned from render. This usually means a " + "return statement is missing. Or, to render nothing, " + "return null.", Component.displayName || Component.name || "Component");
                }
            }
          }

          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }

        return reconcileChildFibers;
      }

      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);

      function cloneChildFibers(current$$1, workInProgress) {
        invariant(current$$1 === null || workInProgress.child === current$$1.child, "Resuming work not yet implemented.");

        if (workInProgress.child === null) {
          return;
        }

        var currentChild = workInProgress.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
        workInProgress.child = newChild;
        newChild.return = workInProgress;

        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
          newChild.return = workInProgress;
        }

        newChild.sibling = null;
      }

      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);

      function requiredContext(c) {
        invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug " + "in React. Please file an issue.");
        return c;
      }

      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }

      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }

      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }

      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }

      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type, rootInstance);

        if (context === nextContext) {
          return;
        }

        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }

      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }

        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }

      var NoEffect$1 = 0;
      var UnmountSnapshot = 2;
      var UnmountMutation = 4;
      var MountMutation = 8;
      var UnmountLayout = 16;
      var MountLayout = 32;
      var MountPassive = 64;
      var UnmountPassive = 128;
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var didWarnAboutMismatchedHooksForComponent = void 0;
      {
        didWarnAboutMismatchedHooksForComponent = new Set();
      }
      var renderExpirationTime = NoWork;
      var currentlyRenderingFiber$1 = null;
      var firstCurrentHook = null;
      var currentHook = null;
      var nextCurrentHook = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var nextWorkInProgressHook = null;
      var remainingExpirationTime = NoWork;
      var componentUpdateQueue = null;
      var sideEffectTag = 0;
      var didScheduleRenderPhaseUpdate = false;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var currentHookNameInDev = null;

      function warnOnHookMismatchInDev() {
        {
          var componentName = getComponentName(currentlyRenderingFiber$1.type);

          if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            var secondColumnStart = 22;
            var table = "";
            var prevHook = firstCurrentHook;
            var nextHook = firstWorkInProgressHook;
            var n = 1;

            while (prevHook !== null && nextHook !== null) {
              var oldHookName = prevHook._debugType;
              var newHookName = nextHook._debugType;
              var row = n + ". " + oldHookName;

              while (row.length < secondColumnStart) {
                row += " ";
              }

              row += newHookName + "\n";
              table += row;
              prevHook = prevHook.next;
              nextHook = nextHook.next;
              n++;
            }

            warning$1(false, "React has detected a change in the order of Hooks called by %s. " + "This will lead to bugs and errors if not fixed. " + "For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n" + "   Previous render    Next render\n" + "   -------------------------------\n" + "%s" + "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
          }
        }
      }

      function throwInvalidHookError() {
        invariant(false, "Hooks can only be called inside the body of a function component. " + "(https://fb.me/react-invalid-hook-call)");
      }

      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            warning$1(false, "%s received a final argument during this render, but not during " + "the previous render. Even though the final argument is optional, " + "its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }

        {
          if (nextDeps.length !== prevDeps.length) {
            warning$1(false, "The final argument passed to %s changed size between renders. The " + "order and size of this array must remain constant.\n\n" + "Previous: %s\n" + "Incoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }

        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (is(nextDeps[i], prevDeps[i])) {
            continue;
          }

          return false;
        }

        return true;
      }

      function renderWithHooks(current, workInProgress, Component, props, refOrContext, nextRenderExpirationTime) {
        renderExpirationTime = nextRenderExpirationTime;
        currentlyRenderingFiber$1 = workInProgress;
        firstCurrentHook = nextCurrentHook = current !== null ? current.memoizedState : null;
        {
          ReactCurrentDispatcher$1.current = nextCurrentHook === null ? HooksDispatcherOnMountInDEV : HooksDispatcherOnUpdateInDEV;
        }
        var children = Component(props, refOrContext);

        if (didScheduleRenderPhaseUpdate) {
          do {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            firstCurrentHook = nextCurrentHook = current !== null ? current.memoizedState : null;
            nextWorkInProgressHook = firstWorkInProgressHook;
            currentHook = null;
            workInProgressHook = null;
            componentUpdateQueue = null;
            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            children = Component(props, refOrContext);
          } while (didScheduleRenderPhaseUpdate);

          renderPhaseUpdates = null;
          numberOfReRenders = 0;
        }

        {
          currentHookNameInDev = null;
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        var renderedWork = currentlyRenderingFiber$1;
        renderedWork.memoizedState = firstWorkInProgressHook;
        renderedWork.expirationTime = remainingExpirationTime;
        renderedWork.updateQueue = componentUpdateQueue;
        renderedWork.effectTag |= sideEffectTag;
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        nextCurrentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        nextWorkInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        sideEffectTag = 0;
        invariant(!didRenderTooFewHooks, "Rendered fewer hooks than expected. This may be caused by an accidental " + "early return statement.");
        return children;
      }

      function bailoutHooks(current, workInProgress, expirationTime) {
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.effectTag &= ~(Passive | Update);

        if (current.expirationTime <= expirationTime) {
          current.expirationTime = NoWork;
        }
      }

      function resetHooks() {
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        nextCurrentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        nextWorkInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        sideEffectTag = 0;
        {
          currentHookNameInDev = null;
        }
        didScheduleRenderPhaseUpdate = false;
        renderPhaseUpdates = null;
        numberOfReRenders = 0;
      }

      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          queue: null,
          baseUpdate: null,
          next: null
        };
        {
          hook._debugType = currentHookNameInDev;
        }

        if (workInProgressHook === null) {
          firstWorkInProgressHook = workInProgressHook = hook;
        } else {
          workInProgressHook = workInProgressHook.next = hook;
        }

        return workInProgressHook;
      }

      function updateWorkInProgressHook() {
        if (nextWorkInProgressHook !== null) {
          workInProgressHook = nextWorkInProgressHook;
          nextWorkInProgressHook = workInProgressHook.next;
          currentHook = nextCurrentHook;
          nextCurrentHook = currentHook !== null ? currentHook.next : null;
        } else {
          invariant(nextCurrentHook !== null, "Rendered more hooks than during the previous render.");
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            queue: currentHook.queue,
            baseUpdate: currentHook.baseUpdate,
            next: null
          };

          if (workInProgressHook === null) {
            workInProgressHook = firstWorkInProgressHook = newHook;
          } else {
            workInProgressHook = workInProgressHook.next = newHook;
          }

          nextCurrentHook = currentHook.next;
          {
            newHook._debugType = currentHookNameInDev;

            if (currentHookNameInDev !== currentHook._debugType) {
              warnOnHookMismatchInDev();
            }
          }
        }

        return workInProgressHook;
      }

      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null
        };
      }

      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }

      function mountContext(context, observedBits) {
        {
          mountWorkInProgressHook();
        }
        return _readContext(context, observedBits);
      }

      function updateContext(context, observedBits) {
        {
          updateWorkInProgressHook();
        }
        return _readContext(context, observedBits);
      }

      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState = void 0;

        if (init !== undefined) {
          initialState = init(initialArg);
        } else {
          initialState = initialArg;
        }

        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
          last: null,
          dispatch: null,
          eagerReducer: reducer,
          eagerState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }

      function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        invariant(queue !== null, "Should have a queue. This is likely a bug in React. Please file an issue.");

        if (numberOfReRenders > 0) {
          var _dispatch = queue.dispatch;

          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue);
              var newState = hook.memoizedState;
              var update = firstRenderPhaseUpdate;

              do {
                var _action = update.action;
                newState = reducer(newState, _action);
                update = update.next;
              } while (update !== null);

              if (!is(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }

              hook.memoizedState = newState;

              if (hook.baseUpdate === queue.last) {
                hook.baseState = newState;
              }

              queue.eagerReducer = reducer;
              queue.eagerState = newState;
              return [newState, _dispatch];
            }
          }

          return [hook.memoizedState, _dispatch];
        }

        var last = queue.last;
        var baseUpdate = hook.baseUpdate;
        var baseState = hook.baseState;
        var first = void 0;

        if (baseUpdate !== null) {
          if (last !== null) {
            last.next = null;
          }

          first = baseUpdate.next;
        } else {
          first = last !== null ? last.next : null;
        }

        if (first !== null) {
          var _newState = baseState;
          var newBaseState = null;
          var newBaseUpdate = null;
          var prevUpdate = baseUpdate;
          var _update = first;
          var didSkip = false;

          do {
            var updateExpirationTime = _update.expirationTime;

            if (updateExpirationTime < renderExpirationTime) {
              if (!didSkip) {
                didSkip = true;
                newBaseUpdate = prevUpdate;
                newBaseState = _newState;
              }

              if (updateExpirationTime > remainingExpirationTime) {
                remainingExpirationTime = updateExpirationTime;
              }
            } else {
              if (_update.eagerReducer === reducer) {
                _newState = _update.eagerState;
              } else {
                var _action2 = _update.action;
                _newState = reducer(_newState, _action2);
              }
            }

            prevUpdate = _update;
            _update = _update.next;
          } while (_update !== null && _update !== first);

          if (!didSkip) {
            newBaseUpdate = prevUpdate;
            newBaseState = _newState;
          }

          if (!is(_newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }

          hook.memoizedState = _newState;
          hook.baseUpdate = newBaseUpdate;
          hook.baseState = newBaseState;
          queue.eagerReducer = reducer;
          queue.eagerState = _newState;
        }

        var dispatch = queue.dispatch;
        return [hook.memoizedState, dispatch];
      }

      function mountState(initialState) {
        var hook = mountWorkInProgressHook();

        if (typeof initialState === "function") {
          initialState = initialState();
        }

        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
          last: null,
          dispatch: null,
          eagerReducer: basicStateReducer,
          eagerState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }

      function updateState(initialState) {
        return updateReducer(basicStateReducer, initialState);
      }

      function pushEffect(tag, create, destroy, deps) {
        var effect = {
          tag: tag,
          create: create,
          destroy: destroy,
          deps: deps,
          next: null
        };

        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var _lastEffect = componentUpdateQueue.lastEffect;

          if (_lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = _lastEffect.next;
            _lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }

        return effect;
      }

      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        var ref = {
          current: initialValue
        };
        {
          Object.seal(ref);
        }
        hook.memoizedState = ref;
        return ref;
      }

      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }

      function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        sideEffectTag |= fiberEffectTag;
        hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);
      }

      function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var destroy = undefined;

        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;

          if (nextDeps !== null) {
            var prevDeps = prevEffect.deps;

            if (areHookInputsEqual(nextDeps, prevDeps)) {
              pushEffect(NoEffect$1, create, destroy, nextDeps);
              return;
            }
          }
        }

        sideEffectTag |= fiberEffectTag;
        hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);
      }

      function mountEffect(create, deps) {
        return mountEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
      }

      function updateEffect(create, deps) {
        return updateEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
      }

      function mountLayoutEffect(create, deps) {
        return mountEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
      }

      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
      }

      function imperativeHandleEffect(create, ref) {
        if (typeof ref === "function") {
          var refCallback = ref;

          var _inst = create();

          refCallback(_inst);
          return function () {
            refCallback(null);
          };
        } else if (ref !== null && ref !== undefined) {
          var refObject = ref;
          {
            !refObject.hasOwnProperty("current") ? warning$1(false, "Expected useImperativeHandle() first argument to either be a " + "ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}") : void 0;
          }

          var _inst2 = create();

          refObject.current = _inst2;
          return function () {
            refObject.current = null;
          };
        }
      }

      function mountImperativeHandle(ref, create, deps) {
        {
          !(typeof create === "function") ? warning$1(false, "Expected useImperativeHandle() second argument to be a function " + "that creates a handle. Instead received: %s.", create !== null ? typeof create : "null") : void 0;
        }
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
        return mountEffectImpl(Update, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }

      function updateImperativeHandle(ref, create, deps) {
        {
          !(typeof create === "function") ? warning$1(false, "Expected useImperativeHandle() second argument to be a function " + "that creates a handle. Instead received: %s.", create !== null ? typeof create : "null") : void 0;
        }
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
        return updateEffectImpl(Update, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }

      function mountDebugValue(value, formatterFn) {}

      var updateDebugValue = mountDebugValue;

      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }

      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;

        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];

            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }

        hook.memoizedState = [callback, nextDeps];
        return callback;
      }

      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }

      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;

        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];

            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }

        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }

      var shouldWarnForUnbatchedSetState = false;
      {
        if ("undefined" !== typeof jest) {
          shouldWarnForUnbatchedSetState = true;
        }
      }

      function dispatchAction(fiber, queue, action) {
        invariant(numberOfReRenders < RE_RENDER_LIMIT, "Too many re-renders. React limits the number of renders to prevent " + "an infinite loop.");
        {
          !(arguments.length <= 3) ? warning$1(false, "State updates from the useState() and useReducer() Hooks don't support the " + "second callback argument. To execute a side effect after " + "rendering, declare it in the component body with useEffect().") : void 0;
        }
        var alternate = fiber.alternate;

        if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            expirationTime: renderExpirationTime,
            action: action,
            eagerReducer: null,
            eagerState: null,
            next: null
          };

          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map();
          }

          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }

            lastRenderPhaseUpdate.next = update;
          }
        } else {
          flushPassiveEffects();
          var currentTime = requestCurrentTime();

          var _expirationTime = computeExpirationForFiber(currentTime, fiber);

          var _update2 = {
            expirationTime: _expirationTime,
            action: action,
            eagerReducer: null,
            eagerState: null,
            next: null
          };
          var _last = queue.last;

          if (_last === null) {
            _update2.next = _update2;
          } else {
            var first = _last.next;

            if (first !== null) {
              _update2.next = first;
            }

            _last.next = _update2;
          }

          queue.last = _update2;

          if (fiber.expirationTime === NoWork && (alternate === null || alternate.expirationTime === NoWork)) {
            var _eagerReducer = queue.eagerReducer;

            if (_eagerReducer !== null) {
              var prevDispatcher = void 0;
              {
                prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              }

              try {
                var currentState = queue.eagerState;

                var _eagerState = _eagerReducer(currentState, action);

                _update2.eagerReducer = _eagerReducer;
                _update2.eagerState = _eagerState;

                if (is(_eagerState, currentState)) {
                  return;
                }
              } catch (error) {} finally {
                {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              }
            }
          }

          {
            if (shouldWarnForUnbatchedSetState === true) {
              warnIfNotCurrentlyBatchingInDev(fiber);
            }
          }
          scheduleWork(fiber, _expirationTime);
        }
      }

      var ContextOnlyDispatcher = {
        readContext: _readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError
      };
      var HooksDispatcherOnMountInDEV = null;
      var HooksDispatcherOnUpdateInDEV = null;
      var InvalidNestedHooksDispatcherOnMountInDEV = null;
      var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
      {
        var warnInvalidContextAccess = function warnInvalidContextAccess() {
          warning$1(false, "Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
        };

        var warnInvalidHookAccess = function warnInvalidHookAccess() {
          warning$1(false, "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " + "You can only call Hooks at the top level of your React function. " + "For more information, see " + "https://fb.me/rules-of-hooks");
        };

        HooksDispatcherOnMountInDEV = {
          readContext: function readContext(context, observedBits) {
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            return mountCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            return mountContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            return mountEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            return mountImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            return mountLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            return mountRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            return mountDebugValue(value, formatterFn);
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function readContext(context, observedBits) {
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            return updateCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            return updateContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            return updateEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            return updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            return updateLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            return updateRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            return updateDebugValue(value, formatterFn);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function readContext(context, observedBits) {
            warnInvalidContextAccess();
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            return mountCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            return mountContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            return mountImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            return mountRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            return mountDebugValue(value, formatterFn);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function readContext(context, observedBits) {
            warnInvalidContextAccess();
            return _readContext(context, observedBits);
          },
          useCallback: function useCallback(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            return updateCallback(callback, deps);
          },
          useContext: function useContext(context, observedBits) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            return updateContext(context, observedBits);
          },
          useEffect: function useEffect(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function useImperativeHandle(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            return updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function useLayoutEffect(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function useMemo(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function useReducer(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function useRef(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            return updateRef(initialValue);
          },
          useState: function useState(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function useDebugValue(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            return updateDebugValue(value, formatterFn);
          }
        };
      }
      var commitTime = 0;
      var profilerStartTime = -1;

      function getCommitTime() {
        return commitTime;
      }

      function recordCommitTime() {
        if (!enableProfilerTimer) {
          return;
        }

        commitTime = now$$1();
      }

      function startProfilerTimer(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = now$$1();

        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now$$1();
        }
      }

      function stopProfilerTimerIfRunning(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = -1;
      }

      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (!enableProfilerTimer) {
          return;
        }

        if (profilerStartTime >= 0) {
          var elapsedTime = now$$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime;

          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }

          profilerStartTime = -1;
        }
      }

      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;

      function enterHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChild(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        return true;
      }

      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber) {
        if (!supportsHydration) {
          return false;
        }

        var suspenseInstance = fiber.stateNode;
        nextHydratableInstance = getNextHydratableSibling(suspenseInstance);
        popToNextHostParent(fiber);
        isHydrating = true;
        return true;
      }

      function deleteHydratableInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot:
              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
              break;

            case HostComponent:
              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
              break;
          }
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        childToDelete.effectTag = Deletion;

        if (returnFiber.lastEffect !== null) {
          returnFiber.lastEffect.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }
      }

      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.effectTag |= Placement;
        {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;

                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableContainerInstance(parentContainer, type, props);
                    break;

                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableContainerTextInstance(parentContainer, text);
                    break;

                  case SuspenseComponent:
                    didNotFindHydratableContainerSuspenseInstance(parentContainer);
                    break;
                }

                break;
              }

            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;

                switch (fiber.tag) {
                  case HostComponent:
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                    break;

                  case HostText:
                    var _text = fiber.pendingProps;
                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                    break;

                  case SuspenseComponent:
                    didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);
                    break;
                }

                break;
              }

            default:
              return;
          }
        }
      }

      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent:
            {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type, props);

              if (instance !== null) {
                fiber.stateNode = instance;
                return true;
              }

              return false;
            }

          case HostText:
            {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);

              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                return true;
              }

              return false;
            }

          case SuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);

                if (suspenseInstance !== null) {
                  fiber.tag = DehydratedSuspenseComponent;
                  fiber.stateNode = suspenseInstance;
                  return true;
                }
              }

              return false;
            }

          default:
            return false;
        }
      }

      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }

        var nextInstance = nextHydratableInstance;

        if (!nextInstance) {
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }

        var firstAttemptedInstance = nextInstance;

        if (!tryHydrate(fiber, nextInstance)) {
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);

          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }

          deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
        }

        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
      }

      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var instance = fiber.stateNode;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
        fiber.updateQueue = updatePayload;

        if (updatePayload !== null) {
          return true;
        }

        return false;
      }

      function prepareToHydrateHostTextInstance(fiber) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostTextInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        {
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;

            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot:
                  {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                  }

                case HostComponent:
                  {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
                  }
              }
            }
          }
        }
        return shouldUpdate;
      }

      function skipPastDehydratedSuspenseInstance(fiber) {
        if (!supportsHydration) {
          invariant(false, "Expected skipPastDehydratedSuspenseInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var suspenseInstance = fiber.stateNode;
        invariant(suspenseInstance, "Expected to have a hydrated suspense instance. " + "This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }

      function popToNextHostParent(fiber) {
        var parent = fiber.return;

        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== DehydratedSuspenseComponent) {
          parent = parent.return;
        }

        hydrationParentFiber = parent;
      }

      function popHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        if (fiber !== hydrationParentFiber) {
          return false;
        }

        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }

        var type = fiber.type;

        if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
          var nextInstance = nextHydratableInstance;

          while (nextInstance) {
            deleteHydratableInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }

        popToNextHostParent(fiber);
        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
      }

      function resetHydrationState() {
        if (!supportsHydration) {
          return;
        }

        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
      }

      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var didReceiveUpdate = false;
      var didWarnAboutBadClass = void 0;
      var didWarnAboutContextTypeOnFunctionComponent = void 0;
      var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
      var didWarnAboutFunctionRefs = void 0;
      var didWarnAboutReassigningProps = void 0;
      {
        didWarnAboutBadClass = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
        didWarnAboutReassigningProps = false;
      }

      function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        if (current$$1 === null) {
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
        }
      }

      function forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime);
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      }

      function updateForwardRef(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
            }
          }
        }
        var render = Component.render;
        var ref = workInProgress.ref;
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = renderWithHooks(current$$1, workInProgress, render, nextProps, ref, renderExpirationTime);

          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            if (workInProgress.memoizedState !== null) {
              nextChildren = renderWithHooks(current$$1, workInProgress, render, nextProps, ref, renderExpirationTime);
            }
          }

          setCurrentPhase(null);
        }

        if (current$$1 !== null && !didReceiveUpdate) {
          bailoutHooks(current$$1, workInProgress, renderExpirationTime);
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        if (current$$1 === null) {
          var type = Component.type;

          if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === undefined) {
            workInProgress.tag = SimpleMemoComponent;
            workInProgress.type = type;
            {
              validateFunctionComponentInDev(workInProgress, type);
            }
            return updateSimpleMemoComponent(current$$1, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
          }

          {
            var innerPropTypes = type.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(type), getCurrentFiberStackInDev);
            }
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
          child.ref = workInProgress.ref;
          child.return = workInProgress;
          workInProgress.child = child;
          return child;
        }

        {
          var _type = Component.type;
          var _innerPropTypes = _type.propTypes;

          if (_innerPropTypes) {
            checkPropTypes(_innerPropTypes, nextProps, "prop", getComponentName(_type), getCurrentFiberStackInDev);
          }
        }
        var currentChild = current$$1.child;

        if (updateExpirationTime < renderExpirationTime) {
          var prevProps = currentChild.memoizedProps;
          var compare = Component.compare;
          compare = compare !== null ? compare : shallowEqual;

          if (compare(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        workInProgress.effectTag |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps, renderExpirationTime);
        newChild.ref = workInProgress.ref;
        newChild.return = workInProgress;
        workInProgress.child = newChild;
        return newChild;
      }

      function updateSimpleMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerMemoType = workInProgress.elementType;

            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
              outerMemoType = refineResolvedLazyComponent(outerMemoType);
            }

            var outerPropTypes = outerMemoType && outerMemoType.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, nextProps, "prop", getComponentName(outerMemoType), getCurrentFiberStackInDev);
            }
          }
        }

        if (current$$1 !== null) {
          var prevProps = current$$1.memoizedProps;

          if (shallowEqual(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            didReceiveUpdate = false;

            if (updateExpirationTime < renderExpirationTime) {
              return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            }
          }
        }

        return updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
      }

      function updateFragment(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMode(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
        if (enableProfilerTimer) {
          workInProgress.effectTag |= Update;
        }

        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function markRef(current$$1, workInProgress) {
        var ref = workInProgress.ref;

        if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {
          workInProgress.effectTag |= Ref;
        }
      }

      function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
            }
          }
        }
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = renderWithHooks(current$$1, workInProgress, Component, nextProps, context, renderExpirationTime);

          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            if (workInProgress.memoizedState !== null) {
              nextChildren = renderWithHooks(current$$1, workInProgress, Component, nextProps, context, renderExpirationTime);
            }
          }

          setCurrentPhase(null);
        }

        if (current$$1 !== null && !didReceiveUpdate) {
          bailoutHooks(current$$1, workInProgress, renderExpirationTime);
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;

            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
            }
          }
        }
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        var instance = workInProgress.stateNode;
        var shouldUpdate = void 0;

        if (instance === null) {
          if (current$$1 !== null) {
            current$$1.alternate = null;
            workInProgress.alternate = null;
            workInProgress.effectTag |= Placement;
          }

          constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          shouldUpdate = true;
        } else if (current$$1 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        } else {
          shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
        }

        var nextUnitOfWork = finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
        {
          var inst = workInProgress.stateNode;

          if (inst.props !== nextProps) {
            !didWarnAboutReassigningProps ? warning$1(false, "It looks like %s is reassigning its own `this.props` while rendering. " + "This is not supported and can lead to confusing bugs.", getComponentName(workInProgress.type) || "a component") : void 0;
            didWarnAboutReassigningProps = true;
          }
        }
        return nextUnitOfWork;
      }

      function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
        markRef(current$$1, workInProgress);
        var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress, Component, false);
          }

          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var instance = workInProgress.stateNode;
        ReactCurrentOwner$3.current = workInProgress;
        var nextChildren = void 0;

        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;

          if (enableProfilerTimer) {
            stopProfilerTimerIfRunning(workInProgress);
          }
        } else {
          {
            setCurrentPhase("render");
            nextChildren = instance.render();

            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              instance.render();
            }

            setCurrentPhase(null);
          }
        }

        workInProgress.effectTag |= PerformedWork;

        if (current$$1 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        workInProgress.memoizedState = instance.state;

        if (hasContext) {
          invalidateContextProvider(workInProgress, Component, true);
        }

        return workInProgress.child;
      }

      function pushHostRootContext(workInProgress) {
        var root = workInProgress.stateNode;

        if (root.pendingContext) {
          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
        } else if (root.context) {
          pushTopLevelContextObject(workInProgress, root.context, false);
        }

        pushHostContainer(workInProgress, root.containerInfo);
      }

      function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
        pushHostRootContext(workInProgress);
        var updateQueue = workInProgress.updateQueue;
        invariant(updateQueue !== null, "If the root does not have an updateQueue, we should have already " + "bailed out. This error is likely caused by a bug in React. Please " + "file an issue.");
        var nextProps = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        var prevChildren = prevState !== null ? prevState.element : null;
        processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
        var nextState = workInProgress.memoizedState;
        var nextChildren = nextState.element;

        if (nextChildren === prevChildren) {
          resetHydrationState();
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var root = workInProgress.stateNode;

        if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
          workInProgress.effectTag |= Placement;
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
          resetHydrationState();
        }

        return workInProgress.child;
      }

      function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContext(workInProgress);

        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        var type = workInProgress.type;
        var nextProps = workInProgress.pendingProps;
        var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);

        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress.effectTag |= ContentReset;
        }

        markRef(current$$1, workInProgress);

        if (renderExpirationTime !== Never && workInProgress.mode & ConcurrentMode && shouldDeprioritizeSubtree(type, nextProps)) {
          workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
          return null;
        }

        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateHostText(current$$1, workInProgress) {
        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        return null;
      }

      function mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        cancelWorkTimer(workInProgress);
        var Component = readLazyComponentType(elementType);
        workInProgress.type = Component;
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
        startWorkTimer(workInProgress);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child = void 0;

        switch (resolvedTag) {
          case FunctionComponent:
            {
              {
                validateFunctionComponentInDev(workInProgress, Component);
              }
              child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ClassComponent:
            {
              child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ForwardRef:
            {
              child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case MemoComponent:
            {
              {
                if (workInProgress.type !== workInProgress.elementType) {
                  var outerPropTypes = Component.propTypes;

                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, resolvedProps, "prop", getComponentName(Component), getCurrentFiberStackInDev);
                  }
                }
              }
              child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), updateExpirationTime, renderExpirationTime);
              break;
            }

          default:
            {
              var hint = "";
              {
                if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
                  hint = " Did you wrap a component in React.lazy() more than once?";
                }
              }
              invariant(false, "Element type is invalid. Received a promise that resolves to: %s. " + "Lazy element type must resolve to a class or function.%s", Component, hint);
            }
        }

        return child;
      }

      function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        workInProgress.tag = ClassComponent;
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
      }

      function mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        prepareToReadContext(workInProgress, renderExpirationTime);
        var value = void 0;
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentName(Component) || "Unknown";

            if (!didWarnAboutBadClass[componentName]) {
              warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
          }

          ReactCurrentOwner$3.current = workInProgress;
          value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);
        }
        workInProgress.effectTag |= PerformedWork;

        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          workInProgress.tag = ClassComponent;
          resetHooks();
          var hasContext = false;

          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
          } else {
            hasContext = false;
          }

          workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;

          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
          }

          adoptClassInstance(workInProgress, value);
          mountClassInstance(workInProgress, Component, props, renderExpirationTime);
          return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
        } else {
          workInProgress.tag = FunctionComponent;
          {
            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              if (workInProgress.memoizedState !== null) {
                value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);
              }
            }
          }
          reconcileChildren(null, workInProgress, value, renderExpirationTime);
          {
            validateFunctionComponentInDev(workInProgress, Component);
          }
          return workInProgress.child;
        }
      }

      function validateFunctionComponentInDev(workInProgress, Component) {
        if (Component) {
          !!Component.childContextTypes ? warningWithoutStack$1(false, "%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component") : void 0;
        }

        if (workInProgress.ref !== null) {
          var info = "";
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();

          if (ownerName) {
            info += "\n\nCheck the render method of `" + ownerName + "`.";
          }

          var warningKey = ownerName || workInProgress._debugID || "";
          var debugSource = workInProgress._debugSource;

          if (debugSource) {
            warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
          }

          if (!didWarnAboutFunctionRefs[warningKey]) {
            didWarnAboutFunctionRefs[warningKey] = true;
            warning$1(false, "Function components cannot be given refs. " + "Attempts to access this ref will fail. " + "Did you mean to use React.forwardRef()?%s", info);
          }
        }

        if (typeof Component.getDerivedStateFromProps === "function") {
          var componentName = getComponentName(Component) || "Unknown";

          if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {
            warningWithoutStack$1(false, "%s: Function components do not support getDerivedStateFromProps.", componentName);
            didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;
          }
        }

        if (typeof Component.contextType === "object" && Component.contextType !== null) {
          var _componentName = getComponentName(Component) || "Unknown";

          if (!didWarnAboutContextTypeOnFunctionComponent[_componentName]) {
            warningWithoutStack$1(false, "%s: Function components do not support contextType.", _componentName);
            didWarnAboutContextTypeOnFunctionComponent[_componentName] = true;
          }
        }
      }

      function updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
        var mode = workInProgress.mode;
        var nextProps = workInProgress.pendingProps;
        var nextState = workInProgress.memoizedState;
        var nextDidTimeout = void 0;

        if ((workInProgress.effectTag & DidCapture) === NoEffect) {
          nextState = null;
          nextDidTimeout = false;
        } else {
          nextState = {
            timedOutAt: nextState !== null ? nextState.timedOutAt : NoWork
          };
          nextDidTimeout = true;
          workInProgress.effectTag &= ~DidCapture;
        }

        var child = void 0;
        var next = void 0;

        if (current$$1 === null) {
          if (enableSuspenseServerRenderer) {
            if (nextProps.fallback !== undefined) {
              tryToClaimNextHydratableInstance(workInProgress);

              if (workInProgress.tag === DehydratedSuspenseComponent) {
                return updateDehydratedSuspenseComponent(null, workInProgress, renderExpirationTime);
              }
            }
          }

          if (nextDidTimeout) {
            var nextFallbackChildren = nextProps.fallback;
            var primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);

            if ((workInProgress.mode & ConcurrentMode) === NoContext) {
              var progressedState = workInProgress.memoizedState;
              var progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;
              primaryChildFragment.child = progressedPrimaryChild;
            }

            var fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);
            primaryChildFragment.sibling = fallbackChildFragment;
            child = primaryChildFragment;
            next = fallbackChildFragment;
            child.return = next.return = workInProgress;
          } else {
            var nextPrimaryChildren = nextProps.children;
            child = next = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime);
          }
        } else {
          var prevState = current$$1.memoizedState;
          var prevDidTimeout = prevState !== null;

          if (prevDidTimeout) {
            var currentPrimaryChildFragment = current$$1.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;

            if (nextDidTimeout) {
              var _nextFallbackChildren = nextProps.fallback;

              var _primaryChildFragment = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps, NoWork);

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState = workInProgress.memoizedState;

                var _progressedPrimaryChild = _progressedState !== null ? workInProgress.child.child : workInProgress.child;

                if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
                  _primaryChildFragment.child = _progressedPrimaryChild;
                }
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var treeBaseDuration = 0;
                var hiddenChild = _primaryChildFragment.child;

                while (hiddenChild !== null) {
                  treeBaseDuration += hiddenChild.treeBaseDuration;
                  hiddenChild = hiddenChild.sibling;
                }

                _primaryChildFragment.treeBaseDuration = treeBaseDuration;
              }

              var _fallbackChildFragment = _primaryChildFragment.sibling = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren, currentFallbackChildFragment.expirationTime);

              child = _primaryChildFragment;
              _primaryChildFragment.childExpirationTime = NoWork;
              next = _fallbackChildFragment;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren = nextProps.children;
              var currentPrimaryChild = currentPrimaryChildFragment.child;
              var primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime);
              child = next = primaryChild;
            }
          } else {
            var _currentPrimaryChild = current$$1.child;

            if (nextDidTimeout) {
              var _nextFallbackChildren2 = nextProps.fallback;

              var _primaryChildFragment2 = createFiberFromFragment(null, mode, NoWork, null);

              _primaryChildFragment2.child = _currentPrimaryChild;

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState2 = workInProgress.memoizedState;

                var _progressedPrimaryChild2 = _progressedState2 !== null ? workInProgress.child.child : workInProgress.child;

                _primaryChildFragment2.child = _progressedPrimaryChild2;
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var _treeBaseDuration = 0;
                var _hiddenChild = _primaryChildFragment2.child;

                while (_hiddenChild !== null) {
                  _treeBaseDuration += _hiddenChild.treeBaseDuration;
                  _hiddenChild = _hiddenChild.sibling;
                }

                _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
              }

              var _fallbackChildFragment2 = _primaryChildFragment2.sibling = createFiberFromFragment(_nextFallbackChildren2, mode, renderExpirationTime, null);

              _fallbackChildFragment2.effectTag |= Placement;
              child = _primaryChildFragment2;
              _primaryChildFragment2.childExpirationTime = NoWork;
              next = _fallbackChildFragment2;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              next = child = reconcileChildFibers(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);
            }
          }

          workInProgress.stateNode = current$$1.stateNode;
        }

        workInProgress.memoizedState = nextState;
        workInProgress.child = child;
        return next;
      }

      function updateDehydratedSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
        if (current$$1 === null) {
          workInProgress.expirationTime = Never;
          return null;
        }

        if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
          workInProgress.child = null;
          return null;
        }

        var hasContextChanged$$1 = current$$1.childExpirationTime >= renderExpirationTime;
        var suspenseInstance = current$$1.stateNode;

        if (didReceiveUpdate || hasContextChanged$$1 || isSuspenseInstanceFallback(suspenseInstance)) {
          current$$1.alternate = null;
          workInProgress.alternate = null;
          var returnFiber = workInProgress.return;
          invariant(returnFiber !== null, "Suspense boundaries are never on the root. " + "This is probably a bug in React.");
          var last = returnFiber.lastEffect;

          if (last !== null) {
            last.nextEffect = current$$1;
            returnFiber.lastEffect = current$$1;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = current$$1;
          }

          current$$1.nextEffect = null;
          current$$1.effectTag = Deletion;
          workInProgress.tag = SuspenseComponent;
          workInProgress.stateNode = null;
          workInProgress.memoizedState = null;
          workInProgress.effectTag |= Placement;
          return updateSuspenseComponent(null, workInProgress, renderExpirationTime);
        } else if (isSuspenseInstancePending(suspenseInstance)) {
          workInProgress.effectTag |= DidCapture;
          workInProgress.child = null;
          registerSuspenseInstanceRetry(suspenseInstance, retryTimedOutBoundary.bind(null, current$$1));
          return null;
        } else {
          reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress);
          var nextProps = workInProgress.pendingProps;
          var nextChildren = nextProps.children;
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
          return workInProgress.child;
        }
      }

      function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        var nextChildren = workInProgress.pendingProps;

        if (current$$1 === null) {
          workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        return workInProgress.child;
      }

      function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {
        var providerType = workInProgress.type;
        var context = providerType._context;
        var newProps = workInProgress.pendingProps;
        var oldProps = workInProgress.memoizedProps;
        var newValue = newProps.value;
        {
          var providerPropTypes = workInProgress.type.propTypes;

          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider", getCurrentFiberStackInDev);
          }
        }
        pushProvider(workInProgress, newValue);

        if (oldProps !== null) {
          var oldValue = oldProps.value;
          var changedBits = calculateChangedBits(context, newValue, oldValue);

          if (changedBits === 0) {
            if (oldProps.children === newProps.children && !hasContextChanged()) {
              return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            }
          } else {
            propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
          }
        }

        var newChildren = newProps.children;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      var hasWarnedAboutUsingContextAsConsumer = false;

      function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {
        var context = workInProgress.type;
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                warning$1(false, "Rendering <Context> directly is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress.pendingProps;
        var render = newProps.children;
        {
          !(typeof render === "function") ? warningWithoutStack$1(false, "A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.") : void 0;
        }
        prepareToReadContext(workInProgress, renderExpirationTime);

        var newValue = _readContext(context, newProps.unstable_observedBits);

        var newChildren = void 0;
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          newChildren = render(newValue);
          setCurrentPhase(null);
        }
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
      }

      function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
        cancelWorkTimer(workInProgress);

        if (current$$1 !== null) {
          workInProgress.contextDependencies = current$$1.contextDependencies;
        }

        if (enableProfilerTimer) {
          stopProfilerTimerIfRunning(workInProgress);
        }

        var childExpirationTime = workInProgress.childExpirationTime;

        if (childExpirationTime < renderExpirationTime) {
          return null;
        } else {
          cloneChildFibers(current$$1, workInProgress);
          return workInProgress.child;
        }
      }

      function beginWork(current$$1, workInProgress, renderExpirationTime) {
        var updateExpirationTime = workInProgress.expirationTime;

        if (current$$1 !== null) {
          var oldProps = current$$1.memoizedProps;
          var newProps = workInProgress.pendingProps;

          if (oldProps !== newProps || hasContextChanged()) {
            didReceiveUpdate = true;
          } else if (updateExpirationTime < renderExpirationTime) {
            didReceiveUpdate = false;

            switch (workInProgress.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress);
                resetHydrationState();
                break;

              case HostComponent:
                pushHostContext(workInProgress);
                break;

              case ClassComponent:
                {
                  var Component = workInProgress.type;

                  if (isContextProvider(Component)) {
                    pushContextProvider(workInProgress);
                  }

                  break;
                }

              case HostPortal:
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                break;

              case ContextProvider:
                {
                  var newValue = workInProgress.memoizedProps.value;
                  pushProvider(workInProgress, newValue);
                  break;
                }

              case Profiler:
                if (enableProfilerTimer) {
                  workInProgress.effectTag |= Update;
                }

                break;

              case SuspenseComponent:
                {
                  var state = workInProgress.memoizedState;
                  var didTimeout = state !== null;

                  if (didTimeout) {
                    var primaryChildFragment = workInProgress.child;
                    var primaryChildExpirationTime = primaryChildFragment.childExpirationTime;

                    if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime) {
                      return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
                    } else {
                      var child = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);

                      if (child !== null) {
                        return child.sibling;
                      } else {
                        return null;
                      }
                    }
                  }

                  break;
                }

              case DehydratedSuspenseComponent:
                {
                  if (enableSuspenseServerRenderer) {
                    workInProgress.effectTag |= DidCapture;
                    break;
                  }
                }
            }

            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        } else {
          didReceiveUpdate = false;
        }

        workInProgress.expirationTime = NoWork;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            {
              var elementType = workInProgress.elementType;
              return mountIndeterminateComponent(current$$1, workInProgress, elementType, renderExpirationTime);
            }

          case LazyComponent:
            {
              var _elementType = workInProgress.elementType;
              return mountLazyComponent(current$$1, workInProgress, _elementType, updateExpirationTime, renderExpirationTime);
            }

          case FunctionComponent:
            {
              var _Component = workInProgress.type;
              var unresolvedProps = workInProgress.pendingProps;
              var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
              return updateFunctionComponent(current$$1, workInProgress, _Component, resolvedProps, renderExpirationTime);
            }

          case ClassComponent:
            {
              var _Component2 = workInProgress.type;
              var _unresolvedProps = workInProgress.pendingProps;

              var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

              return updateClassComponent(current$$1, workInProgress, _Component2, _resolvedProps, renderExpirationTime);
            }

          case HostRoot:
            return updateHostRoot(current$$1, workInProgress, renderExpirationTime);

          case HostComponent:
            return updateHostComponent(current$$1, workInProgress, renderExpirationTime);

          case HostText:
            return updateHostText(current$$1, workInProgress);

          case SuspenseComponent:
            return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);

          case HostPortal:
            return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);

          case ForwardRef:
            {
              var type = workInProgress.type;
              var _unresolvedProps2 = workInProgress.pendingProps;

              var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

              return updateForwardRef(current$$1, workInProgress, type, _resolvedProps2, renderExpirationTime);
            }

          case Fragment:
            return updateFragment(current$$1, workInProgress, renderExpirationTime);

          case Mode:
            return updateMode(current$$1, workInProgress, renderExpirationTime);

          case Profiler:
            return updateProfiler(current$$1, workInProgress, renderExpirationTime);

          case ContextProvider:
            return updateContextProvider(current$$1, workInProgress, renderExpirationTime);

          case ContextConsumer:
            return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);

          case MemoComponent:
            {
              var _type2 = workInProgress.type;
              var _unresolvedProps3 = workInProgress.pendingProps;

              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);

              {
                if (workInProgress.type !== workInProgress.elementType) {
                  var outerPropTypes = _type2.propTypes;

                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, _resolvedProps3, "prop", getComponentName(_type2), getCurrentFiberStackInDev);
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current$$1, workInProgress, _type2, _resolvedProps3, updateExpirationTime, renderExpirationTime);
            }

          case SimpleMemoComponent:
            {
              return updateSimpleMemoComponent(current$$1, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
            }

          case IncompleteClassComponent:
            {
              var _Component3 = workInProgress.type;
              var _unresolvedProps4 = workInProgress.pendingProps;

              var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

              return mountIncompleteClassComponent(current$$1, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);
            }

          case DehydratedSuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                return updateDehydratedSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
              }

              break;
            }
        }

        invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
      }

      var valueCursor = createCursor(null);
      var rendererSigil = void 0;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastContextWithAllBitsObserved = null;
      var isDisallowedContextReadInDEV = false;

      function resetContextDependences() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        {
          isDisallowedContextReadInDEV = false;
        }
      }

      function enterDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = true;
        }
      }

      function exitDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = false;
        }
      }

      function pushProvider(providerFiber, nextValue) {
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer = rendererSigil;
          }
        } else {
          push(valueCursor, context._currentValue2, providerFiber);
          context._currentValue2 = nextValue;
          {
            !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer2 = rendererSigil;
          }
        }
      }

      function popProvider(providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          context._currentValue = currentValue;
        } else {
          context._currentValue2 = currentValue;
        }
      }

      function calculateChangedBits(context, newValue, oldValue) {
        if (is(oldValue, newValue)) {
          return 0;
        } else {
          var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;
          {
            !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, "calculateChangedBits: Expected the return value to be a " + "31-bit integer. Instead received: %s", changedBits) : void 0;
          }
          return changedBits | 0;
        }
      }

      function scheduleWorkOnParentPath(parent, renderExpirationTime) {
        var node = parent;

        while (node !== null) {
          var alternate = node.alternate;

          if (node.childExpirationTime < renderExpirationTime) {
            node.childExpirationTime = renderExpirationTime;

            if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
              alternate.childExpirationTime = renderExpirationTime;
            }
          } else if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
            alternate.childExpirationTime = renderExpirationTime;
          } else {
            break;
          }

          node = node.return;
        }
      }

      function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
        var fiber = workInProgress.child;

        if (fiber !== null) {
          fiber.return = workInProgress;
        }

        while (fiber !== null) {
          var nextFiber = void 0;
          var list = fiber.contextDependencies;

          if (list !== null) {
            nextFiber = fiber.child;
            var dependency = list.first;

            while (dependency !== null) {
              if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                if (fiber.tag === ClassComponent) {
                  var update = createUpdate(renderExpirationTime);
                  update.tag = ForceUpdate;
                  enqueueUpdate(fiber, update);
                }

                if (fiber.expirationTime < renderExpirationTime) {
                  fiber.expirationTime = renderExpirationTime;
                }

                var alternate = fiber.alternate;

                if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
                  alternate.expirationTime = renderExpirationTime;
                }

                scheduleWorkOnParentPath(fiber.return, renderExpirationTime);

                if (list.expirationTime < renderExpirationTime) {
                  list.expirationTime = renderExpirationTime;
                }

                break;
              }

              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
          } else if (enableSuspenseServerRenderer && fiber.tag === DehydratedSuspenseComponent) {
            if (fiber.expirationTime < renderExpirationTime) {
              fiber.expirationTime = renderExpirationTime;
            }

            var _alternate = fiber.alternate;

            if (_alternate !== null && _alternate.expirationTime < renderExpirationTime) {
              _alternate.expirationTime = renderExpirationTime;
            }

            scheduleWorkOnParentPath(fiber, renderExpirationTime);
            nextFiber = fiber.sibling;
          } else {
            nextFiber = fiber.child;
          }

          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;

            while (nextFiber !== null) {
              if (nextFiber === workInProgress) {
                nextFiber = null;
                break;
              }

              var sibling = nextFiber.sibling;

              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }

              nextFiber = nextFiber.return;
            }
          }

          fiber = nextFiber;
        }
      }

      function prepareToReadContext(workInProgress, renderExpirationTime) {
        currentlyRenderingFiber = workInProgress;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        var currentDependencies = workInProgress.contextDependencies;

        if (currentDependencies !== null && currentDependencies.expirationTime >= renderExpirationTime) {
          markWorkInProgressReceivedUpdate();
        }

        workInProgress.contextDependencies = null;
      }

      function _readContext(context, observedBits) {
        {
          !!isDisallowedContextReadInDEV ? warning$1(false, "Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().") : void 0;
        }

        if (lastContextWithAllBitsObserved === context) {} else if (observedBits === false || observedBits === 0) {} else {
          var resolvedObservedBits = void 0;

          if (typeof observedBits !== "number" || observedBits === maxSigned31BitInt) {
            lastContextWithAllBitsObserved = context;
            resolvedObservedBits = maxSigned31BitInt;
          } else {
            resolvedObservedBits = observedBits;
          }

          var contextItem = {
            context: context,
            observedBits: resolvedObservedBits,
            next: null
          };

          if (lastContextDependency === null) {
            invariant(currentlyRenderingFiber !== null, "Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
            lastContextDependency = contextItem;
            currentlyRenderingFiber.contextDependencies = {
              first: contextItem,
              expirationTime: NoWork
            };
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }

        return isPrimaryRenderer ? context._currentValue : context._currentValue2;
      }

      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate = void 0;
      var currentlyProcessingQueue = void 0;
      var resetCurrentlyProcessingQueue = void 0;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;

        resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {
          currentlyProcessingQueue = null;
        };
      }

      function createUpdateQueue(baseState) {
        var queue = {
          baseState: baseState,
          firstUpdate: null,
          lastUpdate: null,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function cloneUpdateQueue(currentQueue) {
        var queue = {
          baseState: currentQueue.baseState,
          firstUpdate: currentQueue.firstUpdate,
          lastUpdate: currentQueue.lastUpdate,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function createUpdate(expirationTime) {
        return {
          expirationTime: expirationTime,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null,
          nextEffect: null
        };
      }

      function appendUpdateToQueue(queue, update) {
        if (queue.lastUpdate === null) {
          queue.firstUpdate = queue.lastUpdate = update;
        } else {
          queue.lastUpdate.next = update;
          queue.lastUpdate = update;
        }
      }

      function enqueueUpdate(fiber, update) {
        var alternate = fiber.alternate;
        var queue1 = void 0;
        var queue2 = void 0;

        if (alternate === null) {
          queue1 = fiber.updateQueue;
          queue2 = null;

          if (queue1 === null) {
            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
          }
        } else {
          queue1 = fiber.updateQueue;
          queue2 = alternate.updateQueue;

          if (queue1 === null) {
            if (queue2 === null) {
              queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
              queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
            } else {
              queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
            }
          } else {
            if (queue2 === null) {
              queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
            } else {}
          }
        }

        if (queue2 === null || queue1 === queue2) {
          appendUpdateToQueue(queue1, update);
        } else {
          if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
            appendUpdateToQueue(queue1, update);
            appendUpdateToQueue(queue2, update);
          } else {
            appendUpdateToQueue(queue1, update);
            queue2.lastUpdate = update;
          }
        }

        {
          if (fiber.tag === ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
            warningWithoutStack$1(false, "An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
      }

      function enqueueCapturedUpdate(workInProgress, update) {
        var workInProgressQueue = workInProgress.updateQueue;

        if (workInProgressQueue === null) {
          workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
        } else {
          workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
        }

        if (workInProgressQueue.lastCapturedUpdate === null) {
          workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
        } else {
          workInProgressQueue.lastCapturedUpdate.next = update;
          workInProgressQueue.lastCapturedUpdate = update;
        }
      }

      function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
        var current = workInProgress.alternate;

        if (current !== null) {
          if (queue === current.updateQueue) {
            queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
          }
        }

        return queue;
      }

      function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState:
            {
              var _payload = update.payload;

              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();

                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload.call(instance, prevState, nextProps);
                  }
                }

                var nextState = _payload.call(instance, prevState, nextProps);

                {
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }

              return _payload;
            }

          case CaptureUpdate:
            {
              workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;
            }

          case UpdateState:
            {
              var _payload2 = update.payload;
              var partialState = void 0;

              if (typeof _payload2 === "function") {
                {
                  enterDisallowedContextReadInDEV();

                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload2.call(instance, prevState, nextProps);
                  }
                }
                partialState = _payload2.call(instance, prevState, nextProps);
                {
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload2;
              }

              if (partialState === null || partialState === undefined) {
                return prevState;
              }

              return _extends({}, prevState, partialState);
            }

          case ForceUpdate:
            {
              hasForceUpdate = true;
              return prevState;
            }
        }

        return prevState;
      }

      function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
        hasForceUpdate = false;
        queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);
        {
          currentlyProcessingQueue = queue;
        }
        var newBaseState = queue.baseState;
        var newFirstUpdate = null;
        var newExpirationTime = NoWork;
        var update = queue.firstUpdate;
        var resultState = newBaseState;

        while (update !== null) {
          var updateExpirationTime = update.expirationTime;

          if (updateExpirationTime < renderExpirationTime) {
            if (newFirstUpdate === null) {
              newFirstUpdate = update;
              newBaseState = resultState;
            }

            if (newExpirationTime < updateExpirationTime) {
              newExpirationTime = updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback = update.callback;

            if (_callback !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastEffect === null) {
                queue.firstEffect = queue.lastEffect = update;
              } else {
                queue.lastEffect.nextEffect = update;
                queue.lastEffect = update;
              }
            }
          }

          update = update.next;
        }

        var newFirstCapturedUpdate = null;
        update = queue.firstCapturedUpdate;

        while (update !== null) {
          var _updateExpirationTime = update.expirationTime;

          if (_updateExpirationTime < renderExpirationTime) {
            if (newFirstCapturedUpdate === null) {
              newFirstCapturedUpdate = update;

              if (newFirstUpdate === null) {
                newBaseState = resultState;
              }
            }

            if (newExpirationTime < _updateExpirationTime) {
              newExpirationTime = _updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback2 = update.callback;

            if (_callback2 !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastCapturedEffect === null) {
                queue.firstCapturedEffect = queue.lastCapturedEffect = update;
              } else {
                queue.lastCapturedEffect.nextEffect = update;
                queue.lastCapturedEffect = update;
              }
            }
          }

          update = update.next;
        }

        if (newFirstUpdate === null) {
          queue.lastUpdate = null;
        }

        if (newFirstCapturedUpdate === null) {
          queue.lastCapturedUpdate = null;
        } else {
          workInProgress.effectTag |= Callback;
        }

        if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
          newBaseState = resultState;
        }

        queue.baseState = newBaseState;
        queue.firstUpdate = newFirstUpdate;
        queue.firstCapturedUpdate = newFirstCapturedUpdate;
        workInProgress.expirationTime = newExpirationTime;
        workInProgress.memoizedState = resultState;
        {
          currentlyProcessingQueue = null;
        }
      }

      function callCallback(callback, context) {
        invariant(typeof callback === "function", "Invalid argument passed as callback. Expected a function. Instead " + "received: %s", callback);
        callback.call(context);
      }

      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }

      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }

      function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
        if (finishedQueue.firstCapturedUpdate !== null) {
          if (finishedQueue.lastUpdate !== null) {
            finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
            finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
          }

          finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
        }

        commitUpdateEffects(finishedQueue.firstEffect, instance);
        finishedQueue.firstEffect = finishedQueue.lastEffect = null;
        commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
        finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
      }

      function commitUpdateEffects(effect, instance) {
        while (effect !== null) {
          var _callback3 = effect.callback;

          if (_callback3 !== null) {
            effect.callback = null;
            callCallback(_callback3, instance);
          }

          effect = effect.nextEffect;
        }
      }

      function createCapturedValue(value, source) {
        return {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }

      function markUpdate(workInProgress) {
        workInProgress.effectTag |= Update;
      }

      function markRef$1(workInProgress) {
        workInProgress.effectTag |= Ref;
      }

      var _appendAllChildren = void 0;

      var updateHostContainer = void 0;
      var updateHostComponent$1 = void 0;
      var updateHostText$1 = void 0;

      if (supportsMutation) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal) {} else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var oldProps = current.memoizedProps;

          if (oldProps === newProps) {
            return;
          }

          var instance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress.updateQueue = updatePayload;

          if (updatePayload) {
            markUpdate(workInProgress);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress);
          }
        };
      } else if (supportsPersistence) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendInitialChild(parent, instance);
            } else if (node.tag === HostText) {
              var _instance = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance;
              }

              appendInitialChild(parent, _instance);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    _appendAllChildren(parent, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendChildToContainerChildSet(containerChildSet, instance);
            } else if (node.tag === HostText) {
              var _instance2 = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance2 = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance2 = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance2;
              }

              appendChildToContainerChildSet(containerChildSet, _instance2);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {
          var portalOrRoot = workInProgress.stateNode;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged) {} else {
            var container = portalOrRoot.containerInfo;
            var newChildSet = createContainerChildSet(container);
            appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
            portalOrRoot.pendingChildren = newChildSet;
            markUpdate(workInProgress);
            finalizeContainerChildren(container, newChildSet);
          }
        };

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var currentInstance = current.stateNode;
          var oldProps = current.memoizedProps;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged && oldProps === newProps) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var recyclableInstance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = null;

          if (oldProps !== newProps) {
            updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          }

          if (childrenUnchanged && updatePayload === null) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);

          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
            markUpdate(workInProgress);
          }

          workInProgress.stateNode = newInstance;

          if (childrenUnchanged) {
            markUpdate(workInProgress);
          } else {
            _appendAllChildren(newInstance, workInProgress, false, false);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            var rootContainerInstance = getRootHostContainer();
            var currentHostContext = getHostContext();
            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
            markUpdate(workInProgress);
          }
        };
      } else {
        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {};

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {};
      }

      function completeWork(current, workInProgress, renderExpirationTime) {
        var newProps = workInProgress.pendingProps;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            break;

          case LazyComponent:
            break;

          case SimpleMemoComponent:
          case FunctionComponent:
            break;

          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var fiberRoot = workInProgress.stateNode;

              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }

              if (current === null || current.child === null) {
                popHydrationState(workInProgress);
                workInProgress.effectTag &= ~Placement;
              }

              updateHostContainer(workInProgress);
              break;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress.type;

              if (current !== null && workInProgress.stateNode != null) {
                updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

                if (current.ref !== workInProgress.ref) {
                  markRef$1(workInProgress);
                }
              } else {
                if (!newProps) {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                  break;
                }

                var currentHostContext = getHostContext();
                var wasHydrated = popHydrationState(workInProgress);

                if (wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);

                  _appendAllChildren(instance, workInProgress, false, false);

                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }

                  workInProgress.stateNode = instance;
                }

                if (workInProgress.ref !== null) {
                  markRef$1(workInProgress);
                }
              }

              break;
            }

          case HostText:
            {
              var newText = newProps;

              if (current && workInProgress.stateNode != null) {
                var oldText = current.memoizedProps;
                updateHostText$1(current, workInProgress, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                }

                var _rootContainerInstance = getRootHostContainer();

                var _currentHostContext = getHostContext();

                var _wasHydrated = popHydrationState(workInProgress);

                if (_wasHydrated) {
                  if (prepareToHydrateHostTextInstance(workInProgress)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                }
              }

              break;
            }

          case ForwardRef:
            break;

          case SuspenseComponent:
            {
              var nextState = workInProgress.memoizedState;

              if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
                workInProgress.expirationTime = renderExpirationTime;
                return workInProgress;
              }

              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current !== null && current.memoizedState !== null;

              if (current === null) {
                popHydrationState(workInProgress);
              } else if (!nextDidTimeout && prevDidTimeout) {
                var currentFallbackChild = current.child.sibling;

                if (currentFallbackChild !== null) {
                  var first = workInProgress.firstEffect;

                  if (first !== null) {
                    workInProgress.firstEffect = currentFallbackChild;
                    currentFallbackChild.nextEffect = first;
                  } else {
                    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
                    currentFallbackChild.nextEffect = null;
                  }

                  currentFallbackChild.effectTag = Deletion;
                }
              }

              if (nextDidTimeout || prevDidTimeout) {
                workInProgress.effectTag |= Update;
              }

              break;
            }

          case Fragment:
            break;

          case Mode:
            break;

          case Profiler:
            break;

          case HostPortal:
            popHostContainer(workInProgress);
            updateHostContainer(workInProgress);
            break;

          case ContextProvider:
            popProvider(workInProgress);
            break;

          case ContextConsumer:
            break;

          case MemoComponent:
            break;

          case IncompleteClassComponent:
            {
              var _Component = workInProgress.type;

              if (isContextProvider(_Component)) {
                popContext(workInProgress);
              }

              break;
            }

          case DehydratedSuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                if (current === null) {
                  var _wasHydrated2 = popHydrationState(workInProgress);

                  invariant(_wasHydrated2, "A dehydrated suspense component was completed without a hydrated node. " + "This is probably a bug in React.");
                  skipPastDehydratedSuspenseInstance(workInProgress);
                } else if ((workInProgress.effectTag & DidCapture) === NoEffect) {
                  current.alternate = null;
                  workInProgress.alternate = null;
                  workInProgress.tag = SuspenseComponent;
                  workInProgress.memoizedState = null;
                  workInProgress.stateNode = null;
                }
              }

              break;
            }

          default:
            invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
        }

        return null;
      }

      function shouldCaptureSuspense(workInProgress) {
        if (workInProgress.memoizedProps.fallback === undefined) {
          return false;
        }

        var nextState = workInProgress.memoizedState;
        return nextState === null;
      }

      function showErrorDialog(capturedError) {
        var componentStack = capturedError.componentStack,
            error = capturedError.error;
        var errorToHandle = void 0;

        if (error instanceof Error) {
          var message = error.message,
              name = error.name;
          var summary = message ? name + ": " + message : name;
          errorToHandle = error;

          try {
            errorToHandle.message = summary + "\n\nThis error is located at:" + componentStack;
          } catch (e) {}
        } else if (typeof error === "string") {
          errorToHandle = new Error(error + "\n\nThis error is located at:" + componentStack);
        } else {
          errorToHandle = new Error("Unspecified error at:" + componentStack);
        }

        ExceptionsManager.handleException(errorToHandle, false);
        return false;
      }

      function logCapturedError(capturedError) {
        var logError = showErrorDialog(capturedError);

        if (logError === false) {
          return;
        }

        var error = capturedError.error;
        {
          var componentName = capturedError.componentName,
              componentStack = capturedError.componentStack,
              errorBoundaryName = capturedError.errorBoundaryName,
              errorBoundaryFound = capturedError.errorBoundaryFound,
              willRetry = capturedError.willRetry;

          if (error != null && error._suppressLogging) {
            if (errorBoundaryFound && willRetry) {
              return;
            }

            console.error(error);
          }

          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
          var errorBoundaryMessage = void 0;

          if (errorBoundaryFound && errorBoundaryName) {
            if (willRetry) {
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            } else {
              errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\n" + "Recreating the tree from scratch failed so React will unmount the tree.";
            }
          } else {
            errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n" + "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
          }

          var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);
          console.error(combinedMessage);
        }
      }

      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
      }
      var PossiblyWeakSet$1 = typeof WeakSet === "function" ? WeakSet : Set;

      function logError(boundary, errorInfo) {
        var source = errorInfo.source;
        var stack = errorInfo.stack;

        if (stack === null && source !== null) {
          stack = getStackByFiberInDevAndProd(source);
        }

        var capturedError = {
          componentName: source !== null ? getComponentName(source.type) : null,
          componentStack: stack !== null ? stack : "",
          error: errorInfo.value,
          errorBoundary: null,
          errorBoundaryName: null,
          errorBoundaryFound: false,
          willRetry: false
        };

        if (boundary !== null && boundary.tag === ClassComponent) {
          capturedError.errorBoundary = boundary.stateNode;
          capturedError.errorBoundaryName = getComponentName(boundary.type);
          capturedError.errorBoundaryFound = true;
          capturedError.willRetry = true;
        }

        try {
          logCapturedError(capturedError);
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }

      var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current$$1, instance) {
        startPhaseTimer(current$$1, "componentWillUnmount");
        instance.props = current$$1.memoizedProps;
        instance.state = current$$1.memoizedState;
        instance.componentWillUnmount();
        stopPhaseTimer();
      };

      function safelyCallComponentWillUnmount(current$$1, instance) {
        {
          invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);

          if (hasCaughtError()) {
            var unmountError = clearCaughtError();
            captureCommitPhaseError(current$$1, unmountError);
          }
        }
      }

      function safelyDetachRef(current$$1) {
        var ref = current$$1.ref;

        if (ref !== null) {
          if (typeof ref === "function") {
            {
              invokeGuardedCallback(null, ref, null, null);

              if (hasCaughtError()) {
                var refError = clearCaughtError();
                captureCommitPhaseError(current$$1, refError);
              }
            }
          } else {
            ref.current = null;
          }
        }
      }

      function safelyCallDestroy(current$$1, destroy) {
        {
          invokeGuardedCallback(null, destroy, null);

          if (hasCaughtError()) {
            var error = clearCaughtError();
            captureCommitPhaseError(current$$1, error);
          }
        }
      }

      function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
              return;
            }

          case ClassComponent:
            {
              if (finishedWork.effectTag & Snapshot) {
                if (current$$1 !== null) {
                  var prevProps = current$$1.memoizedProps;
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "getSnapshotBeforeUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "getSnapshotBeforeUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      warningWithoutStack$1(false, "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) " + "must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  stopPhaseTimer();
                }
              }

              return;
            }

          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case IncompleteClassComponent:
            return;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitHookEffectList(unmountTag, mountTag, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;

          do {
            if ((effect.tag & unmountTag) !== NoEffect$1) {
              var destroy = effect.destroy;
              effect.destroy = undefined;

              if (destroy !== undefined) {
                destroy();
              }
            }

            if ((effect.tag & mountTag) !== NoEffect$1) {
              var create = effect.create;
              effect.destroy = create();
              {
                var _destroy = effect.destroy;

                if (_destroy !== undefined && typeof _destroy !== "function") {
                  var addendum = void 0;

                  if (_destroy === null) {
                    addendum = " You returned null. If your effect does not require clean " + "up, return undefined (or nothing).";
                  } else if (typeof _destroy.then === "function") {
                    addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. " + "Instead, you may write an async function separately " + "and then call it from inside the effect:\n\n" + "async function fetchComment(commentId) {\n" + "  // You can await here\n" + "}\n\n" + "useEffect(() => {\n" + "  fetchComment(commentId);\n" + "}, [commentId]);\n\n" + "In the future, React will provide a more idiomatic solution for data fetching " + "that doesn't involve writing effects manually.";
                  } else {
                    addendum = " You returned: " + _destroy;
                  }

                  warningWithoutStack$1(false, "An Effect function must not return anything besides a function, " + "which is used for clean-up.%s%s", addendum, getStackByFiberInDevAndProd(finishedWork));
                }
              }
            }

            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }

      function commitPassiveHookEffects(finishedWork) {
        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
      }

      function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
              break;
            }

          case ClassComponent:
            {
              var instance = finishedWork.stateNode;

              if (finishedWork.effectTag & Update) {
                if (current$$1 === null) {
                  startPhaseTimer(finishedWork, "componentDidMount");
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "componentDidMount. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "componentDidMount. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    }
                  }
                  instance.componentDidMount();
                  stopPhaseTimer();
                } else {
                  var prevProps = finishedWork.elementType === finishedWork.type ? current$$1.memoizedProps : resolveDefaultProps(finishedWork.type, current$$1.memoizedProps);
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "componentDidUpdate");
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "componentDidUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "componentDidUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    }
                  }
                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                  stopPhaseTimer();
                }
              }

              var updateQueue = finishedWork.updateQueue;

              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected %s props to match memoized props before " + "processing the update queue. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                    !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected %s state to match memoized state before " + "processing the update queue. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentName(finishedWork.type) || "instance") : void 0;
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);
              }

              return;
            }

          case HostRoot:
            {
              var _updateQueue = finishedWork.updateQueue;

              if (_updateQueue !== null) {
                var _instance = null;

                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;

                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }

                commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);
              }

              return;
            }

          case HostComponent:
            {
              var _instance2 = finishedWork.stateNode;

              if (current$$1 === null && finishedWork.effectTag & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props, finishedWork);
              }

              return;
            }

          case HostText:
            {
              return;
            }

          case HostPortal:
            {
              return;
            }

          case Profiler:
            {
              if (enableProfilerTimer) {
                var onRender = finishedWork.memoizedProps.onRender;

                if (enableSchedulerTracing) {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
                } else {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());
                }
              }

              return;
            }

          case SuspenseComponent:
            break;

          case IncompleteClassComponent:
            break;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        if (supportsMutation) {
          var node = finishedWork;

          while (true) {
            if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (isHidden) {
                hideInstance(instance);
              } else {
                unhideInstance(node.stateNode, node.memoizedProps);
              }
            } else if (node.tag === HostText) {
              var _instance3 = node.stateNode;

              if (isHidden) {
                hideTextInstance(_instance3);
              } else {
                unhideTextInstance(_instance3, node.memoizedProps);
              }
            } else if (node.tag === SuspenseComponent && node.memoizedState !== null) {
              var fallbackChildFragment = node.child.sibling;
              fallbackChildFragment.return = node;
              node = fallbackChildFragment;
              continue;
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === finishedWork) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
      }

      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;

        if (ref !== null) {
          var instance = finishedWork.stateNode;
          var instanceToUse = void 0;

          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;

            default:
              instanceToUse = instance;
          }

          if (typeof ref === "function") {
            ref(instanceToUse);
          } else {
            {
              if (!ref.hasOwnProperty("current")) {
                warningWithoutStack$1(false, "Unexpected ref object provided for %s. " + "Use either a ref-setter function or React.createRef().%s", getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
              }
            }
            ref.current = instanceToUse;
          }
        }
      }

      function commitDetachRef(current$$1) {
        var currentRef = current$$1.ref;

        if (currentRef !== null) {
          if (typeof currentRef === "function") {
            currentRef(null);
          } else {
            currentRef.current = null;
          }
        }
      }

      function commitUnmount(current$$1) {
        onCommitUnmount(current$$1);

        switch (current$$1.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              var updateQueue = current$$1.updateQueue;

              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;

                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;

                  do {
                    var destroy = effect.destroy;

                    if (destroy !== undefined) {
                      safelyCallDestroy(current$$1, destroy);
                    }

                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }

              break;
            }

          case ClassComponent:
            {
              safelyDetachRef(current$$1);
              var instance = current$$1.stateNode;

              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(current$$1, instance);
              }

              return;
            }

          case HostComponent:
            {
              safelyDetachRef(current$$1);
              return;
            }

          case HostPortal:
            {
              if (supportsMutation) {
                unmountHostComponents(current$$1);
              } else if (supportsPersistence) {
                emptyPortalContainer(current$$1);
              }

              return;
            }
        }
      }

      function commitNestedUnmounts(root) {
        var node = root;

        while (true) {
          commitUnmount(node);

          if (node.child !== null && (!supportsMutation || node.tag !== HostPortal)) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === root) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === root) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function detachFiber(current$$1) {
        current$$1.return = null;
        current$$1.child = null;
        current$$1.memoizedState = null;
        current$$1.updateQueue = null;
        var alternate = current$$1.alternate;

        if (alternate !== null) {
          alternate.return = null;
          alternate.child = null;
          alternate.memoizedState = null;
          alternate.updateQueue = null;
        }
      }

      function emptyPortalContainer(current$$1) {
        if (!supportsPersistence) {
          return;
        }

        var portal = current$$1.stateNode;
        var containerInfo = portal.containerInfo;
        var emptyChildSet = createContainerChildSet(containerInfo);
      }

      function commitContainer(finishedWork) {
        if (!supportsPersistence) {
          return;
        }

        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              return;
            }

          case HostText:
            {
              return;
            }

          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function getHostParentFiber(fiber) {
        var parent = fiber.return;

        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }

          parent = parent.return;
        }

        invariant(false, "Expected to find a host parent. This error is likely caused by a bug " + "in React. Please file an issue.");
      }

      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }

      function getHostSibling(fiber) {
        var node = fiber;

        siblings: while (true) {
          while (node.sibling === null) {
            if (node.return === null || isHostParent(node.return)) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;

          while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedSuspenseComponent) {
            if (node.effectTag & Placement) {
              continue siblings;
            }

            if (node.child === null || node.tag === HostPortal) {
              continue siblings;
            } else {
              node.child.return = node;
              node = node.child;
            }
          }

          if (!(node.effectTag & Placement)) {
            return node.stateNode;
          }
        }
      }

      function commitPlacement(finishedWork) {
        if (!supportsMutation) {
          return;
        }

        var parentFiber = getHostParentFiber(finishedWork);
        var parent = void 0;
        var isContainer = void 0;

        switch (parentFiber.tag) {
          case HostComponent:
            parent = parentFiber.stateNode;
            isContainer = false;
            break;

          case HostRoot:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          case HostPortal:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          default:
            invariant(false, "Invalid host parent fiber. This error is likely caused by a bug " + "in React. Please file an issue.");
        }

        if (parentFiber.effectTag & ContentReset) {
          resetTextContent(parent);
          parentFiber.effectTag &= ~ContentReset;
        }

        var before = getHostSibling(finishedWork);
        var node = finishedWork;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            if (before) {
              if (isContainer) {
                insertInContainerBefore(parent, node.stateNode, before);
              } else {
                insertBefore(parent, node.stateNode, before);
              }
            } else {
              if (isContainer) {
                appendChildToContainer(parent, node.stateNode);
              } else {
                appendChild$1(parent, node.stateNode);
              }
            }
          } else if (node.tag === HostPortal) {} else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === finishedWork) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === finishedWork) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function unmountHostComponents(current$$1) {
        var node = current$$1;
        var currentParentIsValid = false;
        var currentParent = void 0;
        var currentParentIsContainer = void 0;

        while (true) {
          if (!currentParentIsValid) {
            var parent = node.return;

            findParent: while (true) {
              invariant(parent !== null, "Expected to find a host parent. This error is likely caused by " + "a bug in React. Please file an issue.");

              switch (parent.tag) {
                case HostComponent:
                  currentParent = parent.stateNode;
                  currentParentIsContainer = false;
                  break findParent;

                case HostRoot:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;

                case HostPortal:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;
              }

              parent = parent.return;
            }

            currentParentIsValid = true;
          }

          if (node.tag === HostComponent || node.tag === HostText) {
            commitNestedUnmounts(node);

            if (currentParentIsContainer) {
              removeChildFromContainer(currentParent, node.stateNode);
            } else {
              removeChild(currentParent, node.stateNode);
            }
          } else if (enableSuspenseServerRenderer && node.tag === DehydratedSuspenseComponent) {
            if (currentParentIsContainer) {
              clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);
            } else {
              clearSuspenseBoundary(currentParent, node.stateNode);
            }
          } else if (node.tag === HostPortal) {
            if (node.child !== null) {
              currentParent = node.stateNode.containerInfo;
              currentParentIsContainer = true;
              node.child.return = node;
              node = node.child;
              continue;
            }
          } else {
            commitUnmount(node);

            if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          }

          if (node === current$$1) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === current$$1) {
              return;
            }

            node = node.return;

            if (node.tag === HostPortal) {
              currentParentIsValid = false;
            }
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function commitDeletion(current$$1) {
        if (supportsMutation) {
          unmountHostComponents(current$$1);
        } else {
          commitNestedUnmounts(current$$1);
        }

        detachFiber(current$$1);
      }

      function commitWork(current$$1, finishedWork) {
        if (!supportsMutation) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
              {
                commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
                return;
              }
          }

          commitContainer(finishedWork);
          return;
        }

        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
              return;
            }

          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              var instance = finishedWork.stateNode;

              if (instance != null) {
                var newProps = finishedWork.memoizedProps;
                var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;
                var type = finishedWork.type;
                var updatePayload = finishedWork.updateQueue;
                finishedWork.updateQueue = null;

                if (updatePayload !== null) {
                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                }
              }

              return;
            }

          case HostText:
            {
              invariant(finishedWork.stateNode !== null, "This should have a text node initialized. This error is likely " + "caused by a bug in React. Please file an issue.");
              var textInstance = finishedWork.stateNode;
              var newText = finishedWork.memoizedProps;
              var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
              commitTextUpdate(textInstance, oldText, newText);
              return;
            }

          case HostRoot:
            {
              return;
            }

          case Profiler:
            {
              return;
            }

          case SuspenseComponent:
            {
              var newState = finishedWork.memoizedState;
              var newDidTimeout = void 0;
              var primaryChildParent = finishedWork;

              if (newState === null) {
                newDidTimeout = false;
              } else {
                newDidTimeout = true;
                primaryChildParent = finishedWork.child;

                if (newState.timedOutAt === NoWork) {
                  newState.timedOutAt = requestCurrentTime();
                }
              }

              if (primaryChildParent !== null) {
                hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
              }

              var thenables = finishedWork.updateQueue;

              if (thenables !== null) {
                finishedWork.updateQueue = null;
                var retryCache = finishedWork.stateNode;

                if (retryCache === null) {
                  retryCache = finishedWork.stateNode = new PossiblyWeakSet$1();
                }

                thenables.forEach(function (thenable) {
                  var retry = resolveRetryThenable.bind(null, finishedWork, thenable);

                  if (enableSchedulerTracing) {
                    retry = tracing.unstable_wrap(retry);
                  }

                  if (!retryCache.has(thenable)) {
                    retryCache.add(thenable);
                    thenable.then(retry, retry);
                  }
                });
              }

              return;
            }

          case IncompleteClassComponent:
            {
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitResetTextContent(current$$1) {
        if (!supportsMutation) {
          return;
        }

        resetTextContent(current$$1.stateNode);
      }

      var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
      var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;

      function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error = errorInfo.value;

        update.callback = function () {
          onUncaughtError(error);
          logError(fiber, errorInfo);
        };

        return update;
      }

      function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

        if (typeof getDerivedStateFromError === "function") {
          var error = errorInfo.value;

          update.payload = function () {
            return getDerivedStateFromError(error);
          };
        }

        var inst = fiber.stateNode;

        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }

            var error = errorInfo.value;
            var stack = errorInfo.stack;
            logError(fiber, errorInfo);
            this.componentDidCatch(error, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                !(fiber.expirationTime === Sync) ? warningWithoutStack$1(false, "%s: Error boundaries should implement getDerivedStateFromError(). " + "In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown") : void 0;
              }
            }
          };
        }

        return update;
      }

      function attachPingListener(root, renderExpirationTime, thenable) {
        var pingCache = root.pingCache;
        var threadIDs = void 0;

        if (pingCache === null) {
          pingCache = root.pingCache = new PossiblyWeakMap();
          threadIDs = new Set();
          pingCache.set(thenable, threadIDs);
        } else {
          threadIDs = pingCache.get(thenable);

          if (threadIDs === undefined) {
            threadIDs = new Set();
            pingCache.set(thenable, threadIDs);
          }
        }

        if (!threadIDs.has(renderExpirationTime)) {
          threadIDs.add(renderExpirationTime);
          var ping = pingSuspendedRoot.bind(null, root, thenable, renderExpirationTime);

          if (enableSchedulerTracing) {
            ping = tracing.unstable_wrap(ping);
          }

          thenable.then(ping, ping);
        }
      }

      function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
        sourceFiber.effectTag |= Incomplete;
        sourceFiber.firstEffect = sourceFiber.lastEffect = null;

        if (value !== null && typeof value === "object" && typeof value.then === "function") {
          var thenable = value;
          var _workInProgress = returnFiber;
          var earliestTimeoutMs = -1;
          var startTimeMs = -1;

          do {
            if (_workInProgress.tag === SuspenseComponent) {
              var current$$1 = _workInProgress.alternate;

              if (current$$1 !== null) {
                var currentState = current$$1.memoizedState;

                if (currentState !== null) {
                  var timedOutAt = currentState.timedOutAt;
                  startTimeMs = expirationTimeToMs(timedOutAt);
                  break;
                }
              }

              var timeoutPropMs = _workInProgress.pendingProps.maxDuration;

              if (typeof timeoutPropMs === "number") {
                if (timeoutPropMs <= 0) {
                  earliestTimeoutMs = 0;
                } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
                  earliestTimeoutMs = timeoutPropMs;
                }
              }
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          _workInProgress = returnFiber;

          do {
            if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress)) {
              var thenables = _workInProgress.updateQueue;

              if (thenables === null) {
                var updateQueue = new Set();
                updateQueue.add(thenable);
                _workInProgress.updateQueue = updateQueue;
              } else {
                thenables.add(thenable);
              }

              if ((_workInProgress.mode & ConcurrentMode) === NoEffect) {
                _workInProgress.effectTag |= DidCapture;
                sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);

                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;

                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(Sync);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update);
                  }
                }

                sourceFiber.expirationTime = Sync;
                return;
              }

              attachPingListener(root, renderExpirationTime, thenable);
              var absoluteTimeoutMs = void 0;

              if (earliestTimeoutMs === -1) {
                absoluteTimeoutMs = maxSigned31BitInt;
              } else {
                if (startTimeMs === -1) {
                  var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);
                  var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
                  startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
                }

                absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
              }

              renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            } else if (enableSuspenseServerRenderer && _workInProgress.tag === DehydratedSuspenseComponent) {
              attachPingListener(root, renderExpirationTime, thenable);
              var retryCache = _workInProgress.memoizedState;

              if (retryCache === null) {
                retryCache = _workInProgress.memoizedState = new PossiblyWeakSet();
                var _current = _workInProgress.alternate;
                invariant(_current, "A dehydrated suspense boundary must commit before trying to render. " + "This is probably a bug in React.");
                _current.memoizedState = retryCache;
              }

              if (!retryCache.has(thenable)) {
                retryCache.add(thenable);
                var retry = resolveRetryThenable.bind(null, _workInProgress, thenable);

                if (enableSchedulerTracing) {
                  retry = tracing.unstable_wrap(retry);
                }

                thenable.then(retry, retry);
              }

              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n" + "\n" + "Add a <Suspense fallback=...> component higher in the tree to " + "provide a loading indicator or placeholder to display." + getStackByFiberInDevAndProd(sourceFiber));
        }

        renderDidError();
        value = createCapturedValue(value, sourceFiber);
        var workInProgress = returnFiber;

        do {
          switch (workInProgress.tag) {
            case HostRoot:
              {
                var _errorInfo = value;
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;

                var _update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);

                enqueueCapturedUpdate(workInProgress, _update);
                return;
              }

            case ClassComponent:
              var errorInfo = value;
              var ctor = workInProgress.type;
              var instance = workInProgress.stateNode;

              if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;

                var _update2 = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);

                enqueueCapturedUpdate(workInProgress, _update2);
                return;
              }

              break;

            default:
              break;
          }

          workInProgress = workInProgress.return;
        } while (workInProgress !== null);
      }

      function unwindWork(workInProgress, renderExpirationTime) {
        switch (workInProgress.tag) {
          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag & ShouldCapture) {
                workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var _effectTag = workInProgress.effectTag;
              invariant((_effectTag & DidCapture) === NoEffect, "The root failed to unmount after an error. This is likely a bug in " + "React. Please file an issue.");
              workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              return null;
            }

          case SuspenseComponent:
            {
              var _effectTag2 = workInProgress.effectTag;

              if (_effectTag2 & ShouldCapture) {
                workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case DehydratedSuspenseComponent:
            {
              if (enableSuspenseServerRenderer) {
                var _effectTag3 = workInProgress.effectTag;

                if (_effectTag3 & ShouldCapture) {
                  workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;
                  return workInProgress;
                }
              }

              return null;
            }

          case HostPortal:
            popHostContainer(workInProgress);
            return null;

          case ContextProvider:
            popProvider(workInProgress);
            return null;

          default:
            return null;
        }
      }

      function unwindInterruptedWork(interruptedWork) {
        switch (interruptedWork.tag) {
          case ClassComponent:
            {
              var childContextTypes = interruptedWork.type.childContextTypes;

              if (childContextTypes !== null && childContextTypes !== undefined) {
                popContext(interruptedWork);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              break;
            }

          case HostComponent:
            {
              popHostContext(interruptedWork);
              break;
            }

          case HostPortal:
            popHostContainer(interruptedWork);
            break;

          case ContextProvider:
            popProvider(interruptedWork);
            break;

          default:
            break;
        }
      }

      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
      var didWarnAboutStateTransition = void 0;
      var didWarnSetStateChildContext = void 0;
      var warnAboutUpdateOnUnmounted = void 0;
      var warnAboutInvalidUpdates = void 0;

      if (enableSchedulerTracing) {
        invariant(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null, "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " + "without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. " + "Your bundler might have a setting for aliasing both modules. " + "Learn more at http://fb.me/react-profiling");
      }

      {
        didWarnAboutStateTransition = false;
        didWarnSetStateChildContext = false;
        var didWarnStateUpdateForUnmountedComponent = {};

        warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber, isClass) {
          var componentName = getComponentName(fiber.type) || "ReactComponent";

          if (didWarnStateUpdateForUnmountedComponent[componentName]) {
            return;
          }

          warningWithoutStack$1(false, "Can't perform a React state update on an unmounted component. This " + "is a no-op, but it indicates a memory leak in your application. To " + "fix, cancel all subscriptions and asynchronous tasks in %s.%s", isClass ? "the componentWillUnmount method" : "a useEffect cleanup function", getStackByFiberInDevAndProd(fiber));
          didWarnStateUpdateForUnmountedComponent[componentName] = true;
        };

        warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
          switch (phase) {
            case "getChildContext":
              if (didWarnSetStateChildContext) {
                return;
              }

              warningWithoutStack$1(false, "setState(...): Cannot call setState() inside getChildContext()");
              didWarnSetStateChildContext = true;
              break;

            case "render":
              if (didWarnAboutStateTransition) {
                return;
              }

              warningWithoutStack$1(false, "Cannot update during an existing state transition (such as within " + "`render`). Render methods should be a pure function of props and state.");
              didWarnAboutStateTransition = true;
              break;
          }
        };
      }
      var isWorking = false;
      var nextUnitOfWork = null;
      var nextRoot = null;
      var nextRenderExpirationTime = NoWork;
      var nextLatestAbsoluteTimeoutMs = -1;
      var nextRenderDidError = false;
      var nextEffect = null;
      var isCommitting$1 = false;
      var rootWithPendingPassiveEffects = null;
      var passiveEffectCallbackHandle = null;
      var passiveEffectCallback = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var interruptedBy = null;
      var stashedWorkInProgressProperties = void 0;
      var replayUnitOfWork = void 0;
      var mayReplayFailedUnitOfWork = void 0;
      var isReplayingFailedUnitOfWork = void 0;
      var originalReplayError = void 0;
      var rethrowOriginalError = void 0;

      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        stashedWorkInProgressProperties = null;
        mayReplayFailedUnitOfWork = true;
        isReplayingFailedUnitOfWork = false;
        originalReplayError = null;

        replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {
          if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
            return;
          }

          if (stashedWorkInProgressProperties === null) {
            warningWithoutStack$1(false, "Could not replay rendering after an error. This is likely a bug in React. " + "Please file an issue.");
            return;
          }

          assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);

          switch (failedUnitOfWork.tag) {
            case HostRoot:
              popHostContainer(failedUnitOfWork);
              popTopLevelContextObject(failedUnitOfWork);
              break;

            case HostComponent:
              popHostContext(failedUnitOfWork);
              break;

            case ClassComponent:
              {
                var Component = failedUnitOfWork.type;

                if (isContextProvider(Component)) {
                  popContext(failedUnitOfWork);
                }

                break;
              }

            case HostPortal:
              popHostContainer(failedUnitOfWork);
              break;

            case ContextProvider:
              popProvider(failedUnitOfWork);
              break;
          }

          isReplayingFailedUnitOfWork = true;
          originalReplayError = thrownValue;
          invokeGuardedCallback(null, workLoop, null, isYieldy);
          isReplayingFailedUnitOfWork = false;
          originalReplayError = null;

          if (hasCaughtError()) {
            var replayError = clearCaughtError();

            if (replayError != null && thrownValue != null) {
              try {
                if (replayError._suppressLogging) {
                  thrownValue._suppressLogging = true;
                }
              } catch (inner) {}
            }
          } else {
            nextUnitOfWork = failedUnitOfWork;
          }
        };

        rethrowOriginalError = function rethrowOriginalError() {
          throw originalReplayError;
        };
      }

      function resetStack() {
        if (nextUnitOfWork !== null) {
          var interruptedWork = nextUnitOfWork.return;

          while (interruptedWork !== null) {
            unwindInterruptedWork(interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }

        {
          ReactStrictModeWarnings.discardPendingWarnings();
          checkThatStackIsEmpty();
        }
        nextRoot = null;
        nextRenderExpirationTime = NoWork;
        nextLatestAbsoluteTimeoutMs = -1;
        nextRenderDidError = false;
        nextUnitOfWork = null;
      }

      function commitAllHostEffects() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          recordEffect();
          var effectTag = nextEffect.effectTag;

          if (effectTag & ContentReset) {
            commitResetTextContent(nextEffect);
          }

          if (effectTag & Ref) {
            var current$$1 = nextEffect.alternate;

            if (current$$1 !== null) {
              commitDetachRef(current$$1);
            }
          }

          var primaryEffectTag = effectTag & (Placement | Update | Deletion);

          switch (primaryEffectTag) {
            case Placement:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                break;
              }

            case PlacementAndUpdate:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                var _current = nextEffect.alternate;
                commitWork(_current, nextEffect);
                break;
              }

            case Update:
              {
                var _current2 = nextEffect.alternate;
                commitWork(_current2, nextEffect);
                break;
              }

            case Deletion:
              {
                commitDeletion(nextEffect);
                break;
              }
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitBeforeMutationLifecycles() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          var effectTag = nextEffect.effectTag;

          if (effectTag & Snapshot) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitBeforeMutationLifeCycles(current$$1, nextEffect);
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
        {
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          ReactStrictModeWarnings.flushLegacyContextWarning();

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.flushPendingDeprecationWarnings();
          }
        }

        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          var effectTag = nextEffect.effectTag;

          if (effectTag & (Update | Callback)) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);
          }

          if (effectTag & Ref) {
            recordEffect();
            commitAttachRef(nextEffect);
          }

          if (effectTag & Passive) {
            rootWithPendingPassiveEffects = finishedRoot;
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitPassiveEffects(root, firstEffect) {
        rootWithPendingPassiveEffects = null;
        passiveEffectCallbackHandle = null;
        passiveEffectCallback = null;
        var previousIsRendering = isRendering;
        isRendering = true;
        var effect = firstEffect;

        do {
          {
            setCurrentFiber(effect);
          }

          if (effect.effectTag & Passive) {
            var didError = false;
            var error = void 0;
            {
              invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);

              if (hasCaughtError()) {
                didError = true;
                error = clearCaughtError();
              }
            }

            if (didError) {
              captureCommitPhaseError(effect, error);
            }
          }

          effect = effect.nextEffect;
        } while (effect !== null);

        {
          resetCurrentFiber();
        }
        isRendering = previousIsRendering;
        var rootExpirationTime = root.expirationTime;

        if (rootExpirationTime !== NoWork) {
          requestWork(root, rootExpirationTime);
        }

        if (!isBatchingUpdates && !isRendering) {
          performSyncWork();
        }
      }

      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }

      function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance);
        }
      }

      function flushPassiveEffects() {
        if (passiveEffectCallbackHandle !== null) {
          cancelPassiveEffects(passiveEffectCallbackHandle);
        }

        if (passiveEffectCallback !== null) {
          passiveEffectCallback();
        }
      }

      function commitRoot(root, finishedWork) {
        isWorking = true;
        isCommitting$1 = true;
        startCommitTimer();
        invariant(root.current !== finishedWork, "Cannot commit the same tree as before. This is probably a bug " + "related to the return field. This error is likely caused by a bug " + "in React. Please file an issue.");
        var committedExpirationTime = root.pendingCommitExpirationTime;
        invariant(committedExpirationTime !== NoWork, "Cannot commit an incomplete root. This error is likely caused by a " + "bug in React. Please file an issue.");
        root.pendingCommitExpirationTime = NoWork;
        var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
        var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeBeforeCommit = childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
        markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);
        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        ReactCurrentOwner$2.current = null;
        var firstEffect = void 0;

        if (finishedWork.effectTag > PerformedWork) {
          if (finishedWork.lastEffect !== null) {
            finishedWork.lastEffect.nextEffect = finishedWork;
            firstEffect = finishedWork.firstEffect;
          } else {
            firstEffect = finishedWork;
          }
        } else {
          firstEffect = finishedWork.firstEffect;
        }

        prepareForCommit(root.containerInfo);
        nextEffect = firstEffect;
        startCommitSnapshotEffectsTimer();

        while (nextEffect !== null) {
          var didError = false;
          var error = void 0;
          {
            invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);

            if (hasCaughtError()) {
              didError = true;
              error = clearCaughtError();
            }
          }

          if (didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitSnapshotEffectsTimer();

        if (enableProfilerTimer) {
          recordCommitTime();
        }

        nextEffect = firstEffect;
        startCommitHostEffectsTimer();

        while (nextEffect !== null) {
          var _didError = false;

          var _error = void 0;

          {
            invokeGuardedCallback(null, commitAllHostEffects, null);

            if (hasCaughtError()) {
              _didError = true;
              _error = clearCaughtError();
            }
          }

          if (_didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitHostEffectsTimer();
        resetAfterCommit(root.containerInfo);
        root.current = finishedWork;
        nextEffect = firstEffect;
        startCommitLifeCyclesTimer();

        while (nextEffect !== null) {
          var _didError2 = false;

          var _error2 = void 0;

          {
            invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);

            if (hasCaughtError()) {
              _didError2 = true;
              _error2 = clearCaughtError();
            }
          }

          if (_didError2) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error2);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        if (firstEffect !== null && rootWithPendingPassiveEffects !== null) {
          var callback = commitPassiveEffects.bind(null, root, firstEffect);

          if (enableSchedulerTracing) {
            callback = tracing.unstable_wrap(callback);
          }

          passiveEffectCallbackHandle = scheduler.unstable_runWithPriority(scheduler.unstable_NormalPriority, function () {
            return schedulePassiveEffects(callback);
          });
          passiveEffectCallback = callback;
        }

        isCommitting$1 = false;
        isWorking = false;
        stopCommitLifeCyclesTimer();
        stopCommitTimer();
        onCommitRoot(finishedWork.stateNode);

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
        }

        var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
        var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeAfterCommit = childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;

        if (earliestRemainingTimeAfterCommit === NoWork) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }

        onCommit(root, earliestRemainingTimeAfterCommit);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
          var subscriber = void 0;

          try {
            subscriber = tracing.__subscriberRef.current;

            if (subscriber !== null && root.memoizedInteractions.size > 0) {
              var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
              subscriber.onWorkStopped(root.memoizedInteractions, threadID);
            }
          } catch (error) {
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          } finally {
            var pendingInteractionMap = root.pendingInteractionMap;
            pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
                pendingInteractionMap.delete(scheduledExpirationTime);
                scheduledInteractions.forEach(function (interaction) {
                  interaction.__count--;

                  if (subscriber !== null && interaction.__count === 0) {
                    try {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    } catch (error) {
                      if (!hasUnhandledError) {
                        hasUnhandledError = true;
                        unhandledError = error;
                      }
                    }
                  }
                });
              }
            });
          }
        }
      }

      function resetChildExpirationTime(workInProgress, renderTime) {
        if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
          return;
        }

        var newChildExpirationTime = NoWork;

        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
          var actualDuration = workInProgress.actualDuration;
          var treeBaseDuration = workInProgress.selfBaseDuration;
          var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;
          var child = workInProgress.child;

          while (child !== null) {
            var childUpdateExpirationTime = child.expirationTime;
            var childChildExpirationTime = child.childExpirationTime;

            if (childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childUpdateExpirationTime;
            }

            if (childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childChildExpirationTime;
            }

            if (shouldBubbleActualDurations) {
              actualDuration += child.actualDuration;
            }

            treeBaseDuration += child.treeBaseDuration;
            child = child.sibling;
          }

          workInProgress.actualDuration = actualDuration;
          workInProgress.treeBaseDuration = treeBaseDuration;
        } else {
          var _child = workInProgress.child;

          while (_child !== null) {
            var _childUpdateExpirationTime = _child.expirationTime;
            var _childChildExpirationTime = _child.childExpirationTime;

            if (_childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childUpdateExpirationTime;
            }

            if (_childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childChildExpirationTime;
            }

            _child = _child.sibling;
          }
        }

        workInProgress.childExpirationTime = newChildExpirationTime;
      }

      function completeUnitOfWork(workInProgress) {
        while (true) {
          var current$$1 = workInProgress.alternate;
          {
            setCurrentFiber(workInProgress);
          }
          var returnFiber = workInProgress.return;
          var siblingFiber = workInProgress.sibling;

          if ((workInProgress.effectTag & Incomplete) === NoEffect) {
            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = false;
            }

            nextUnitOfWork = workInProgress;

            if (enableProfilerTimer) {
              if (workInProgress.mode & ProfileMode) {
                startProfilerTimer(workInProgress);
              }

              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);

              if (workInProgress.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              }
            } else {
              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);
            }

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = true;
            }

            stopWorkTimer(workInProgress);
            resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
            {
              resetCurrentFiber();
            }

            if (nextUnitOfWork !== null) {
              return nextUnitOfWork;
            }

            if (returnFiber !== null && (returnFiber.effectTag & Incomplete) === NoEffect) {
              if (returnFiber.firstEffect === null) {
                returnFiber.firstEffect = workInProgress.firstEffect;
              }

              if (workInProgress.lastEffect !== null) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
                }

                returnFiber.lastEffect = workInProgress.lastEffect;
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag > PerformedWork) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress;
                } else {
                  returnFiber.firstEffect = workInProgress;
                }

                returnFiber.lastEffect = workInProgress;
              }
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          } else {
            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              var actualDuration = workInProgress.actualDuration;
              var child = workInProgress.child;

              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }

              workInProgress.actualDuration = actualDuration;
            }

            var next = unwindWork(workInProgress, nextRenderExpirationTime);

            if (workInProgress.effectTag & DidCapture) {
              stopFailedWorkTimer(workInProgress);
            } else {
              stopWorkTimer(workInProgress);
            }

            {
              resetCurrentFiber();
            }

            if (next !== null) {
              stopWorkTimer(workInProgress);

              if (true && ReactFiberInstrumentation_1.debugTool) {
                ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
              }

              next.effectTag &= HostEffectMask;
              return next;
            }

            if (returnFiber !== null) {
              returnFiber.firstEffect = returnFiber.lastEffect = null;
              returnFiber.effectTag |= Incomplete;
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          }
        }

        return null;
      }

      function performUnitOfWork(workInProgress) {
        var current$$1 = workInProgress.alternate;
        startWorkTimer(workInProgress);
        {
          setCurrentFiber(workInProgress);
        }

        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
          stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);
        }

        var next = void 0;

        if (enableProfilerTimer) {
          if (workInProgress.mode & ProfileMode) {
            startProfilerTimer(workInProgress);
          }

          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;

          if (workInProgress.mode & ProfileMode) {
            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
          }
        } else {
          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;
        }

        {
          resetCurrentFiber();

          if (isReplayingFailedUnitOfWork) {
            rethrowOriginalError();
          }
        }

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
        }

        if (next === null) {
          next = completeUnitOfWork(workInProgress);
        }

        ReactCurrentOwner$2.current = null;
        return next;
      }

      function workLoop(isYieldy) {
        if (!isYieldy) {
          while (nextUnitOfWork !== null) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        } else {
          while (nextUnitOfWork !== null && !shouldYield$$1()) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        }
      }

      function renderRoot(root, isYieldy) {
        invariant(!isWorking, "renderRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        flushPassiveEffects();
        isWorking = true;
        var previousDispatcher = ReactCurrentDispatcher.current;
        ReactCurrentDispatcher.current = ContextOnlyDispatcher;
        var expirationTime = root.nextExpirationTimeToWorkOn;

        if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
          resetStack();
          nextRoot = root;
          nextRenderExpirationTime = expirationTime;
          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);
          root.pendingCommitExpirationTime = NoWork;

          if (enableSchedulerTracing) {
            var interactions = new Set();
            root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime >= expirationTime) {
                scheduledInteractions.forEach(function (interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root.memoizedInteractions = interactions;

            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;

              if (subscriber !== null) {
                var threadID = computeThreadID(expirationTime, root.interactionThreadID);

                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error) {
                  if (!hasUnhandledError) {
                    hasUnhandledError = true;
                    unhandledError = error;
                  }
                }
              }
            }
          }
        }

        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        var didFatal = false;
        startWorkLoopTimer(nextUnitOfWork);

        do {
          try {
            workLoop(isYieldy);
          } catch (thrownValue) {
            resetContextDependences();
            resetHooks();
            var mayReplay = void 0;

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplay = mayReplayFailedUnitOfWork;
              mayReplayFailedUnitOfWork = true;
            }

            if (nextUnitOfWork === null) {
              didFatal = true;
              onUncaughtError(thrownValue);
            } else {
              if (enableProfilerTimer && nextUnitOfWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);
              }

              {
                resetCurrentlyProcessingQueue();
              }

              if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
                if (mayReplay) {
                  var failedUnitOfWork = nextUnitOfWork;
                  replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
                }
              }

              invariant(nextUnitOfWork !== null, "Failed to replay rendering after an error. This " + "is likely caused by a bug in React. Please file an issue " + "with a reproducing case to help us find it.");
              var sourceFiber = nextUnitOfWork;
              var returnFiber = sourceFiber.return;

              if (returnFiber === null) {
                didFatal = true;
                onUncaughtError(thrownValue);
              } else {
                throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
                nextUnitOfWork = completeUnitOfWork(sourceFiber);
                continue;
              }
            }
          }

          break;
        } while (true);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
        }

        isWorking = false;
        ReactCurrentDispatcher.current = previousDispatcher;
        resetContextDependences();
        resetHooks();

        if (didFatal) {
          var _didCompleteRoot = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
          interruptedBy = null;
          {
            resetStackAfterFatalErrorInDev();
          }
          nextRoot = null;
          onFatal(root);
          return;
        }

        if (nextUnitOfWork !== null) {
          var _didCompleteRoot2 = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
          interruptedBy = null;
          onYield(root);
          return;
        }

        var didCompleteRoot = true;
        stopWorkLoopTimer(interruptedBy, didCompleteRoot);
        var rootWorkInProgress = root.current.alternate;
        invariant(rootWorkInProgress !== null, "Finished root should have a work-in-progress. This error is likely " + "caused by a bug in React. Please file an issue.");
        nextRoot = null;
        interruptedBy = null;

        if (nextRenderDidError) {
          if (hasLowerPriorityWork(root, expirationTime)) {
            markSuspendedPriorityLevel(root, expirationTime);
            var suspendedExpirationTime = expirationTime;
            var rootExpirationTime = root.expirationTime;
            onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1);
            return;
          } else if (!root.didError && isYieldy) {
            root.didError = true;

            var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;

            var _rootExpirationTime = root.expirationTime = Sync;

            onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1);
            return;
          }
        }

        if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
          var _suspendedExpirationTime2 = expirationTime;
          markSuspendedPriorityLevel(root, _suspendedExpirationTime2);
          var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);
          var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);

          if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
            nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
          }

          var currentTimeMs = expirationTimeToMs(requestCurrentTime());
          var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
          msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;
          var _rootExpirationTime2 = root.expirationTime;
          onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
          return;
        }

        onComplete(root, rootWorkInProgress, expirationTime);
      }

      function captureCommitPhaseError(sourceFiber, value) {
        var expirationTime = Sync;
        var fiber = sourceFiber.return;

        while (fiber !== null) {
          switch (fiber.tag) {
            case ClassComponent:
              var ctor = fiber.type;
              var instance = fiber.stateNode;

              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValue(value, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
                enqueueUpdate(fiber, update);
                scheduleWork(fiber, expirationTime);
                return;
              }

              break;

            case HostRoot:
              {
                var _errorInfo = createCapturedValue(value, sourceFiber);

                var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);

                enqueueUpdate(fiber, _update);
                scheduleWork(fiber, expirationTime);
                return;
              }
          }

          fiber = fiber.return;
        }

        if (sourceFiber.tag === HostRoot) {
          var rootFiber = sourceFiber;

          var _errorInfo2 = createCapturedValue(value, rootFiber);

          var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);

          enqueueUpdate(rootFiber, _update2);
          scheduleWork(rootFiber, expirationTime);
        }
      }

      function computeThreadID(expirationTime, interactionThreadID) {
        return expirationTime * 1000 + interactionThreadID;
      }

      function computeExpirationForFiber(currentTime, fiber) {
        var priorityLevel = scheduler.unstable_getCurrentPriorityLevel();
        var expirationTime = void 0;

        if ((fiber.mode & ConcurrentMode) === NoContext) {
          expirationTime = Sync;
        } else if (isWorking && !isCommitting$1) {
          expirationTime = nextRenderExpirationTime;
        } else {
          switch (priorityLevel) {
            case scheduler.unstable_ImmediatePriority:
              expirationTime = Sync;
              break;

            case scheduler.unstable_UserBlockingPriority:
              expirationTime = computeInteractiveExpiration(currentTime);
              break;

            case scheduler.unstable_NormalPriority:
              expirationTime = computeAsyncExpiration(currentTime);
              break;

            case scheduler.unstable_LowPriority:
            case scheduler.unstable_IdlePriority:
              expirationTime = Never;
              break;

            default:
              invariant(false, "Unknown priority level. This error is likely caused by a bug in " + "React. Please file an issue.");
          }

          if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
            expirationTime -= 1;
          }
        }

        if (priorityLevel === scheduler.unstable_UserBlockingPriority && (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime < lowestPriorityPendingInteractiveExpirationTime)) {
          lowestPriorityPendingInteractiveExpirationTime = expirationTime;
        }

        return expirationTime;
      }

      function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
        if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
          nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
        }
      }

      function renderDidError() {
        nextRenderDidError = true;
      }

      function pingSuspendedRoot(root, thenable, pingTime) {
        var pingCache = root.pingCache;

        if (pingCache !== null) {
          pingCache.delete(thenable);
        }

        if (nextRoot !== null && nextRenderExpirationTime === pingTime) {
          nextRoot = null;
        } else {
          if (isPriorityLevelSuspended(root, pingTime)) {
            markPingedPriorityLevel(root, pingTime);
            var rootExpirationTime = root.expirationTime;

            if (rootExpirationTime !== NoWork) {
              requestWork(root, rootExpirationTime);
            }
          }
        }
      }

      function retryTimedOutBoundary(boundaryFiber) {
        var currentTime = requestCurrentTime();
        var retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
        var root = scheduleWorkToRoot(boundaryFiber, retryTime);

        if (root !== null) {
          markPendingPriorityLevel(root, retryTime);
          var rootExpirationTime = root.expirationTime;

          if (rootExpirationTime !== NoWork) {
            requestWork(root, rootExpirationTime);
          }
        }
      }

      function resolveRetryThenable(boundaryFiber, thenable) {
        var retryCache = void 0;

        if (enableSuspenseServerRenderer) {
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              break;

            case DehydratedSuspenseComponent:
              retryCache = boundaryFiber.memoizedState;
              break;

            default:
              invariant(false, "Pinged unknown suspense boundary type. " + "This is probably a bug in React.");
          }
        } else {
          retryCache = boundaryFiber.stateNode;
        }

        if (retryCache !== null) {
          retryCache.delete(thenable);
        }

        retryTimedOutBoundary(boundaryFiber);
      }

      function scheduleWorkToRoot(fiber, expirationTime) {
        recordScheduleUpdate();
        {
          if (fiber.tag === ClassComponent) {
            var instance = fiber.stateNode;
            warnAboutInvalidUpdates(instance);
          }
        }

        if (fiber.expirationTime < expirationTime) {
          fiber.expirationTime = expirationTime;
        }

        var alternate = fiber.alternate;

        if (alternate !== null && alternate.expirationTime < expirationTime) {
          alternate.expirationTime = expirationTime;
        }

        var node = fiber.return;
        var root = null;

        if (node === null && fiber.tag === HostRoot) {
          root = fiber.stateNode;
        } else {
          while (node !== null) {
            alternate = node.alternate;

            if (node.childExpirationTime < expirationTime) {
              node.childExpirationTime = expirationTime;

              if (alternate !== null && alternate.childExpirationTime < expirationTime) {
                alternate.childExpirationTime = expirationTime;
              }
            } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {
              alternate.childExpirationTime = expirationTime;
            }

            if (node.return === null && node.tag === HostRoot) {
              root = node.stateNode;
              break;
            }

            node = node.return;
          }
        }

        if (enableSchedulerTracing) {
          if (root !== null) {
            var interactions = tracing.__interactionsRef.current;

            if (interactions.size > 0) {
              var pendingInteractionMap = root.pendingInteractionMap;
              var pendingInteractions = pendingInteractionMap.get(expirationTime);

              if (pendingInteractions != null) {
                interactions.forEach(function (interaction) {
                  if (!pendingInteractions.has(interaction)) {
                    interaction.__count++;
                  }

                  pendingInteractions.add(interaction);
                });
              } else {
                pendingInteractionMap.set(expirationTime, new Set(interactions));
                interactions.forEach(function (interaction) {
                  interaction.__count++;
                });
              }

              var subscriber = tracing.__subscriberRef.current;

              if (subscriber !== null) {
                var threadID = computeThreadID(expirationTime, root.interactionThreadID);
                subscriber.onWorkScheduled(interactions, threadID);
              }
            }
          }
        }

        return root;
      }

      function warnIfNotCurrentlyBatchingInDev(fiber) {
        {
          if (isRendering === false && isBatchingUpdates === false) {
            warningWithoutStack$1(false, "An update to %s inside a test was not wrapped in act(...).\n\n" + "When testing, code that causes React state updates should be wrapped into act(...):\n\n" + "act(() => {\n" + "  /* fire events that update state */\n" + "});\n" + "/* assert on the output */\n\n" + "This ensures that you're testing the behavior the user would see in the browser." + " Learn more at https://fb.me/react-wrap-tests-with-act" + "%s", getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));
          }
        }
      }

      function scheduleWork(fiber, expirationTime) {
        var root = scheduleWorkToRoot(fiber, expirationTime);

        if (root === null) {
          {
            switch (fiber.tag) {
              case ClassComponent:
                warnAboutUpdateOnUnmounted(fiber, true);
                break;

              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
                warnAboutUpdateOnUnmounted(fiber, false);
                break;
            }
          }
          return;
        }

        if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime > nextRenderExpirationTime) {
          interruptedBy = fiber;
          resetStack();
        }

        markPendingPriorityLevel(root, expirationTime);

        if (!isWorking || isCommitting$1 || nextRoot !== root) {
          var rootExpirationTime = root.expirationTime;
          requestWork(root, rootExpirationTime);
        }

        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          invariant(false, "Maximum update depth exceeded. This can happen when a " + "component repeatedly calls setState inside " + "componentWillUpdate or componentDidUpdate. React limits " + "the number of nested updates to prevent infinite loops.");
        }
      }

      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var callbackExpirationTime = NoWork;
      var callbackID = void 0;
      var isRendering = false;
      var nextFlushedRoot = null;
      var nextFlushedExpirationTime = NoWork;
      var lowestPriorityPendingInteractiveExpirationTime = NoWork;
      var hasUnhandledError = false;
      var unhandledError = null;
      var isBatchingUpdates = false;
      var isUnbatchingUpdates = false;
      var completedBatches = null;
      var originalStartTimeMs = now$$1();
      var currentRendererTime = msToExpirationTime(originalStartTimeMs);
      var currentSchedulerTime = currentRendererTime;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var lastCommittedRootDuringThisBatch = null;

      function recomputeCurrentRendererTime() {
        var currentTimeMs = now$$1() - originalStartTimeMs;
        currentRendererTime = msToExpirationTime(currentTimeMs);
      }

      function scheduleCallbackWithExpirationTime(root, expirationTime) {
        if (callbackExpirationTime !== NoWork) {
          if (expirationTime < callbackExpirationTime) {
            return;
          } else {
            if (callbackID !== null) {
              cancelDeferredCallback$$1(callbackID);
            }
          }
        } else {
          startRequestCallbackTimer();
        }

        callbackExpirationTime = expirationTime;
        var currentMs = now$$1() - originalStartTimeMs;
        var expirationTimeMs = expirationTimeToMs(expirationTime);
        var timeout = expirationTimeMs - currentMs;
        callbackID = scheduleDeferredCallback$$1(performAsyncWork, {
          timeout: timeout
        });
      }

      function onFatal(root) {
        root.finishedWork = null;
      }

      function onComplete(root, finishedWork, expirationTime) {
        root.pendingCommitExpirationTime = expirationTime;
        root.finishedWork = finishedWork;
      }

      function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
        root.expirationTime = rootExpirationTime;

        if (msUntilTimeout === 0 && !shouldYield$$1()) {
          root.pendingCommitExpirationTime = suspendedExpirationTime;
          root.finishedWork = finishedWork;
        } else if (msUntilTimeout > 0) {
          root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
        }
      }

      function onYield(root) {
        root.finishedWork = null;
      }

      function onTimeout(root, finishedWork, suspendedExpirationTime) {
        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;
        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;
        flushRoot(root, suspendedExpirationTime);
      }

      function onCommit(root, expirationTime) {
        root.expirationTime = expirationTime;
        root.finishedWork = null;
      }

      function requestCurrentTime() {
        if (isRendering) {
          return currentSchedulerTime;
        }

        findHighestPriorityRoot();

        if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;
          return currentSchedulerTime;
        }

        return currentSchedulerTime;
      }

      function requestWork(root, expirationTime) {
        addRootToSchedule(root, expirationTime);

        if (isRendering) {
          return;
        }

        if (isBatchingUpdates) {
          if (isUnbatchingUpdates) {
            nextFlushedRoot = root;
            nextFlushedExpirationTime = Sync;
            performWorkOnRoot(root, Sync, false);
          }

          return;
        }

        if (expirationTime === Sync) {
          performSyncWork();
        } else {
          scheduleCallbackWithExpirationTime(root, expirationTime);
        }
      }

      function addRootToSchedule(root, expirationTime) {
        if (root.nextScheduledRoot === null) {
          root.expirationTime = expirationTime;

          if (lastScheduledRoot === null) {
            firstScheduledRoot = lastScheduledRoot = root;
            root.nextScheduledRoot = root;
          } else {
            lastScheduledRoot.nextScheduledRoot = root;
            lastScheduledRoot = root;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          }
        } else {
          var remainingExpirationTime = root.expirationTime;

          if (expirationTime > remainingExpirationTime) {
            root.expirationTime = expirationTime;
          }
        }
      }

      function findHighestPriorityRoot() {
        var highestPriorityWork = NoWork;
        var highestPriorityRoot = null;

        if (lastScheduledRoot !== null) {
          var previousScheduledRoot = lastScheduledRoot;
          var root = firstScheduledRoot;

          while (root !== null) {
            var remainingExpirationTime = root.expirationTime;

            if (remainingExpirationTime === NoWork) {
              invariant(previousScheduledRoot !== null && lastScheduledRoot !== null, "Should have a previous and last root. This error is likely " + "caused by a bug in React. Please file an issue.");

              if (root === root.nextScheduledRoot) {
                root.nextScheduledRoot = null;
                firstScheduledRoot = lastScheduledRoot = null;
                break;
              } else if (root === firstScheduledRoot) {
                var next = root.nextScheduledRoot;
                firstScheduledRoot = next;
                lastScheduledRoot.nextScheduledRoot = next;
                root.nextScheduledRoot = null;
              } else if (root === lastScheduledRoot) {
                lastScheduledRoot = previousScheduledRoot;
                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                root.nextScheduledRoot = null;
                break;
              } else {
                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
                root.nextScheduledRoot = null;
              }

              root = previousScheduledRoot.nextScheduledRoot;
            } else {
              if (remainingExpirationTime > highestPriorityWork) {
                highestPriorityWork = remainingExpirationTime;
                highestPriorityRoot = root;
              }

              if (root === lastScheduledRoot) {
                break;
              }

              if (highestPriorityWork === Sync) {
                break;
              }

              previousScheduledRoot = root;
              root = root.nextScheduledRoot;
            }
          }
        }

        nextFlushedRoot = highestPriorityRoot;
        nextFlushedExpirationTime = highestPriorityWork;
      }

      function performAsyncWork(didTimeout) {
        if (didTimeout) {
          if (firstScheduledRoot !== null) {
            recomputeCurrentRendererTime();
            var root = firstScheduledRoot;

            do {
              didExpireAtExpirationTime(root, currentRendererTime);
              root = root.nextScheduledRoot;
            } while (root !== firstScheduledRoot);
          }
        }

        performWork(NoWork, true);
      }

      function performSyncWork() {
        performWork(Sync, false);
      }

      function performWork(minExpirationTime, isYieldy) {
        findHighestPriorityRoot();

        if (isYieldy) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;

          if (enableUserTimingAPI) {
            var didExpire = nextFlushedExpirationTime > currentRendererTime;
            var timeout = expirationTimeToMs(nextFlushedExpirationTime);
            stopRequestCallbackTimer(didExpire, timeout);
          }

          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime && !(shouldYield$$1() && currentRendererTime > nextFlushedExpirationTime)) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime);
            findHighestPriorityRoot();
            recomputeCurrentRendererTime();
            currentSchedulerTime = currentRendererTime;
          }
        } else {
          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
            findHighestPriorityRoot();
          }
        }

        if (isYieldy) {
          callbackExpirationTime = NoWork;
          callbackID = null;
        }

        if (nextFlushedExpirationTime !== NoWork) {
          scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
        }

        finishRendering();
      }

      function flushRoot(root, expirationTime) {
        invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely " + "means you attempted to commit from inside a lifecycle method.");
        nextFlushedRoot = root;
        nextFlushedExpirationTime = expirationTime;
        performWorkOnRoot(root, expirationTime, false);
        performSyncWork();
      }

      function finishRendering() {
        nestedUpdateCount = 0;
        lastCommittedRootDuringThisBatch = null;

        if (completedBatches !== null) {
          var batches = completedBatches;
          completedBatches = null;

          for (var i = 0; i < batches.length; i++) {
            var batch = batches[i];

            try {
              batch._onComplete();
            } catch (error) {
              if (!hasUnhandledError) {
                hasUnhandledError = true;
                unhandledError = error;
              }
            }
          }
        }

        if (hasUnhandledError) {
          var error = unhandledError;
          unhandledError = null;
          hasUnhandledError = false;
          throw error;
        }
      }

      function performWorkOnRoot(root, expirationTime, isYieldy) {
        invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        isRendering = true;

        if (!isYieldy) {
          var finishedWork = root.finishedWork;

          if (finishedWork !== null) {
            completeRoot$1(root, finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var timeoutHandle = root.timeoutHandle;

            if (timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }

            renderRoot(root, isYieldy);
            finishedWork = root.finishedWork;

            if (finishedWork !== null) {
              completeRoot$1(root, finishedWork, expirationTime);
            }
          }
        } else {
          var _finishedWork = root.finishedWork;

          if (_finishedWork !== null) {
            completeRoot$1(root, _finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var _timeoutHandle = root.timeoutHandle;

            if (_timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(_timeoutHandle);
            }

            renderRoot(root, isYieldy);
            _finishedWork = root.finishedWork;

            if (_finishedWork !== null) {
              if (!shouldYield$$1()) {
                completeRoot$1(root, _finishedWork, expirationTime);
              } else {
                root.finishedWork = _finishedWork;
              }
            }
          }
        }

        isRendering = false;
      }

      function completeRoot$1(root, finishedWork, expirationTime) {
        var firstBatch = root.firstBatch;

        if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
          if (completedBatches === null) {
            completedBatches = [firstBatch];
          } else {
            completedBatches.push(firstBatch);
          }

          if (firstBatch._defer) {
            root.finishedWork = finishedWork;
            root.expirationTime = NoWork;
            return;
          }
        }

        root.finishedWork = null;

        if (root === lastCommittedRootDuringThisBatch) {
          nestedUpdateCount++;
        } else {
          lastCommittedRootDuringThisBatch = root;
          nestedUpdateCount = 0;
        }

        scheduler.unstable_runWithPriority(scheduler.unstable_ImmediatePriority, function () {
          commitRoot(root, finishedWork);
        });
      }

      function onUncaughtError(error) {
        invariant(nextFlushedRoot !== null, "Should be working on a root. This error is likely caused by a bug in " + "React. Please file an issue.");
        nextFlushedRoot.expirationTime = NoWork;

        if (!hasUnhandledError) {
          hasUnhandledError = true;
          unhandledError = error;
        }
      }

      function batchedUpdates$1(fn, a) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return fn(a);
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function interactiveUpdates$1(fn, a, b) {
        if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }

        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return scheduler.unstable_runWithPriority(scheduler.unstable_UserBlockingPriority, function () {
            return fn(a, b);
          });
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function flushInteractiveUpdates$1() {
        if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }
      }

      var didWarnAboutNestedUpdates = void 0;
      var didWarnAboutFindNodeInStrictMode = void 0;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }

      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }

        var fiber = get$1(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);

        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;

          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }

        return parentContext;
      }

      function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
        {
          if (phase === "render" && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            warningWithoutStack$1(false, "Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + "If necessary, trigger nested updates in componentDidUpdate.\n\n" + "Check the render method of %s.", getComponentName(current.type) || "Unknown");
          }
        }
        var update = createUpdate(expirationTime);
        update.payload = {
          element: element
        };
        callback = callback === undefined ? null : callback;

        if (callback !== null) {
          !(typeof callback === "function") ? warningWithoutStack$1(false, "render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback) : void 0;
          update.callback = callback;
        }

        flushPassiveEffects();
        enqueueUpdate(current$$1, update);
        scheduleWork(current$$1, expirationTime);
        return expirationTime;
      }

      function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
        var current$$1 = container.current;
        {
          if (ReactFiberInstrumentation_1.debugTool) {
            if (current$$1.alternate === null) {
              ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
            } else if (element === null) {
              ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
            } else {
              ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
            }
          }
        }
        var context = getContextForSubtree(parentComponent);

        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }

        return scheduleRootUpdate(current$$1, element, expirationTime, callback);
      }

      function findHostInstance(component) {
        var fiber = get$1(component);

        if (fiber === undefined) {
          if (typeof component.render === "function") {
            invariant(false, "Unable to find node on an unmounted component.");
          } else {
            invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
          }
        }

        var hostFiber = findCurrentHostFiber(fiber);

        if (hostFiber === null) {
          return null;
        }

        return hostFiber.stateNode;
      }

      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get$1(component);

          if (fiber === undefined) {
            if (typeof component.render === "function") {
              invariant(false, "Unable to find node on an unmounted component.");
            } else {
              invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
            }
          }

          var hostFiber = findCurrentHostFiber(fiber);

          if (hostFiber === null) {
            return null;
          }

          if (hostFiber.mode & StrictMode) {
            var componentName = getComponentName(fiber.type) || "Component";

            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;

              if (fiber.mode & StrictMode) {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which is inside StrictMode. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              } else {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which renders StrictMode children. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              }
            }
          }

          return hostFiber.stateNode;
        }
        return findHostInstance(component);
      }

      function createContainer(containerInfo, isConcurrent, hydrate) {
        return createFiberRoot(containerInfo, isConcurrent, hydrate);
      }

      function updateContainer(element, container, parentComponent, callback) {
        var current$$1 = container.current;
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, current$$1);
        return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
      }

      function getPublicRootInstance(container) {
        var containerFiber = container.current;

        if (!containerFiber.child) {
          return null;
        }

        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);

          default:
            return containerFiber.child.stateNode;
        }
      }

      var overrideProps = null;
      {
        var copyWithSetImpl = function copyWithSetImpl(obj, path, idx, value) {
          if (idx >= path.length) {
            return value;
          }

          var key = path[idx];
          var updated = Array.isArray(obj) ? obj.slice() : _extends({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
          return updated;
        };

        var copyWithSet = function copyWithSet(obj, path, value) {
          return copyWithSetImpl(obj, path, 0, value);
        };

        overrideProps = function overrideProps(fiber, path, value) {
          flushPassiveEffects();
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);

          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }

          scheduleWork(fiber, Sync);
        };
      }

      function injectIntoDevTools(devToolsConfig) {
        var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals(_extends({}, devToolsConfig, {
          overrideProps: overrideProps,
          currentDispatcherRef: ReactCurrentDispatcher,
          findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);

            if (hostFiber === null) {
              return null;
            }

            return hostFiber.stateNode;
          },
          findFiberByHostInstance: function findFiberByHostInstance(instance) {
            if (!_findFiberByHostInstance) {
              return null;
            }

            return _findFiberByHostInstance(instance);
          }
        }));
      }

      function _createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children: children,
          containerInfo: containerInfo,
          implementation: implementation
        };
      }

      var ReactVersion = "16.8.3";

      var NativeMethodsMixin = function NativeMethodsMixin(findNodeHandle, findHostInstance) {
        var NativeMethodsMixin = {
          measure: function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureInWindow: function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          },
          setNativeProps: function setNativeProps(nativeProps) {
            {
              if (warnAboutDeprecatedSetNativeProps) {
                warningWithoutStack$1(false, "Warning: Calling ref.setNativeProps(nativeProps) " + "is deprecated and will be removed in a future release. " + "Use the setNativeProps export from the react-native package instead." + "\n\timport {setNativeProps} from 'react-native';\n\tsetNativeProps(ref, nativeProps);\n");
              }
            }
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var nativeTag = maybeInstance._nativeTag || maybeInstance.canonical._nativeTag;
            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            {
              warnForStyleProps(nativeProps, viewConfig.validAttributes);
            }
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          },
          focus: function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          },
          blur: function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          }
        };
        {
          var NativeMethodsMixin_DEV = NativeMethodsMixin;
          invariant(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps && !NativeMethodsMixin_DEV.UNSAFE_componentWillMount && !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps, "Do not override existing functions.");

          NativeMethodsMixin_DEV.componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;
          NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;
        }
        return NativeMethodsMixin;
      };

      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var ReactNativeComponent = function ReactNativeComponent(findNodeHandle, findHostInstance) {
        var ReactNativeComponent = function (_React$Component) {
          _inherits(ReactNativeComponent, _React$Component);

          function ReactNativeComponent() {
            _classCallCheck$1(this, ReactNativeComponent);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
          }

          ReactNativeComponent.prototype.blur = function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.focus = function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.measure = function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureInWindow = function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          };

          ReactNativeComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
            {
              if (warnAboutDeprecatedSetNativeProps) {
                warningWithoutStack$1(false, "Warning: Calling ref.setNativeProps(nativeProps) " + "is deprecated and will be removed in a future release. " + "Use the setNativeProps export from the react-native package instead." + "\n\timport {setNativeProps} from 'react-native';\n\tsetNativeProps(ref, nativeProps);\n");
              }
            }
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var nativeTag = maybeInstance._nativeTag || maybeInstance.canonical._nativeTag;
            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          };

          return ReactNativeComponent;
        }(React.Component);

        return ReactNativeComponent;
      };

      var instanceCache = {};

      function getInstanceFromTag(tag) {
        return instanceCache[tag] || null;
      }

      var emptyObject$1 = {};
      {
        Object.freeze(emptyObject$1);
      }
      var getInspectorDataForViewTag = void 0;
      {
        var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {
          if (instance) {
            hierarchy.unshift(instance);
            traverseOwnerTreeUp(hierarchy, instance._debugOwner);
          }
        };

        var getOwnerHierarchy = function getOwnerHierarchy(instance) {
          var hierarchy = [];
          traverseOwnerTreeUp(hierarchy, instance);
          return hierarchy;
        };

        var lastNonHostInstance = function lastNonHostInstance(hierarchy) {
          for (var i = hierarchy.length - 1; i > 1; i--) {
            var instance = hierarchy[i];

            if (instance.tag !== HostComponent) {
              return instance;
            }
          }

          return hierarchy[0];
        };

        var getHostProps = function getHostProps(fiber) {
          var host = findCurrentHostFiber(fiber);

          if (host) {
            return host.memoizedProps || emptyObject$1;
          }

          return emptyObject$1;
        };

        var getHostNode = function getHostNode(fiber, findNodeHandle) {
          var hostNode = void 0;

          while (fiber) {
            if (fiber.stateNode !== null && fiber.tag === HostComponent) {
              hostNode = findNodeHandle(fiber.stateNode);
            }

            if (hostNode) {
              return hostNode;
            }

            fiber = fiber.child;
          }

          return null;
        };

        var createHierarchy = function createHierarchy(fiberHierarchy) {
          return fiberHierarchy.map(function (fiber) {
            return {
              name: getComponentName(fiber.type),
              getInspectorData: function getInspectorData(findNodeHandle) {
                return {
                  measure: function measure(callback) {
                    return UIManager.measure(getHostNode(fiber, findNodeHandle), callback);
                  },
                  props: getHostProps(fiber),
                  source: fiber._debugSource
                };
              }
            };
          });
        };

        getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {
          var closestInstance = getInstanceFromTag(viewTag);

          if (!closestInstance) {
            return {
              hierarchy: [],
              props: emptyObject$1,
              selection: null,
              source: null
            };
          }

          var fiber = findCurrentFiberUsingSlowPath(closestInstance);
          var fiberHierarchy = getOwnerHierarchy(fiber);
          var instance = lastNonHostInstance(fiberHierarchy);
          var hierarchy = createHierarchy(fiberHierarchy);
          var props = getHostProps(instance);
          var source = instance._debugSource;
          var selection = fiberHierarchy.indexOf(instance);
          return {
            hierarchy: hierarchy,
            props: props,
            selection: selection,
            source: source
          };
        };
      }

      function setNativeProps(handle, nativeProps) {
        if (handle._nativeTag == null) {
          !(handle._nativeTag != null) ? warningWithoutStack$1(false, "setNativeProps was called with a ref that isn't a " + "native component. Use React.forwardRef to get access to the underlying native component") : void 0;
          return;
        }

        {
          warnForStyleProps(nativeProps, handle.viewConfig.validAttributes);
        }
        var updatePayload = create(nativeProps, handle.viewConfig.validAttributes);

        if (updatePayload != null) {
          UIManager.updateView(handle._nativeTag, handle.viewConfig.uiViewClassName, updatePayload);
        }
      }

      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;

      function findNodeHandle(componentOrHandle) {
        {
          var owner = ReactCurrentOwner.current;

          if (owner !== null && owner.stateNode !== null) {
            !owner.stateNode._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing findNodeHandle inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(owner.type) || "A component") : void 0;
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }

        if (componentOrHandle == null) {
          return null;
        }

        if (typeof componentOrHandle === "number") {
          return componentOrHandle;
        }

        if (componentOrHandle._nativeTag) {
          return componentOrHandle._nativeTag;
        }

        if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
          return componentOrHandle.canonical._nativeTag;
        }

        var hostInstance = void 0;
        {
          hostInstance = findHostInstanceWithWarning(componentOrHandle, "findNodeHandle");
        }

        if (hostInstance == null) {
          return hostInstance;
        }

        if (hostInstance.canonical) {
          return hostInstance.canonical._nativeTag;
        }

        return hostInstance._nativeTag;
      }

      setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);
      var roots = new Map();
      var ReactFabric = {
        NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),
        findNodeHandle: findNodeHandle,
        setNativeProps: setNativeProps,
        render: function render(element, containerTag, callback) {
          var root = roots.get(containerTag);

          if (!root) {
            root = createContainer(containerTag, false, false);
            roots.set(containerTag, root);
          }

          updateContainer(element, root, null, callback);
          return getPublicRootInstance(root);
        },
        unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
          var root = roots.get(containerTag);

          if (root) {
            updateContainer(null, root, null, function () {
              roots.delete(containerTag);
            });
          }
        },
        createPortal: function createPortal(children, containerTag) {
          var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return _createPortal(children, containerTag, null, key);
        },
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
          NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance)
        }
      };
      injectIntoDevTools({
        findFiberByHostInstance: getInstanceFromInstance,
        getInspectorDataForViewTag: getInspectorDataForViewTag,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-native-renderer"
      });
      var ReactFabric$2 = Object.freeze({
        default: ReactFabric
      });
      var ReactFabric$3 = ReactFabric$2 && ReactFabric || ReactFabric$2;
      var fabric = ReactFabric$3.default || ReactFabric$3;
      module.exports = fabric;
    })();
  }
},"system_2d01160272669884793b18983a46dcd0_node_modules_react-native_Libraries_Renderer_oss_ReactFabric-dev.js",["node_modules_@babel_runtime_helpers_extends.js","node_modules_react-native_Libraries_Core_InitializeCore.js","node_modules_react-native_Libraries_Renderer_shims_ReactNativeViewConfigRegistry.js","node_modules_react-native_Libraries_ReactNative_UIManager.js","node_modules_react_index.js","node_modules_react-native_Libraries_Utilities_differ_deepDiffer.js","node_modules_react-native_Libraries_StyleSheet_flattenStyle.js","node_modules_react-native_Libraries_Utilities_deepFreezeAndThrowOnMutationInDev.js","node_modules_react-native_Libraries_Components_TextInput_TextInputState.js","node_modules_react-native_Libraries_ReactNative_FabricUIManager.js","system_2d01160272669884793b18983a46dcd0_node_modules_prop-types_checkPropTypes.js","system_2d01160272669884793b18983a46dcd0_node_modules_scheduler_tracing.js","node_modules_scheduler_index.js","node_modules_react-native_Libraries_Core_ExceptionsManager.js"],"node_modules/react-native/Libraries/Renderer/oss/ReactFabric-dev.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _get2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/getPrototypeOf"));

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[8], "orionos-eve-core");

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react"));

  var _HeadTurnScreen = _$$_REQUIRE(_dependencyMap[10], "./demo/HeadTurnScreen");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/App.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var App = function (_BaseComponent) {
    (0, _inherits2.default)(App, _BaseComponent);

    var _super = _createSuper(App);

    function App(props) {
      (0, _classCallCheck2.default)(this, App);
      return _super.call(this, props);
    }

    (0, _createClass2.default)(App, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(App.prototype), "componentDidMount", this).call(this);
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        console.log();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(App.prototype), "componentWillUnmount", this).call(this);
      }
    }, {
      key: "render",
      value: function render() {
        return _react.default.createElement(_HeadTurnScreen.HeadTurnScreen, (0, _extends2.default)({}, this.props, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 27,
            columnNumber: 17
          }
        }));
      }
    }]);
    return App;
  }(_orionosEveCore.BaseComponent);

  exports.default = App;
},"system_2d01160272669884793b18983a46dcd0_app_App.js",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_extends.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_get.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","node_modules_react_index.js","system_2d01160272669884793b18983a46dcd0_app_demo_HeadTurnScreen.tsx"],"app/App.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeadTurnScreen = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _get2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/get"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf"));

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react"));

  var _mobxReact = _$$_REQUIRE(_dependencyMap[9], "mobx-react");

  var _reactNative = _$$_REQUIRE(_dependencyMap[10], "react-native");

  var _HeadTurnViewModel = _$$_REQUIRE(_dependencyMap[11], "../headTurn/HeadTurnViewModel");

  var _BasicMotionViewModel = _$$_REQUIRE(_dependencyMap[12], "../basicMotion/BasicMotionViewModel");

  var _StandardFaceTrackViewModel = _$$_REQUIRE(_dependencyMap[13], "../standardFaceTrack/StandardFaceTrackViewModel");

  var _ChargeStartViewModel = _$$_REQUIRE(_dependencyMap[14], "../chargeStart/ChargeStartViewModel");

  var _MapViewModel = _$$_REQUIRE(_dependencyMap[15], "../map/MapViewModel");

  var _NavigationViewModel = _$$_REQUIRE(_dependencyMap[16], "../navigation/NavigationViewModel");

  var _PersonAppearViewModel = _$$_REQUIRE(_dependencyMap[17], "../personAppear/PersonAppearViewModel");

  var _HeadTurnVoice = _$$_REQUIRE(_dependencyMap[18], "./HeadTurnVoice");

  var _HeadTurnTrigger = _$$_REQUIRE(_dependencyMap[19], "./HeadTurnTrigger");

  var _HeadTurnView = _$$_REQUIRE(_dependencyMap[20], "../headTurn/HeadTurnView");

  var _BasicMotionView = _$$_REQUIRE(_dependencyMap[21], "../basicMotion/BasicMotionView");

  var _StandardFaceTrackView = _$$_REQUIRE(_dependencyMap[22], "../standardFaceTrack/StandardFaceTrackView");

  var _ChargeStartView = _$$_REQUIRE(_dependencyMap[23], "../chargeStart/ChargeStartView");

  var _NavigationView = _$$_REQUIRE(_dependencyMap[24], "../navigation/NavigationView");

  var _PersonAppearView = _$$_REQUIRE(_dependencyMap[25], "../personAppear/PersonAppearView");

  var _ThirdApkInfo = _$$_REQUIRE(_dependencyMap[26], "../biz/base/ThirdApkInfo");

  var _class,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/demo/HeadTurnScreen.tsx";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  _orionosEveCore.triggerManager.addTrigger(new _HeadTurnTrigger.HeadTurnTrigger());

  var TAG = 'shadow_opk_for_android----shadow_opk_for_android DemoScreen.tsx';
  var FORWARD_SPEED = 0.1;
  var BACKWARD_SPEED = -0.1;
  var LEFT_SPEED = 0.1;
  var RIGHT_SPEED = -0.1;
  var SPEED_NONE = 0;

  var HeadTurnScreen = (0, _mobxReact.observer)(_class = function (_BaseComponent) {
    (0, _inherits2.default)(HeadTurnScreen, _BaseComponent);

    var _super = _createSuper(HeadTurnScreen);

    function HeadTurnScreen(props) {
      var _this;

      (0, _classCallCheck2.default)(this, HeadTurnScreen);
      _this = _super.call(this, props);
      _this.return_obj = {
        "command": "",
        "text": "",
        "code": -1,
        "messaage": ""
      };

      _this.initListener = function () {
        _this.nlpApkControlListener = new _orionosEveCore.NLPApkControlListener();

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_APP_NOT_RESPONDING, function (event) {
          console.log(TAG, 'EVENT_ON_APP_NOT_RESPONDING:' + JSON.stringify(event));
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_TRIGGER_COMMAND, function (event) {
          console.log(TAG, 'EVENT_ON_TRIGGER_COMMAND:' + JSON.stringify(event));

          if (event.eventdata) {
            var eventDataObj = JSON.parse(event.eventdata);

            if (eventDataObj.command === "headUp") {
              console.log(TAG, '1:' + JSON.stringify(event));
              var text = eventDataObj.text;

              _this.viewModel.setHeadAction("head");

              var hMode = 'relative';
              var hAngle = 0;
              var vMode = 'relative';
              var vAngle = -10;

              if (eventDataObj.params !== "") {
                hMode = eventDataObj.params.hMode;
                hAngle = eventDataObj.params.hAngle;
                vMode = eventDataObj.params.vMode;
                vAngle = eventDataObj.params.vAngle;
              }

              _this.viewModel.onPressHeadUp(hMode, hAngle, vMode, vAngle);
            } else if (eventDataObj.command === "headDown") {
              console.log(TAG, '2:' + JSON.stringify(event));
              var _text = eventDataObj.text;

              _this.viewModel.setHeadAction("head");

              var _hMode = 'relative';
              var _hAngle = 0;
              var _vMode = 'relative';
              var _vAngle = 10;

              if (eventDataObj.params !== "") {
                _hMode = eventDataObj.params.hMode;
                _hAngle = eventDataObj.params.hAngle;
                _vMode = eventDataObj.params.vMode;
                _vAngle = eventDataObj.params.vAngle;
              }

              _this.viewModel.onPressHeadDown(_hMode, _hAngle, _vMode, _vAngle);
            } else if (eventDataObj.command === "headLeft") {
              console.log(TAG, '3:' + JSON.stringify(event));
              var _text2 = eventDataObj.text;

              _this.viewModel.setHeadAction("head");

              var _hMode2 = 'relative';

              var _hAngle2 = -30;

              var _vMode2 = 'relative';
              var _vAngle2 = 0;

              if (eventDataObj.params !== "") {
                _hMode2 = eventDataObj.params.hMode;
                _hAngle2 = eventDataObj.params.hAngle;
                _vMode2 = eventDataObj.params.vMode;
                _vAngle2 = eventDataObj.params.vAngle;
              }

              _this.viewModel.onPressTurnLeft(_hMode2, _hAngle2, _vMode2, _vAngle2);
            } else if (eventDataObj.command === "headRight") {
              console.log(TAG, '4:' + JSON.stringify(event));
              var _text3 = eventDataObj.text;

              _this.viewModel.setHeadAction("head");

              var _hMode3 = 'relative';
              var _hAngle3 = 30;
              var _vMode3 = 'relative';
              var _vAngle3 = 0;

              if (eventDataObj.params !== "") {
                _hMode3 = eventDataObj.params.hMode;
                _hAngle3 = eventDataObj.params.hAngle;
                _vMode3 = eventDataObj.params.vMode;
                _vAngle3 = eventDataObj.params.vAngle;
              }

              _this.viewModel.onPressTurnRight(_hMode3, _hAngle3, _vMode3, _vAngle3);
            } else if (eventDataObj.command === "bodyForward") {
              console.log(TAG, '5:' + JSON.stringify(event));
              var _text4 = eventDataObj.text;

              _orionosEveCore.speechApi.playText(-1, _text4);

              var lineSpeed = FORWARD_SPEED;
              var angularSpeed = 0;

              if (eventDataObj.params !== "") {
                lineSpeed = eventDataObj.params.lineSpeed;
                angularSpeed = eventDataObj.params.angularSpeed;
              }

              _orionosEveCore.RobotApi.motionArcWithObstacles(_this.callback ? _this.callback.getId() : -1, lineSpeed, angularSpeed);

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = _this.callback ? _this.callback.getId() : -1;
              var result = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);
            } else if (eventDataObj.command === "bodyBack") {
              console.log(TAG, '6:' + JSON.stringify(event));
              var _text5 = eventDataObj.text;

              _orionosEveCore.speechApi.playText(-1, _text5);

              var _lineSpeed = BACKWARD_SPEED;
              var _angularSpeed = 0;

              if (eventDataObj.params !== "") {
                _lineSpeed = eventDataObj.params.lineSpeed;
                _angularSpeed = eventDataObj.params.angularSpeed;
              }

              _orionosEveCore.RobotApi.motionArcWithObstacles(_this.callback ? _this.callback.getId() : -1, _lineSpeed, _angularSpeed);

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = _this.callback ? _this.callback.getId() : -1;

              var _result = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _result);
            } else if (eventDataObj.command === "bodyLeft") {
              console.log(TAG, '7:' + JSON.stringify(event));
              var _text6 = eventDataObj.text;

              _orionosEveCore.speechApi.playText(-1, _text6);

              var _lineSpeed2 = 0;
              var _angularSpeed2 = LEFT_SPEED;

              if (eventDataObj.params !== "") {
                _lineSpeed2 = eventDataObj.params.lineSpeed;
                _angularSpeed2 = eventDataObj.params.angularSpeed;
              }

              _orionosEveCore.RobotApi.motionArcWithObstacles(_this.callback ? _this.callback.getId() : -1, _lineSpeed2, _angularSpeed2);

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = _this.callback ? _this.callback.getId() : -1;

              var _result2 = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _result2);
            } else if (eventDataObj.command === "bodyRight") {
              console.log(TAG, '8:' + JSON.stringify(event));
              var _text7 = eventDataObj.text;

              _orionosEveCore.speechApi.playText(-1, _text7);

              var _lineSpeed3 = 0;
              var _angularSpeed3 = RIGHT_SPEED;

              if (eventDataObj.params !== "") {
                _lineSpeed3 = eventDataObj.params.lineSpeed;
                _angularSpeed3 = eventDataObj.params.angularSpeed;
              }

              _orionosEveCore.RobotApi.motionArcWithObstacles(_this.callback ? _this.callback.getId() : -1, _lineSpeed3, _angularSpeed3);

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = _this.callback ? _this.callback.getId() : -1;

              var _result3 = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _result3);
            } else if (eventDataObj.command === "bodyStop") {
              console.log(TAG, '9:' + JSON.stringify(event));
              var _text8 = eventDataObj.text;
              var _lineSpeed4 = SPEED_NONE;
              var _angularSpeed4 = SPEED_NONE;

              _orionosEveCore.RobotApi.motionArcWithObstacles(_this.callback ? _this.callback.getId() : -1, _lineSpeed4, _angularSpeed4);

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = _this.callback ? _this.callback.getId() : -1;

              var _result4 = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _result4);
            } else if (eventDataObj.command === "traceFace") {
              console.log(TAG, '10:' + JSON.stringify(event));
              var _text9 = eventDataObj.text;

              _this.viewModel.setHeadAction("face");

              _this.fviewModel.onPressHeadUp();
            } else if (eventDataObj.command === "stopTraceFace") {
              console.log(TAG, '11:' + JSON.stringify(event));
              var _text10 = eventDataObj.text;

              _this.fviewModel.onPressHeadDown();

              _this.viewModel.setHeadAction("exit");
            } else if (eventDataObj.command === "map") {
              console.log(TAG, '12:' + JSON.stringify(event));

              _this.viewModel.setHeadAction("mapSite");

              _this.mviewModel.getCurrPose().then(function (return_obj) {
                console.log("输出当前坐标信息：" + return_obj);
                var result = JSON.stringify(return_obj);
                console.log("输出当前坐标数据信息：" + result);

                _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);
              });
            } else if (eventDataObj.command === "currentPosition") {
              console.log(TAG, '121:' + JSON.stringify(event));

              _this.mviewModel.getCurrPosition().then(function (return_obj) {
                console.log("输出当前坐标信息(不包含站点列表数据信息)：" + return_obj);
                var result = JSON.stringify(return_obj);
                console.log("输出当前坐标数据信息（字符串，不包含站点列表数据信息）：" + result);

                _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);
              });
            } else if (eventDataObj.command === "gotoMapSite") {
              console.log(TAG, '13:' + JSON.stringify(event));
              var _text11 = eventDataObj.text;

              _this.viewModel.setHeadAction("mapSite");

              _this.nviewModel.onPressStartNavigation(_text11);
            } else if (eventDataObj.command === "stopMapSite") {
              console.log(TAG, '14:' + JSON.stringify(event));

              _this.nviewModel.onPressStopNavigation();

              _this.viewModel.setHeadAction("exit");
            } else if (eventDataObj.command === "speechPlay") {
              console.log(TAG, '15:' + JSON.stringify(event));
              var _text12 = eventDataObj.text;

              _orionosEveCore.speechApi.playText(-1, _text12);

              _this.viewModel.setHeadAction("exit");

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = 1;

              var _result5 = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _result5);
            } else if (eventDataObj.command === "speechStop") {
              console.log(TAG, '1:' + JSON.stringify(event));
              var _text13 = eventDataObj.text;

              _orionosEveCore.speechApi.stopTTS();

              _this.viewModel.setHeadAction("exit");

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = 1;

              var _result6 = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _result6);
            } else if (eventDataObj.command === "speechQuery") {
              console.log(TAG, '16:' + JSON.stringify(event));
              var _text14 = eventDataObj.text;

              _orionosEveCore.speechApi.queryByText(_text14);

              _this.viewModel.setHeadAction("exit");

              _this.return_obj.command = eventDataObj.command;
              _this.return_obj.text = eventDataObj.text;
              _this.return_obj.code = 1;

              var _result7 = JSON.stringify(_this.return_obj);

              _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _result7);
            } else if (eventDataObj.command === "startCharge") {
              console.log(TAG, '17:' + JSON.stringify(event));
              console.log("开始充电");

              _this.viewModel.setHeadAction("charge");

              _this.cviewModel.onPressStartChargeStart();
            } else if (eventDataObj.command === "stopCharge") {
              console.log(TAG, '18:' + JSON.stringify(event));
              console.log("停止充电");

              _this.cviewModel.onPressStopChargeStart();

              _this.viewModel.setHeadAction("exit");
            } else if (eventDataObj.command === "triggerToOpk") {
              console.log(TAG, '19:' + JSON.stringify(event));
              console.log("OPK页面跳转操作");

              _this.triggerToOpk(eventDataObj.jumpNum);
            } else if (eventDataObj.command === "startPersonAppear") {
              console.log(TAG, '20:' + JSON.stringify(event));
              console.log("开始根据条件找人");

              _this.viewModel.setHeadAction("personAppear");

              _this.pviewModel.onPressStartPersonAppear();
            } else if (eventDataObj.command === "stopPersonAppear") {
              console.log(TAG, '21:' + JSON.stringify(event));
              console.log("停止根据条件找人");

              _this.pviewModel.onPressFinishPersonAppear();

              _this.viewModel.setHeadAction("exit");
            } else if (eventDataObj.command === "exit") {
              console.log(TAG, '22:' + JSON.stringify(event));
              console.log("退出操作");

              _this.goHome(_this.viewModel.getTriggerNum());
            }
          }
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_DATA_UPDATE, function (event) {
          console.log(TAG, 'EVENT_ON_DATA_UPDATE:' + JSON.stringify(event));
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_PAGE_STATE_CHANGED, function (event) {
          console.log(TAG, 'EVENT_ON_PAGE_STATE_CHANGED:' + JSON.stringify(event));
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_PLAY_STATE_CHANGED, function (event) {
          console.log(TAG, 'EVENT_ON_PLAY_STATE_CHANGED:' + JSON.stringify(event));
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_PROCESS_DIED, function (event) {
          console.log(TAG, 'EVENT_ON_PROCESS_DIED:' + JSON.stringify(event));

          _this.goHome(_this.viewModel.getTriggerNum());
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_TOPACTIVITY_CHANGED, function (event) {
          console.log(TAG, 'EVENT_ON_TOPACTIVITY_CHANGED:' + JSON.stringify(event));
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_PROCESS_VISIBLE, function (event) {
          console.log(TAG, 'EVENT_ON_PROCESS_VISIBLE:' + JSON.stringify(event));
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_PROCESS_INVISIBLE, function (event) {
          console.log(TAG, 'EVENT_ON_PROCESS_INVISIBLE:' + JSON.stringify(event));

          _orionosEveCore.NLPApkControl.forceStopPackage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME);

          _this.goHome(_this.viewModel.getTriggerNum());
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_SERVICE_CONNECTED, function (event) {
          console.log(TAG, 'EVENT_ON_SERVICE_CONNECTED:' + JSON.stringify(event));
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_SERVICE_DISCONNECTED, function (event) {
          console.log(TAG, 'EVENT_ON_SERVICE_DISCONNECTED:' + JSON.stringify(event));

          _this.goHome(_this.viewModel.getTriggerNum());
        });

        _this.nlpApkControlListener.addListener(_orionosEveCore.NLPApkControlListener.EVENT_ON_ROBOT_MESSENGER_READY, function (event) {
          console.log(TAG, 'EVENT_ON_SERVICE_MESSENGER_READY:' + JSON.stringify(event));
          var params_to_apk = _this.props.navigation.state.params.result;
          var re_result = JSON.stringify(params_to_apk);

          _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, re_result);
        });

        _orionosEveCore.NLPApkControl.addListener(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _this.nlpApkControlListener.getId());
      };

      _this.triggerToOpk = function (jumpNum) {
        console.log(TAG, '跳转到wakeUp页面' + jumpNum);

        _this.viewModel.setTriggerNum(jumpNum);

        console.log(TAG, '跳转到wakeUp页面1');
        _this.return_obj.command = "shutDownAPP" + jumpNum;
        _this.return_obj.text = "need close the running's app";
        _this.return_obj.code = 1;
        var result = JSON.stringify(_this.return_obj);

        _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);

        console.log(TAG, '跳转到wakeUp页面2');
      };

      _this.nlpApkControlListener = new _orionosEveCore.NLPApkControlListener();

      _this.initListener();

      _this.viewModel = new _HeadTurnViewModel.HeadTurnViewModel();
      _this.bviewModel = new _BasicMotionViewModel.BasicMotionViewModel();
      _this.fviewModel = new _StandardFaceTrackViewModel.StandardFaceTrackViewModel();
      _this.cviewModel = new _ChargeStartViewModel.ChargeStartViewModel();
      _this.mviewModel = new _MapViewModel.MapViewModel();
      _this.nviewModel = new _NavigationViewModel.NavigationViewModel();
      _this.pviewModel = new _PersonAppearViewModel.PersonAppearViewModel();
      var voice = new _HeadTurnVoice.HeadTurnVoice(_this.viewModel);

      _this.setViewModel(_this.viewModel);

      _this.setVoice(voice);

      _this.callback = new _orionosEveCore.CommandListener();

      _this.callback.addListener(_orionosEveCore.CommandListener.EVENT_RESULT, function (result) {
        console.log(TAG, 'motionArcWithObstacles onResult', result);
      });

      _this.callback.addListener(_orionosEveCore.CommandListener.EVENT_ONFINISH, function (result) {
        console.log(TAG, 'motionArcWithObstacles onFinish', result);
      });

      _this.callback.addListener(_orionosEveCore.CommandListener.EVENT_STATUSUPDATE, function (result) {
        console.log(TAG, 'motionArcWithObstacles onStatusUpdate', result);
      });

      return _this;
    }

    (0, _createClass2.default)(HeadTurnScreen, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(HeadTurnScreen.prototype), "componentWillUnmount", this).call(this);
        var obj = {
          "intent": "stop"
        };

        _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, JSON.stringify(obj));
      }
    }, {
      key: "goHome",
      value: function goHome(jumpNum) {
        console.log(TAG, '跳转到gohome页面');
        this.viewModel.setHeadAction("exit");

        _reactNative.DeviceEventEmitter.emit("gohome", 0);

        this.nlpApkControlListener && this.nlpApkControlListener.removeListener();
        this.viewModel.cancelCommand(jumpNum);
      }
    }, {
      key: "render",
      value: function render() {
        console.log('进入到了render方法' + "     getHeadAction方法获取的内容=====：" + this.viewModel.getHeadAction());

        if (this.viewModel.getHeadAction() == "") {
          var params_to_apk = this.props.navigation.state.params.result;
          this.viewModel.conDoctor(params_to_apk);
          return null;
        } else if (this.viewModel.getHeadAction() == "head") {
          if (!this.viewModel) {
            return null;
          }

          console.log("进入到了render的0里面");
          return _react.default.createElement(_react.default.Fragment, null, this.viewModel.isRunning() ? _react.default.createElement(_orionosEveCore.HeadTurnComponent, {
            param: this.viewModel.getHeadParam(),
            onStatusUpdate: this.viewModel && this.viewModel.onStatusUpdate,
            onFinish: this.viewModel && this.viewModel.onFinish,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 654,
              columnNumber: 25
            }
          }) : null, _react.default.createElement(_HeadTurnView.HeadTurnView, {
            viewModel: this.viewModel,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 660,
              columnNumber: 21
            }
          }));
        } else if (this.viewModel.getHeadAction() == "body") {
          if (!this.bviewModel) {
            return null;
          }

          console.log("进入到了render的1里面");
          return _react.default.createElement(_react.default.Fragment, null, this.bviewModel.isRunning() ? _react.default.createElement(_orionosEveCore.BasicMotionComponent, {
            param: this.bviewModel.getParam(),
            onFinish: this.bviewModel && this.bviewModel.onFinish,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 672,
              columnNumber: 25
            }
          }) : null, _react.default.createElement(_BasicMotionView.BasicMotionView, {
            viewModel: this.bviewModel,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 677,
              columnNumber: 21
            }
          }));
        } else if (this.viewModel.getHeadAction() == "face") {
          if (!this.fviewModel) {
            return null;
          }

          console.log("进入到了render的2里面");
          return _react.default.createElement(_react.default.Fragment, null, this.fviewModel.isRunning() ? _react.default.createElement(_orionosEveCore.StandardFaceTrackComponent, {
            param: this.fviewModel.getParam(),
            onStatusUpdate: this.fviewModel && this.fviewModel.onStatusUpdate,
            onFinish: this.fviewModel && this.fviewModel.onFinish,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 689,
              columnNumber: 25
            }
          }) : null, _react.default.createElement(_StandardFaceTrackView.StandardFaceTrackView, {
            viewModel: this.fviewModel,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 695,
              columnNumber: 21
            }
          }));
        } else if (this.viewModel.getHeadAction() == "charge") {
          if (!this.cviewModel) {
            return null;
          }

          console.log("进入到了render的3里面");
          return _react.default.createElement(_react.default.Fragment, null, this.cviewModel.isRunning() ? _react.default.createElement(_orionosEveCore.ChargeStartComponent, {
            param: this.cviewModel.getParam(),
            onStatusUpdate: this.cviewModel && this.cviewModel.onStatusUpdate,
            onFinish: this.cviewModel && this.cviewModel.onFinish,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 707,
              columnNumber: 25
            }
          }) : null, _react.default.createElement(_ChargeStartView.ChargeStartView, {
            viewModel: this.cviewModel,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 713,
              columnNumber: 21
            }
          }));
        } else if (this.viewModel.getHeadAction() == "mapSite") {
          if (!this.nviewModel) {
            return null;
          }

          return _react.default.createElement(_react.default.Fragment, null, this.nviewModel.isRunning() ? _react.default.createElement(_orionosEveCore.NavigationComponent, {
            param: this.nviewModel.getParam(),
            onStatusUpdate: this.nviewModel && this.nviewModel.onStatusUpdate,
            onFinish: this.nviewModel && this.nviewModel.onFinish,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 724,
              columnNumber: 25
            }
          }) : null, _react.default.createElement(_NavigationView.NavigationView, {
            viewModel: this.nviewModel,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 730,
              columnNumber: 21
            }
          }));
        } else if (this.viewModel.getHeadAction() == "personAppear") {
          if (!this.pviewModel) {
            return null;
          }

          console.log("人脸识别 render方法");
          return _react.default.createElement(_react.default.Fragment, null, this.pviewModel.isRunning() ? _react.default.createElement(_orionosEveCore.PersonAppearComponent, {
            param: this.pviewModel.getParam(),
            onFinish: this.pviewModel && this.pviewModel.onFinish,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 742,
              columnNumber: 25
            }
          }) : _react.default.createElement(_reactNative.View, {
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 745,
              columnNumber: 25
            }
          }, _react.default.createElement(_reactNative.Text, {
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 745,
              columnNumber: 31
            }
          }, "\u8FDB\u5165\u5230\u4E86personAppear\u7684else\u7684\u65B9\u6CD5\u91CC\u9762")), _react.default.createElement(_PersonAppearView.PersonAppearView, {
            viewModel: this.pviewModel,
            __self: this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 747,
              columnNumber: 21
            }
          }));
        } else if (this.viewModel.getHeadAction() == "exit") {
          console.log("进入到了render的null里面");
          return null;
        }
      }
    }]);
    return HeadTurnScreen;
  }(_orionosEveCore.BaseComponent)) || _class;

  exports.HeadTurnScreen = HeadTurnScreen;
},"system_2d01160272669884793b18983a46dcd0_app_demo_HeadTurnScreen.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_get.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","node_modules_react_index.js","node_modules_mobx-react_native.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","system_2d01160272669884793b18983a46dcd0_app_headTurn_HeadTurnViewModel.ts","system_2d01160272669884793b18983a46dcd0_app_basicMotion_BasicMotionViewModel.ts","system_2d01160272669884793b18983a46dcd0_app_standardFaceTrack_StandardFaceTrackViewModel.ts","system_2d01160272669884793b18983a46dcd0_app_chargeStart_ChargeStartViewModel.ts","system_2d01160272669884793b18983a46dcd0_app_map_MapViewModel.ts","system_2d01160272669884793b18983a46dcd0_app_navigation_NavigationViewModel.ts","system_2d01160272669884793b18983a46dcd0_app_personAppear_PersonAppearViewModel.ts","system_2d01160272669884793b18983a46dcd0_app_demo_HeadTurnVoice.ts","system_2d01160272669884793b18983a46dcd0_app_demo_HeadTurnTrigger.ts","system_2d01160272669884793b18983a46dcd0_app_headTurn_HeadTurnView.tsx","system_2d01160272669884793b18983a46dcd0_app_basicMotion_BasicMotionView.tsx","system_2d01160272669884793b18983a46dcd0_app_standardFaceTrack_StandardFaceTrackView.tsx","system_2d01160272669884793b18983a46dcd0_app_chargeStart_ChargeStartView.tsx","system_2d01160272669884793b18983a46dcd0_app_navigation_NavigationView.tsx","system_2d01160272669884793b18983a46dcd0_app_personAppear_PersonAppearView.tsx","system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts"],"app/demo/HeadTurnScreen.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeadTurnViewModel = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _reactNativeIntentLauncher = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react-native-intent-launcher"));

  var _mobx = _$$_REQUIRE(_dependencyMap[8], "mobx");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[9], "orionos-eve-core");

  var _HeadTurnModel = _$$_REQUIRE(_dependencyMap[10], "./HeadTurnModel");

  var _BasicMotionModel = _$$_REQUIRE(_dependencyMap[11], "../basicMotion/BasicMotionModel");

  var _ThirdApkInfo = _$$_REQUIRE(_dependencyMap[12], "../biz/base/ThirdApkInfo");

  var _class;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TAG = 'shadow_opk_for_android HeadTurnViewModel.ts';
  var HeadTurnViewModel = (_class = function (_BaseViewModel) {
    (0, _inherits2.default)(HeadTurnViewModel, _BaseViewModel);

    var _super = _createSuper(HeadTurnViewModel);

    function HeadTurnViewModel() {
      var _this;

      (0, _classCallCheck2.default)(this, HeadTurnViewModel);
      _this = _super.call(this, 'HeadTurn1199');
      _this.return_obj = {
        "command": "",
        "text": "",
        "code": -1,
        "messaage": ""
      };

      _this.triggerToOpk = function () {
        console.log(TAG, "trigger跳转到其他OPK页面");

        _this._apiTrigger(36362227, '');
      };

      _this.cancelCommand = function (jumpNum) {
        console.log(TAG, "退出");

        _this._apiTrigger(jumpNum, '');
      };

      _this.onPressHeadUp = function (hMode, hAngle, vMode, vAngle) {
        console.log("onPressHeadUp方法");

        _this.hModel.headUp(hMode, hAngle, vMode, vAngle);
      };

      _this.onPressHeadDown = function (hMode, hAngle, vMode, vAngle) {
        _this.hModel.headDown(hMode, hAngle, vMode, vAngle);
      };

      _this.onPressTurnLeft = function (hMode, hAngle, vMode, vAngle) {
        _this.hModel.turnLeft(hMode, hAngle, vMode, vAngle);
      };

      _this.onPressTurnRight = function (hMode, hAngle, vMode, vAngle) {
        _this.hModel.turnRight(hMode, hAngle, vMode, vAngle);
      };

      _this.onStatusUpdate = function (event) {
        if (event && event.status) {
          switch (event.status) {
            case _orionosEveCore.ComponentStatusConst.STATUS_HEAD_TURN_START:
              _this.hModel.appendResultText('STATUS_HEAD_TURN_START(' + event.status + '): 开始执行');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_TURN_HEAD_MAX_UP_ANGLE:
              _this.hModel.appendResultText('STATUS_TURN_HEAD_MAX_UP_ANGLE(' + event.status + '): 云台运动到了向上最大角度');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_TURN_HEAD_MAX_DOWN_ANGLE:
              _this.hModel.appendResultText('STATUS_TURN_HEAD_MAX_DOWN_ANGLE(' + event.status + '): 云台运动到了向下最大角度');

              break;

            default:
              _this.hModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.onFinish = function (event) {
        _this.hModel.finishRunning();

        if (event && event.status) {
          _this.return_obj.command = "headAction";
          _this.return_obj.text = "head action";
          _this.return_obj.code = event && event.status;
          var result = JSON.stringify(_this.return_obj);

          _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);

          console.log(TAG, "人脸追踪" + JSON.stringify(event));

          switch (event.status) {
            case _orionosEveCore.ComponentResultConst.RESULT_HEAD_TURN_SUCCESS:
              _this.hModel.appendResultText('RESULT_HEAD_TURN_SUCCESS(' + event.status + '): 执行完成');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_PARAMS_HEAD_TURN_BEAN_INVALID:
              _this.hModel.appendResultText('ERROR_PARAMS_HEAD_TURN_BEAN_INVALID(' + event.status + '): 参数无效');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_HEAD_TURN_TIMEOUT:
              _this.hModel.appendResultText('ERROR_HEAD_TURN_TIMEOUT(' + event.status + '): 执行超时');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_HEAD_TURN_FAILED:
              _this.hModel.appendResultText('ERROR_HEAD_TURN_FAILED(' + event.status + '): 执行失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_HEAD_TURN_INTERRUPT:
              _this.hModel.appendResultText('ERROR_HEAD_TURN_INTERRUPT(' + event.status + '): 执行被打断');

              break;

            default:
              _this.hModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.conDoctor = function (obj) {
        _reactNativeIntentLauncher.default.isAppInstalled(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME).then(function (result) {
          _orionosEveCore.OpenAppApi.openThirdPartyAppIfKillRnForResult(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, _ThirdApkInfo.ThirdApkInfo.MAIN_ACTIVITY, false).then(function () {});
        }).catch(function (error) {
          console.log(TAG, 'IntentLauncher isAppInstalled: no', error);

          _this._apiTrigger(1001, {});
        });

        return true;
      };

      _this.hModel = new _HeadTurnModel.HeadTurnModel();
      _this.bModel = new _BasicMotionModel.BasicMotionModel();
      return _this;
    }

    (0, _createClass2.default)(HeadTurnViewModel, [{
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onStop",
      value: function onStop() {}
    }, {
      key: "exit",
      value: function exit() {
        this._apiTrigger(1001, '');
      }
    }, {
      key: "showSpeechText",
      value: function showSpeechText(text) {
        console.log('DemoVoice : set ' + text);

        _HeadTurnModel.HeadTurnModel.setInfoText(text);
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        console.log("是否运动中。。。。");
        return this.hModel.isRunning();
      }
    }, {
      key: "getHeadParam",
      value: function getHeadParam() {
        console.log("有没有进入到获取参数里面");
        return this.hModel.getParam();
      }
    }, {
      key: "getBodyParam",
      value: function getBodyParam() {
        return this.bModel.getParam();
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.hModel.getResultText();
      }
    }, {
      key: "getHeadAction",
      value: function getHeadAction() {
        return this.hModel.getInfoText();
      }
    }, {
      key: "setHeadAction",
      value: function setHeadAction(infoText) {
        this.hModel.setInfoText(infoText);
      }
    }, {
      key: "setTriggerNum",
      value: function setTriggerNum(jumpNum) {
        this.hModel.setTriggerNum(jumpNum);
      }
    }, {
      key: "getTriggerNum",
      value: function getTriggerNum() {
        return this.hModel.getTriggerNum();
      }
    }]);
    return HeadTurnViewModel;
  }(_orionosEveCore.BaseViewModel), ((0, _applyDecoratedDescriptor2.default)(_class.prototype, "setHeadAction", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "setHeadAction"), _class.prototype)), _class);
  exports.HeadTurnViewModel = HeadTurnViewModel;
},"system_2d01160272669884793b18983a46dcd0_app_headTurn_HeadTurnViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_react-native-intent-launcher_index.js","node_modules_mobx_lib_mobx.module.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","system_2d01160272669884793b18983a46dcd0_app_headTurn_HeadTurnModel.ts","system_2d01160272669884793b18983a46dcd0_app_basicMotion_BasicMotionModel.ts","system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts"],"app/headTurn/HeadTurnViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeadTurnModel = void 0;

  var _initializerDefineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/initializerDefineProperty"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _initializerWarningHelper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/initializerWarningHelper"));

  var _mobx = _$$_REQUIRE(_dependencyMap[6], "mobx");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4;

  var HeadTurnModel = (_class = function () {
    function HeadTurnModel() {
      (0, _classCallCheck2.default)(this, HeadTurnModel);
      (0, _initializerDefineProperty2.default)(this, "mIsRunning", _descriptor, this);
      (0, _initializerDefineProperty2.default)(this, "mResultText", _descriptor2, this);
      (0, _initializerDefineProperty2.default)(this, "mHeadAction", _descriptor3, this);
      (0, _initializerDefineProperty2.default)(this, "triggerNumber", _descriptor4, this);
      this.mHeadTurnParam = new _orionosEveCore.HeadTurnParam();
    }

    (0, _createClass2.default)(HeadTurnModel, [{
      key: "headUp",
      value: function headUp(hMode, hAngle, vMode, vAngle) {
        console.log("进入到了数据模型里面");
        this.mHeadTurnParam.horizontalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.horizontalAngle = 0;
        this.mHeadTurnParam.horizontalMaxSpeed = 30;
        this.mHeadTurnParam.verticalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.verticalAngle = -10;
        this.mHeadTurnParam.verticalMaxSpeed = 30;
        this.mIsRunning = true;
      }
    }, {
      key: "headDown",
      value: function headDown(hMode, hAngle, vMode, vAngle) {
        this.mHeadTurnParam.horizontalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.horizontalAngle = 0;
        this.mHeadTurnParam.horizontalMaxSpeed = 30;
        this.mHeadTurnParam.verticalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.verticalAngle = 10;
        this.mHeadTurnParam.verticalMaxSpeed = 30;
        this.mIsRunning = true;
      }
    }, {
      key: "turnLeft",
      value: function turnLeft(hMode, hAngle, vMode, vAngle) {
        this.mHeadTurnParam.horizontalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.horizontalAngle = -30;
        this.mHeadTurnParam.horizontalMaxSpeed = 30;
        this.mHeadTurnParam.verticalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.verticalAngle = 0;
        this.mHeadTurnParam.verticalMaxSpeed = 30;
        this.mIsRunning = true;
      }
    }, {
      key: "turnRight",
      value: function turnRight(hMode, hAngle, vMode, vAngle) {
        this.mHeadTurnParam.horizontalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.horizontalAngle = 30;
        this.mHeadTurnParam.horizontalMaxSpeed = 30;
        this.mHeadTurnParam.verticalMode = _orionosEveCore.HeadTurnMode.relative;
        this.mHeadTurnParam.verticalAngle = 0;
        this.mHeadTurnParam.verticalMaxSpeed = 30;
        this.mIsRunning = true;
      }
    }, {
      key: "finishRunning",
      value: function finishRunning() {
        this.mIsRunning = false;
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mHeadTurnParam;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mIsRunning;
      }
    }, {
      key: "appendResultText",
      value: function appendResultText(text) {
        this.mResultText += '\n' + text;
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mResultText;
      }
    }, {
      key: "setInfoText",
      value: function setInfoText(infoText) {
        this.mHeadAction = infoText;
      }
    }, {
      key: "getInfoText",
      value: function getInfoText() {
        return this.mHeadAction;
      }
    }, {
      key: "setTriggerNum",
      value: function setTriggerNum(jumpNum) {
        this.triggerNumber = jumpNum;
      }
    }, {
      key: "getTriggerNum",
      value: function getTriggerNum() {
        return this.triggerNumber;
      }
    }]);
    return HeadTurnModel;
  }(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mIsRunning", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return false;
    }
  }), _descriptor2 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mResultText", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), _descriptor3 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mHeadAction", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), _descriptor4 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "triggerNumber", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return 36362226;
    }
  }), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "headUp", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "headUp"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "headDown", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "headDown"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "turnLeft", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "turnLeft"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "turnRight", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "turnRight"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "finishRunning", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "finishRunning"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "appendResultText", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "appendResultText"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "setInfoText", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "setInfoText"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "setTriggerNum", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "setTriggerNum"), _class.prototype)), _class);
  exports.HeadTurnModel = HeadTurnModel;
},"system_2d01160272669884793b18983a46dcd0_app_headTurn_HeadTurnModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_initializerDefineProperty.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_@babel_runtime_helpers_initializerWarningHelper.js","node_modules_mobx_lib_mobx.module.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/headTurn/HeadTurnModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BasicMotionModel = void 0;

  var _initializerDefineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/initializerDefineProperty"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _initializerWarningHelper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/initializerWarningHelper"));

  var _mobx = _$$_REQUIRE(_dependencyMap[6], "mobx");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _class, _descriptor, _descriptor2;

  var BasicMotionModel = (_class = function () {
    function BasicMotionModel() {
      (0, _classCallCheck2.default)(this, BasicMotionModel);
      (0, _initializerDefineProperty2.default)(this, "mIsRunning", _descriptor, this);
      (0, _initializerDefineProperty2.default)(this, "mResultText", _descriptor2, this);
      this.mBasicMotionParam = new _orionosEveCore.BasicMotionParam();
    }

    (0, _createClass2.default)(BasicMotionModel, [{
      key: "goForward",
      value: function goForward() {
        this.mBasicMotionParam.mode = _orionosEveCore.BasicMotionMode.goForward;
        this.mBasicMotionParam.linearSpeed = 0.1;
        this.mBasicMotionParam.distance = 0.1;
        this.mBasicMotionParam.avoidStop = true;
        this.mIsRunning = true;
      }
    }, {
      key: "goBackward",
      value: function goBackward() {
        this.mBasicMotionParam.mode = _orionosEveCore.BasicMotionMode.goBackward;
        this.mBasicMotionParam.linearSpeed = 0.1;
        this.mBasicMotionParam.distance = 0.1;
        this.mBasicMotionParam.avoidStop = true;
        this.mIsRunning = true;
      }
    }, {
      key: "turnLeft",
      value: function turnLeft() {
        this.mBasicMotionParam.mode = _orionosEveCore.BasicMotionMode.turnLeft;
        this.mBasicMotionParam.angularSpeed = 10;
        this.mBasicMotionParam.angle = 30;
        this.mIsRunning = true;
      }
    }, {
      key: "turnRight",
      value: function turnRight() {
        this.mBasicMotionParam.mode = _orionosEveCore.BasicMotionMode.turnRight;
        this.mBasicMotionParam.angularSpeed = 10;
        this.mBasicMotionParam.angle = 30;
        this.mIsRunning = true;
      }
    }, {
      key: "finishRunning",
      value: function finishRunning() {
        this.mIsRunning = false;
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mBasicMotionParam;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mIsRunning;
      }
    }, {
      key: "appendResultText",
      value: function appendResultText(text) {
        this.mResultText += '\n' + text;
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mResultText;
      }
    }]);
    return BasicMotionModel;
  }(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mIsRunning", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return false;
    }
  }), _descriptor2 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mResultText", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "goForward", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "goForward"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "goBackward", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "goBackward"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "turnLeft", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "turnLeft"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "turnRight", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "turnRight"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "finishRunning", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "finishRunning"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "appendResultText", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "appendResultText"), _class.prototype)), _class);
  exports.BasicMotionModel = BasicMotionModel;
},"system_2d01160272669884793b18983a46dcd0_app_basicMotion_BasicMotionModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_initializerDefineProperty.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_@babel_runtime_helpers_initializerWarningHelper.js","node_modules_mobx_lib_mobx.module.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/basicMotion/BasicMotionModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ThirdApkInfoLocal = exports.ThirdApkInfo = void 0;
  var ThirdApkInfo;
  exports.ThirdApkInfo = ThirdApkInfo;

  (function (ThirdApkInfo) {
    ThirdApkInfo["PACKAGE_NAME"] = "com.example.myfirstapp";
    ThirdApkInfo["MAIN_ACTIVITY"] = "com.example.myfirstapp.MainActivity";
  })(ThirdApkInfo || (exports.ThirdApkInfo = ThirdApkInfo = {}));

  var ThirdApkInfoLocal = ThirdApkInfo;
  exports.ThirdApkInfoLocal = ThirdApkInfoLocal;
},"system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts",[],"app/biz/base/ThirdApkInfo.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BasicMotionViewModel = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[6], "orionos-eve-core");

  var _BasicMotionModel = _$$_REQUIRE(_dependencyMap[7], "./BasicMotionModel");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var BasicMotionViewModel = function (_BaseViewModel) {
    (0, _inherits2.default)(BasicMotionViewModel, _BaseViewModel);

    var _super = _createSuper(BasicMotionViewModel);

    function BasicMotionViewModel() {
      var _this;

      (0, _classCallCheck2.default)(this, BasicMotionViewModel);
      _this = _super.call(this, 'BasicMotion');

      _this.onPressGoForward = function () {
        _this.mModel.goForward();
      };

      _this.onPressGoBackward = function () {
        _this.mModel.goBackward();
      };

      _this.onPressTurnLeft = function () {
        _this.mModel.turnLeft();
      };

      _this.onPressTurnRight = function () {
        _this.mModel.turnRight();
      };

      _this.onPressStop = function () {
        _this.mModel.finishRunning();
      };

      _this.onFinish = function (event) {
        _this.mModel.finishRunning();

        if (event && event.status) {
          switch (event.status) {
            case _orionosEveCore.ComponentResultConst.RESULT_SUCCESS:
              _this.mModel.appendResultText('RESULT_SUCCESS(' + event.status + '): 执行完成');

              break;

            case _orionosEveCore.ComponentResultConst.RESULT_MOTION_STOP_SUCCESS:
              _this.mModel.appendResultText('RESULT_MOTION_STOP_SUCCESS(' + event.status + '): 停止成功');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_PARAMS_BASIC_MOTION_BEAN_INVALID:
              _this.mModel.appendResultText('ERROR_PARAMS_BASIC_MOTION_BEAN_INVALID(' + event.status + '): 参数无效');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_PARAMS_JSON_PARSER_ERROR:
              _this.mModel.appendResultText('ERROR_PARAMS_JSON_PARSER_ERROR(' + event.status + '): 参数错误');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_MOTION_AVOID_STOP:
              _this.mModel.appendResultText('ERROR_MOTION_AVOID_STOP(' + event.status + '): 遇障碍物停止');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_REQUEST_RES_FAILED:
              _this.mModel.appendResultText('ERROR_REQUEST_RES_FAILED(' + event.status + '): 请求底盘失败');

              break;

            default:
              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.mModel = new _BasicMotionModel.BasicMotionModel();
      return _this;
    }

    (0, _createClass2.default)(BasicMotionViewModel, [{
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onStop",
      value: function onStop() {}
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mModel.isRunning();
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mModel.getParam();
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mModel.getResultText();
      }
    }]);
    return BasicMotionViewModel;
  }(_orionosEveCore.BaseViewModel);

  exports.BasicMotionViewModel = BasicMotionViewModel;
},"system_2d01160272669884793b18983a46dcd0_app_basicMotion_BasicMotionViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","system_2d01160272669884793b18983a46dcd0_app_basicMotion_BasicMotionModel.ts"],"app/basicMotion/BasicMotionViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StandardFaceTrackViewModel = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _ThirdApkInfo = _$$_REQUIRE(_dependencyMap[6], "../biz/base/ThirdApkInfo");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _StandardFaceTrackModel = _$$_REQUIRE(_dependencyMap[8], "./StandardFaceTrackModel");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var StandardFaceTrackViewModel = function (_BaseViewModel) {
    (0, _inherits2.default)(StandardFaceTrackViewModel, _BaseViewModel);

    var _super = _createSuper(StandardFaceTrackViewModel);

    function StandardFaceTrackViewModel() {
      var _this;

      (0, _classCallCheck2.default)(this, StandardFaceTrackViewModel);
      _this = _super.call(this, 'StandardFaceTrack');
      _this.return_obj = {
        "command": "",
        "text": "",
        "code": -1,
        "messaage": ""
      };

      _this.onPressHeadUp = function () {
        _this.mModel.startTrack();
      };

      _this.onPressHeadDown = function () {
        _this.mModel.finishRunning();
      };

      _this.onStatusUpdate = function (event) {
        if (event && event.status) {
          switch (event.status) {
            case _orionosEveCore.ComponentStatusConst.STATUS_TRACK_SUCCESS:
              _this.mModel.appendResultText('STATUS_TRACK_SUCCESS(' + event.status + '): 焦点跟随成功');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_TRACK_END:
              _this.mModel.appendResultText('STATUS_TRACK_END(' + event.status + '): 单次焦点跟随结束，还会继续找人跟随');

              break;

            default:
              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.onFinish = function (event) {
        _this.mModel.finishRunning();

        if (event && event.status) {
          _this.return_obj.command = "facAction";
          _this.return_obj.text = "face action";
          _this.return_obj.code = event.status;
          var result = JSON.stringify(_this.return_obj);

          _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);

          switch (event.status) {
            case _orionosEveCore.ComponentResultConst.RESULT_TIMEOUT:
              _this.mModel.appendResultText('RESULT_TIMEOUT(' + event.status + '): 执行超时');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_OPEN_PERSON_DETECT_FAILED:
              _this.mModel.appendResultText('ERROR_OPEN_PERSON_DETECT_FAILED(' + event.status + '): 获取人脸数据失败');

              break;

            default:
              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.mModel = new _StandardFaceTrackModel.StandardFaceTrackModel();
      return _this;
    }

    (0, _createClass2.default)(StandardFaceTrackViewModel, [{
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onStop",
      value: function onStop() {}
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mModel.getParam();
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mModel.isRunning();
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mModel.getResultText();
      }
    }]);
    return StandardFaceTrackViewModel;
  }(_orionosEveCore.BaseViewModel);

  exports.StandardFaceTrackViewModel = StandardFaceTrackViewModel;
},"system_2d01160272669884793b18983a46dcd0_app_standardFaceTrack_StandardFaceTrackViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","system_2d01160272669884793b18983a46dcd0_app_standardFaceTrack_StandardFaceTrackModel.ts"],"app/standardFaceTrack/StandardFaceTrackViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StandardFaceTrackModel = void 0;

  var _initializerDefineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/initializerDefineProperty"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _initializerWarningHelper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/initializerWarningHelper"));

  var _mobx = _$$_REQUIRE(_dependencyMap[6], "mobx");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _class, _descriptor, _descriptor2;

  var StandardFaceTrackModel = (_class = function () {
    function StandardFaceTrackModel() {
      (0, _classCallCheck2.default)(this, StandardFaceTrackModel);
      (0, _initializerDefineProperty2.default)(this, "mIsRunning", _descriptor, this);
      (0, _initializerDefineProperty2.default)(this, "mResultText", _descriptor2, this);
      this.mStandardFaceTrackParam = new _orionosEveCore.StandardFaceTrackParam();
    }

    (0, _createClass2.default)(StandardFaceTrackModel, [{
      key: "startTrack",
      value: function startTrack() {
        this.mStandardFaceTrackParam.personId = undefined;
        this.mStandardFaceTrackParam.maxDistance = 3;
        this.mStandardFaceTrackParam.maxFaceAngleX = 60;
        this.mStandardFaceTrackParam.isNeedInCompleteFace = false;
        this.mStandardFaceTrackParam.disappearTimeout = 7000;
        this.mStandardFaceTrackParam.isMultiPersonNotTrack = false;
        this.mStandardFaceTrackParam.multiPersonNotTrackDistance = 2;
        this.mStandardFaceTrackParam.isAllowMoveBody = true;
        this.mIsRunning = true;
      }
    }, {
      key: "finishRunning",
      value: function finishRunning() {
        this.mIsRunning = false;
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mStandardFaceTrackParam;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mIsRunning;
      }
    }, {
      key: "appendResultText",
      value: function appendResultText(text) {
        this.mResultText += '\n' + text;
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mResultText;
      }
    }]);
    return StandardFaceTrackModel;
  }(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mIsRunning", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return false;
    }
  }), _descriptor2 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mResultText", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "startTrack", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "startTrack"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "finishRunning", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "finishRunning"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "appendResultText", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "appendResultText"), _class.prototype)), _class);
  exports.StandardFaceTrackModel = StandardFaceTrackModel;
},"system_2d01160272669884793b18983a46dcd0_app_standardFaceTrack_StandardFaceTrackModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_initializerDefineProperty.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_@babel_runtime_helpers_initializerWarningHelper.js","node_modules_mobx_lib_mobx.module.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/standardFaceTrack/StandardFaceTrackModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ChargeStartViewModel = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[6], "orionos-eve-core");

  var _ChargeStartModel = _$$_REQUIRE(_dependencyMap[7], "./ChargeStartModel");

  var _ThirdApkInfo = _$$_REQUIRE(_dependencyMap[8], "../biz/base/ThirdApkInfo");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TAG = 'shadow_opk_for_android ChargeStartViewModel.ts';

  var ChargeStartViewModel = function (_BaseViewModel) {
    (0, _inherits2.default)(ChargeStartViewModel, _BaseViewModel);

    var _super = _createSuper(ChargeStartViewModel);

    function ChargeStartViewModel() {
      var _this;

      (0, _classCallCheck2.default)(this, ChargeStartViewModel);
      _this = _super.call(this, 'ChargeStart');
      _this.return_obj = {
        "command": "",
        "text": "",
        "code": -1,
        "messaage": ""
      };

      _this.onPressStartChargeStart = function () {
        console.log("viewmodel start 方法");

        _this.mModel.startChargeStart();
      };

      _this.onPressStopChargeStart = function () {
        console.log("viewmodel stop 方法");

        _this.mModel.finishRunning();
      };

      _this.onStatusUpdate = function (event) {
        if (event && event.status) {
          switch (event.status) {
            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID_START:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID_START(' + event.status + '): 堵死状态开始');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID_END:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID_END(' + event.status + '): 堵死状态结束');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_OBSTACLES_AVOID:
              _this.mModel.appendResultText('STATUS_OBSTACLES_AVOID(' + event.status + '): 避停状态');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_START_NAVIGATION:
              _this.mModel.appendResultText('STATUS_START_NAVIGATION(' + event.status + '): 底盘启动导航成功');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID(' + event.status + '): 堵死计数上报');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_ESTIMATE_LOST:
              _this.mModel.appendResultText('STATUS_ESTIMATE_LOST(' + event.status + '): 定位丢失');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_DISTANCE_WITH_DESTINATION:
              _this.mModel.appendResultText('STATUS_DISTANCE_WITH_DESTINATION(' + event.status + '): 距离目标点' + event.data + '米');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_NEAR_DESTINATION:
              _this.mModel.appendResultText('STATUS_NAVIGATION_NEAR_DESTINATION(' + event.status + '): 靠近目标点');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_RESET_ESTIMATE_SUCCESS:
              _this.mModel.appendResultText('STATUS_NAVIGATION_RESET_ESTIMATE_SUCCESS(' + event.status + '): 运动任务中重定位成功');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID_IMMEDIATELY:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID_IMMEDIATELY(' + event.status + '): 导航避障里面上报状态');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_GO_STRAIGHT:
              _this.mModel.appendResultText('STATUS_NAVIGATION_GO_STRAIGHT(' + event.status + '): 导航直行');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_TURN_LEFT:
              _this.mModel.appendResultText('STATUS_NAVIGATION_TURN_LEFT(' + event.status + '): 导航左转');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_TURN_RIGHT:
              _this.mModel.appendResultText('STATUS_NAVIGATION_TURN_RIGHT(' + event.status + '): 导航右转');

              break;

            default:
              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.onFinish = function (event) {
        _this.mModel.finishRunning();

        if (event && event.status) {
          _this.return_obj.command = "chargeAction";
          _this.return_obj.text = "charge action";
          _this.return_obj.code = event && event.status;
          var result = JSON.stringify(_this.return_obj);

          _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);

          console.log(TAG, "充电追踪" + JSON.stringify(event));

          switch (event.status) {
            case _orionosEveCore.ComponentResultConst.RESULT_NAVIGATION_ARRIVED:
              _this.mModel.appendResultText('RESULT_NAVIGATION_ARRIVED(' + event.status + '): 成功到达目的地');

              break;

            case _orionosEveCore.ComponentResultConst.RESULT_NAVIGATION_FAILURE:
              _this.mModel.appendResultText('RESULT_NAVIGATION_FAILURE(' + event.status + '): 底盘启动导航任务失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_PARAMS_PLACE_NAME_INVALID:
              _this.mModel.appendResultText('ERROR_PARAMS_PLACE_NAME_INVALID(' + event.status + '): 地点名称参数无效');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NOT_ESTIMATE:
              _this.mModel.appendResultText('ERROR_NOT_ESTIMATE(' + event.status + '): 未定位异常');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_ALREADY_IN_DESTINATION:
              _this.mModel.appendResultText('ERROR_NAVIGATION_ALREADY_IN_DESTINATION(' + event.status + '): 已经处于目标点位置');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_DESTINATION_NOT_EXIST:
              _this.mModel.appendResultText('ERROR_DESTINATION_NOT_EXIST(' + event.status + '): 目标点不存在');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_REQUEST_RES_BUSY:
              _this.mModel.appendResultText('ERROR_REQUEST_RES_BUSY(' + event.status + '): 申请机器人底盘资源正在占用');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_REQUEST_RES_FAILED:
              _this.mModel.appendResultText('ERROR_REQUEST_RES_FAILED(' + event.status + '): 申请机器人底盘资源失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_OUT_MAP:
              _this.mModel.appendResultText('ERROR_NAVIGATION_OUT_MAP(' + event.status + '): 目标点在地图外或在糟点上');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_GLOBAL_PATH_FAILED:
              _this.mModel.appendResultText('ERROR_NAVIGATION_GLOBAL_PATH_FAILED(' + event.status + '): 全局路径规划失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_RESET_ESTIMATE_FAIL:
              _this.mModel.appendResultText('ERROR_NAVIGATION_RESET_ESTIMATE_FAIL(' + event.status + '): 重定位失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_DESTINATION_CAN_NOT_ARRIVE:
              _this.mModel.appendResultText('ERROR_DESTINATION_CAN_NOT_ARRIVE(' + event.status + '): 机器无位移超时');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_AVOID_TIMEOUT:
              _this.mModel.appendResultText('ERROR_NAVIGATION_AVOID_TIMEOUT(' + event.status + '): 堵死状态超时');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_PARAMS_JSON_PARSER_ERROR:
              _this.mModel.appendResultText('ERROR_PARAMS_JSON_PARSER_ERROR(' + event.status + '): 参数解析错误');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_WHEEL_OVER_CURRENT_RUN_OUT:
              _this.mModel.appendResultText('ERROR_WHEEL_OVER_CURRENT_RUN_OUT\t(' + event.status + '): 过流重试结束');

              break;

            default:
              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.mModel = new _ChargeStartModel.ChargeStartModel();
      return _this;
    }

    (0, _createClass2.default)(ChargeStartViewModel, [{
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onStop",
      value: function onStop() {}
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mModel.isRunning();
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mModel.getParam();
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mModel.getResultText();
      }
    }]);
    return ChargeStartViewModel;
  }(_orionosEveCore.BaseViewModel);

  exports.ChargeStartViewModel = ChargeStartViewModel;
},"system_2d01160272669884793b18983a46dcd0_app_chargeStart_ChargeStartViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","system_2d01160272669884793b18983a46dcd0_app_chargeStart_ChargeStartModel.ts","system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts"],"app/chargeStart/ChargeStartViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ChargeStartModel = void 0;

  var _initializerDefineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/initializerDefineProperty"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _initializerWarningHelper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/initializerWarningHelper"));

  var _mobx = _$$_REQUIRE(_dependencyMap[6], "mobx");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _class, _descriptor, _descriptor2;

  var ChargeStartModel = (_class = function () {
    function ChargeStartModel() {
      (0, _classCallCheck2.default)(this, ChargeStartModel);
      (0, _initializerDefineProperty2.default)(this, "mIsRunning", _descriptor, this);
      (0, _initializerDefineProperty2.default)(this, "mResultText", _descriptor2, this);
      this.mChargeStartParam = new _orionosEveCore.ChargeStartParam();
    }

    (0, _createClass2.default)(ChargeStartModel, [{
      key: "startChargeStart",
      value: function startChargeStart() {
        this.mChargeStartParam.chargeTimeout = 180000;
        this.mChargeStartParam.avoidDistance = 0.1;
        this.mChargeStartParam.avoidTimeout = 20000;
        this.mChargeStartParam.multiWaitTimeout = 300000;
        this.mIsRunning = true;
      }
    }, {
      key: "finishRunning",
      value: function finishRunning() {
        this.mIsRunning = false;
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mChargeStartParam;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mIsRunning;
      }
    }, {
      key: "appendResultText",
      value: function appendResultText(text) {
        this.mResultText += '\n' + text;
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mResultText;
      }
    }]);
    return ChargeStartModel;
  }(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mIsRunning", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return false;
    }
  }), _descriptor2 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mResultText", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "startChargeStart", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "startChargeStart"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "finishRunning", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "finishRunning"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "appendResultText", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "appendResultText"), _class.prototype)), _class);
  exports.ChargeStartModel = ChargeStartModel;
},"system_2d01160272669884793b18983a46dcd0_app_chargeStart_ChargeStartModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_initializerDefineProperty.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_@babel_runtime_helpers_initializerWarningHelper.js","node_modules_mobx_lib_mobx.module.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/chargeStart/ChargeStartModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MapViewModel = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[6], "orionos-eve-core");

  var _MapModel = _$$_REQUIRE(_dependencyMap[7], "./MapModel");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TAG = 'MapViewModel';

  var MapViewModel = function (_BaseViewModel) {
    (0, _inherits2.default)(MapViewModel, _BaseViewModel);

    var _super = _createSuper(MapViewModel);

    function MapViewModel() {
      var _this;

      (0, _classCallCheck2.default)(this, MapViewModel);
      _this = _super.call(this, 'map');
      _this.return_obj = {
        "mapName": "",
        "pose": "",
        "poseBeanList": ""
      };
      _this.current_position = {
        "curMapName": "",
        "pose": ""
      };
      _this.mModel = new _MapModel.MapModel();
      return _this;
    }

    (0, _createClass2.default)(MapViewModel, [{
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onStop",
      value: function onStop() {}
    }, {
      key: "getCurrPosition",
      value: function getCurrPosition() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          var commandListener = new _orionosEveCore.CommandListener();
          commandListener.addListener(_orionosEveCore.CommandListener.EVENT_RESULT, function (result) {
            console.log(TAG, 'getMapName -> ' + JSON.stringify(result));

            if (result !== null) {
              var mapName = result.message;

              if (mapName !== null && mapName !== '') {
                _orionosEveCore.RobotApi.getPosition().then(function (result) {
                  console.log(TAG, 'getCurrPose -> ' + JSON.stringify(result));
                  _this2.current_position.curMapName = mapName;
                  _this2.current_position.pose = result.message;
                  ;
                  resolve(_this2.current_position);
                }).catch(function (e) {
                  console.log(TAG, 'getCurrPose Error -> ' + e);
                });
              }
            }

            commandListener.removeListener();
          });

          _orionosEveCore.RobotApi.getMapName(commandListener.getId());
        });
      }
    }, {
      key: "getCurrPose",
      value: function getCurrPose() {
        var _this3 = this;

        return new Promise(function (resolve, reject) {
          var commandListener = new _orionosEveCore.CommandListener();
          commandListener.addListener(_orionosEveCore.CommandListener.EVENT_RESULT, function (result) {
            console.log(TAG, 'getMapName -> ' + JSON.stringify(result));

            if (result !== null) {
              var mapName = result.message;

              if (mapName !== null && mapName !== '') {
                _orionosEveCore.RobotApi.getPosition().then(function (result) {
                  var pose = result.message;
                  console.log(TAG, 'getCurrPose -> ' + JSON.stringify(result));

                  _this3.getPlaceListWithName(mapName, pose).then(function (return_obj) {
                    resolve(return_obj);
                  });
                }).catch(function (e) {
                  console.log(TAG, 'getCurrPose Error -> ' + e);
                });
              }
            }

            commandListener.removeListener();
          });

          _orionosEveCore.RobotApi.getMapName(commandListener.getId());
        });
      }
    }, {
      key: "getPlaceListWithName",
      value: function getPlaceListWithName(mapName, pose) {
        var _this4 = this;

        return new Promise(function (resolve, reject) {
          var action = new _orionosEveCore.CommandListener();
          action.addListener(_orionosEveCore.CommandListener.EVENT_RESULT, function (msg) {
            console.log(TAG, '位置点列表数据 : ' + JSON.stringify(msg));
            _this4.return_obj.mapName = mapName;
            _this4.return_obj.pose = pose;
            _this4.return_obj.poseBeanList = msg.message;
            resolve(_this4.return_obj);
            action.removeListener();
          });

          _orionosEveCore.RobotApi.getPlaceListWithName(action.getId());
        });
      }
    }, {
      key: "getCurMapName",
      value: function getCurMapName() {
        return this.mModel.getMapName();
      }
    }]);
    return MapViewModel;
  }(_orionosEveCore.BaseViewModel);

  exports.MapViewModel = MapViewModel;
},"system_2d01160272669884793b18983a46dcd0_app_map_MapViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","system_2d01160272669884793b18983a46dcd0_app_map_MapModel.ts"],"app/map/MapViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MapModel = void 0;

  var _initializerDefineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/initializerDefineProperty"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _initializerWarningHelper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/initializerWarningHelper"));

  var _mobx = _$$_REQUIRE(_dependencyMap[6], "mobx");

  var _class, _descriptor;

  var MapModel = (_class = function () {
    function MapModel() {
      (0, _classCallCheck2.default)(this, MapModel);
      (0, _initializerDefineProperty2.default)(this, "mapName", _descriptor, this);
    }

    (0, _createClass2.default)(MapModel, [{
      key: "setMapName",
      value: function setMapName(text) {
        this.mapName = text;
      }
    }, {
      key: "getMapName",
      value: function getMapName() {
        return this.mapName;
      }
    }]);
    return MapModel;
  }(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mapName", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "setMapName", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "setMapName"), _class.prototype)), _class);
  exports.MapModel = MapModel;
},"system_2d01160272669884793b18983a46dcd0_app_map_MapModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_initializerDefineProperty.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_@babel_runtime_helpers_initializerWarningHelper.js","node_modules_mobx_lib_mobx.module.js"],"app/map/MapModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationViewModel = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _ThirdApkInfo = _$$_REQUIRE(_dependencyMap[6], "../biz/base/ThirdApkInfo");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _NavigationModel = _$$_REQUIRE(_dependencyMap[8], "./NavigationModel");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TAG = 'shadow_opk_for_android navigationViewModel.ts';

  var NavigationViewModel = function (_BaseViewModel) {
    (0, _inherits2.default)(NavigationViewModel, _BaseViewModel);

    var _super = _createSuper(NavigationViewModel);

    function NavigationViewModel() {
      var _this;

      (0, _classCallCheck2.default)(this, NavigationViewModel);
      _this = _super.call(this, 'Navigation');
      _this.return_obj = {
        "command": "",
        "text": "",
        "code": -1,
        "messaage": ""
      };

      _this.onPressStartNavigation = function (placeName) {
        _this.mModel.startNavigation(placeName);
      };

      _this.onPressStartNavigationView = function () {
        _this.mModel.startNavigation("接待点");
      };

      _this.onPressStopNavigation = function () {
        _this.mModel.finishRunning();
      };

      _this.onStatusUpdate = function (event) {
        if (event && event.status) {
          switch (event.status) {
            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID_START:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID_START(' + event.status + '): 堵死状态开始');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID_END:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID_END(' + event.status + '): 堵死状态结束');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_OBSTACLES_AVOID:
              _this.mModel.appendResultText('STATUS_OBSTACLES_AVOID(' + event.status + '): 避停状态');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_START_NAVIGATION:
              _this.mModel.appendResultText('STATUS_START_NAVIGATION(' + event.status + '): 底盘启动导航成功');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID(' + event.status + '): 堵死计数上报');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_ESTIMATE_LOST:
              _this.mModel.appendResultText('STATUS_ESTIMATE_LOST(' + event.status + '): 定位丢失');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_DISTANCE_WITH_DESTINATION:
              _this.mModel.appendResultText('STATUS_DISTANCE_WITH_DESTINATION(' + event.status + '): 距离目标点' + event.data + '米');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_NEAR_DESTINATION:
              _this.mModel.appendResultText('STATUS_NAVIGATION_NEAR_DESTINATION(' + event.status + '): 靠近目标点');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_RESET_ESTIMATE_SUCCESS:
              _this.mModel.appendResultText('STATUS_NAVIGATION_RESET_ESTIMATE_SUCCESS(' + event.status + '): 运动任务中重定位成功');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_AVOID_IMMEDIATELY:
              _this.mModel.appendResultText('STATUS_NAVIGATION_AVOID_IMMEDIATELY(' + event.status + '): 导航避障里面上报状态');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_GO_STRAIGHT:
              _this.mModel.appendResultText('STATUS_NAVIGATION_GO_STRAIGHT(' + event.status + '): 导航直行');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_TURN_LEFT:
              _this.mModel.appendResultText('STATUS_NAVIGATION_TURN_LEFT(' + event.status + '): 导航左转');

              break;

            case _orionosEveCore.ComponentStatusConst.STATUS_NAVIGATION_TURN_RIGHT:
              _this.mModel.appendResultText('STATUS_NAVIGATION_TURN_RIGHT(' + event.status + '): 导航右转');

              break;

            default:
              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.onFinish = function (event) {
        _this.mModel.finishRunning();

        if (event && event.status) {
          _this.return_obj.command = "naviAction";
          _this.return_obj.text = "navigation action";
          _this.return_obj.code = event && event.status;
          var result = JSON.stringify(_this.return_obj);

          _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);

          console.log(TAG, "导航追踪" + JSON.stringify(event));

          switch (event.status) {
            case _orionosEveCore.ComponentResultConst.RESULT_NAVIGATION_ARRIVED:
              _this.mModel.appendResultText('RESULT_NAVIGATION_ARRIVED(' + event.status + '): 成功到达目的地');

              break;

            case _orionosEveCore.ComponentResultConst.RESULT_NAVIGATION_FAILURE:
              _this.mModel.appendResultText('RESULT_NAVIGATION_FAILURE(' + event.status + '): 底盘启动导航任务失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_PARAMS_PLACE_NAME_INVALID:
              _this.mModel.appendResultText('ERROR_PARAMS_PLACE_NAME_INVALID(' + event.status + '): 地点名称参数无效');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NOT_ESTIMATE:
              _this.mModel.appendResultText('ERROR_NOT_ESTIMATE(' + event.status + '): 未定位异常');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_ALREADY_IN_DESTINATION:
              _this.mModel.appendResultText('ERROR_NAVIGATION_ALREADY_IN_DESTINATION(' + event.status + '): 已经处于目标点位置');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_DESTINATION_NOT_EXIST:
              _this.mModel.appendResultText('ERROR_DESTINATION_NOT_EXIST(' + event.status + '): 目标点不存在');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_REQUEST_RES_BUSY:
              _this.mModel.appendResultText('ERROR_REQUEST_RES_BUSY(' + event.status + '): 申请机器人底盘资源正在占用');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_REQUEST_RES_FAILED:
              _this.mModel.appendResultText('ERROR_REQUEST_RES_FAILED(' + event.status + '): 申请机器人底盘资源失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_OUT_MAP:
              _this.mModel.appendResultText('ERROR_NAVIGATION_OUT_MAP(' + event.status + '): 目标点在地图外或在糟点上');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_GLOBAL_PATH_FAILED:
              _this.mModel.appendResultText('ERROR_NAVIGATION_GLOBAL_PATH_FAILED(' + event.status + '): 全局路径规划失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_RESET_ESTIMATE_FAIL:
              _this.mModel.appendResultText('ERROR_NAVIGATION_RESET_ESTIMATE_FAIL(' + event.status + '): 重定位失败');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_DESTINATION_CAN_NOT_ARRIVE:
              _this.mModel.appendResultText('ERROR_DESTINATION_CAN_NOT_ARRIVE(' + event.status + '): 机器无位移超时');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_NAVIGATION_AVOID_TIMEOUT:
              _this.mModel.appendResultText('ERROR_NAVIGATION_AVOID_TIMEOUT(' + event.status + '): 堵死状态超时');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_PARAMS_JSON_PARSER_ERROR:
              _this.mModel.appendResultText('ERROR_PARAMS_JSON_PARSER_ERROR(' + event.status + '): 参数解析错误');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_WHEEL_OVER_CURRENT_RUN_OUT:
              _this.mModel.appendResultText('ERROR_WHEEL_OVER_CURRENT_RUN_OUT\t(' + event.status + '): 过流重试结束');

              break;

            default:
              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.mModel = new _NavigationModel.NavigationModel();
      return _this;
    }

    (0, _createClass2.default)(NavigationViewModel, [{
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onStop",
      value: function onStop() {}
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mModel.getParam();
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mModel.isRunning();
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mModel.getResultText();
      }
    }]);
    return NavigationViewModel;
  }(_orionosEveCore.BaseViewModel);

  exports.NavigationViewModel = NavigationViewModel;
},"system_2d01160272669884793b18983a46dcd0_app_navigation_NavigationViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","system_2d01160272669884793b18983a46dcd0_app_navigation_NavigationModel.ts"],"app/navigation/NavigationViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationModel = void 0;

  var _initializerDefineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/initializerDefineProperty"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _initializerWarningHelper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/initializerWarningHelper"));

  var _mobx = _$$_REQUIRE(_dependencyMap[6], "mobx");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _class, _descriptor, _descriptor2;

  var NavigationModel = (_class = function () {
    function NavigationModel() {
      (0, _classCallCheck2.default)(this, NavigationModel);
      (0, _initializerDefineProperty2.default)(this, "mIsRunning", _descriptor, this);
      (0, _initializerDefineProperty2.default)(this, "mResultText", _descriptor2, this);
      this.mNavigationParam = new _orionosEveCore.NavigationParam('接待点');
    }

    (0, _createClass2.default)(NavigationModel, [{
      key: "startNavigation",
      value: function startNavigation(destination) {
        this.mNavigationParam.destination = destination;
        this.mIsRunning = true;
      }
    }, {
      key: "finishRunning",
      value: function finishRunning() {
        this.mIsRunning = false;
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mNavigationParam;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mIsRunning;
      }
    }, {
      key: "appendResultText",
      value: function appendResultText(text) {
        this.mResultText += '\n' + text;
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mResultText;
      }
    }]);
    return NavigationModel;
  }(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mIsRunning", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return false;
    }
  }), _descriptor2 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mResultText", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "startNavigation", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "startNavigation"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "finishRunning", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "finishRunning"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "appendResultText", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "appendResultText"), _class.prototype)), _class);
  exports.NavigationModel = NavigationModel;
},"system_2d01160272669884793b18983a46dcd0_app_navigation_NavigationModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_initializerDefineProperty.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_@babel_runtime_helpers_initializerWarningHelper.js","node_modules_mobx_lib_mobx.module.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/navigation/NavigationModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PersonAppearViewModel = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _ThirdApkInfo = _$$_REQUIRE(_dependencyMap[6], "../biz/base/ThirdApkInfo");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _PersonAppearModel = _$$_REQUIRE(_dependencyMap[8], "./PersonAppearModel");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TAG = 'shadow_opk_for_android personAppearViewModel.ts';

  var PersonAppearViewModel = function (_BaseViewModel) {
    (0, _inherits2.default)(PersonAppearViewModel, _BaseViewModel);

    var _super = _createSuper(PersonAppearViewModel);

    function PersonAppearViewModel() {
      var _this;

      (0, _classCallCheck2.default)(this, PersonAppearViewModel);
      _this = _super.call(this, 'PersonAppear');
      _this.return_obj = {
        "command": "",
        "text": "",
        "code": -1,
        "data": "",
        "messaage": ""
      };

      _this.onPressStartPersonAppear = function () {
        _this.mModel.startPersonAppear();
      };

      _this.onPressFinishPersonAppear = function () {
        _this.mModel.finishRunning();
      };

      _this.onFinish = function (event) {
        _this.mModel.finishRunning();

        if (event && event.status) {
          _this.return_obj.command = "personAppearAction";
          _this.return_obj.text = "person appear action";
          _this.return_obj.code = event && event.status;
          _this.return_obj.data = event.data ? JSON.stringify(event.data) : "";
          var result = JSON.stringify(_this.return_obj);

          _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result);

          console.log(TAG, "人脸检测 onFinish 方法" + JSON.stringify(event));

          switch (event.status) {
            case _orionosEveCore.ComponentResultConst.RESULT_SUCCESS:
              console.log('啦啦啦啦1' + event.status);

              _this.mModel.appendResultText('RESULT_SUCCESS(' + event.status + '): 检测成功');

              if (event.data) {
                var personData = JSON.parse(event.data);

                _this.mModel.appendResultText('姓名：' + (personData.name ? personData.name : '陌生人'));

                _this.mModel.appendResultText('性别：' + (personData.gender === 'female' ? '女' : '男'));

                _this.mModel.appendResultText('年龄：' + personData.age);
              }

              break;

            case _orionosEveCore.ComponentResultConst.RESULT_TIMEOUT:
              console.log('啦啦啦啦2' + event.status);

              _this.mModel.appendResultText('RESULT_TIMEOUT(' + event.status + '): 检测超时');

              break;

            case _orionosEveCore.ComponentErrorConst.ERROR_OPEN_PERSON_DETECT_FAILED:
              console.log('啦啦啦啦3' + event.status);

              _this.mModel.appendResultText('ERROR_PARAMS_REGISTER_ID_INVALID(' + event.status + '): 获取人脸数据失败');

              break;

            default:
              console.log('啦啦啦啦4' + event.status);

              _this.mModel.appendResultText(event.status + '');

              break;
          }
        }

        return true;
      };

      _this.mModel = new _PersonAppearModel.PersonAppearModel();
      return _this;
    }

    (0, _createClass2.default)(PersonAppearViewModel, [{
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onStop",
      value: function onStop() {}
    }, {
      key: "isRunning",
      value: function isRunning() {
        console.log('检测isRunning方法是否被执行' + this.mModel.getParam());
        return this.mModel.isRunning();
      }
    }, {
      key: "getParam",
      value: function getParam() {
        console.log('啦啦啦5' + this.mModel.getParam());
        return this.mModel.getParam();
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mModel.getResultText();
      }
    }]);
    return PersonAppearViewModel;
  }(_orionosEveCore.BaseViewModel);

  exports.PersonAppearViewModel = PersonAppearViewModel;
},"system_2d01160272669884793b18983a46dcd0_app_personAppear_PersonAppearViewModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","system_2d01160272669884793b18983a46dcd0_app_personAppear_PersonAppearModel.ts"],"app/personAppear/PersonAppearViewModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PersonAppearModel = void 0;

  var _initializerDefineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/initializerDefineProperty"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _applyDecoratedDescriptor2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/applyDecoratedDescriptor"));

  var _initializerWarningHelper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/initializerWarningHelper"));

  var _mobx = _$$_REQUIRE(_dependencyMap[6], "mobx");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _class, _descriptor, _descriptor2;

  var PersonAppearModel = (_class = function () {
    function PersonAppearModel() {
      (0, _classCallCheck2.default)(this, PersonAppearModel);
      (0, _initializerDefineProperty2.default)(this, "mIsRunning", _descriptor, this);
      (0, _initializerDefineProperty2.default)(this, "mResultText", _descriptor2, this);
      this.mPersonAppearParam = new _orionosEveCore.PersonAppearParam();
    }

    (0, _createClass2.default)(PersonAppearModel, [{
      key: "startPersonAppear",
      value: function startPersonAppear() {
        this.mPersonAppearParam.personId = undefined;
        this.mPersonAppearParam.personName = undefined;
        this.mPersonAppearParam.maxDistance = 3;
        this.mPersonAppearParam.maxFaceAngleX = 60;
        this.mPersonAppearParam.isNeedInCompleteFace = false;
        this.mPersonAppearParam.incompleteFaceCacheTimeout = 3000;
        this.mPersonAppearParam.isNeedBody = false;
        this.mPersonAppearParam.isNeedRecognize = true;
        this.mPersonAppearParam.recognizeTimeout = 2000;
        this.mPersonAppearParam.isNeedDeletePic = true;
        this.mPersonAppearParam.appearTimeout = 7000;
        this.mPersonAppearParam.scene = undefined;
        this.mIsRunning = true;
      }
    }, {
      key: "finishRunning",
      value: function finishRunning() {
        this.mIsRunning = false;
      }
    }, {
      key: "getParam",
      value: function getParam() {
        return this.mPersonAppearParam;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.mIsRunning;
      }
    }, {
      key: "appendResultText",
      value: function appendResultText(text) {
        this.mResultText += '\n' + text;
      }
    }, {
      key: "getResultText",
      value: function getResultText() {
        return this.mResultText;
      }
    }]);
    return PersonAppearModel;
  }(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mIsRunning", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return false;
    }
  }), _descriptor2 = (0, _applyDecoratedDescriptor2.default)(_class.prototype, "mResultText", [_mobx.observable], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return '';
    }
  }), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "startPersonAppear", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "startPersonAppear"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "finishRunning", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "finishRunning"), _class.prototype), (0, _applyDecoratedDescriptor2.default)(_class.prototype, "appendResultText", [_mobx.action], Object.getOwnPropertyDescriptor(_class.prototype, "appendResultText"), _class.prototype)), _class);
  exports.PersonAppearModel = PersonAppearModel;
},"system_2d01160272669884793b18983a46dcd0_app_personAppear_PersonAppearModel.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_initializerDefineProperty.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_applyDecoratedDescriptor.js","node_modules_@babel_runtime_helpers_initializerWarningHelper.js","node_modules_mobx_lib_mobx.module.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/personAppear/PersonAppearModel.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeadTurnVoice = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _ThirdApkInfo = _$$_REQUIRE(_dependencyMap[6], "../biz/base/ThirdApkInfo");

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var HeadTurnVoice = function (_BaseVoice) {
    (0, _inherits2.default)(HeadTurnVoice, _BaseVoice);

    var _super = _createSuper(HeadTurnVoice);

    function HeadTurnVoice(viewModel) {
      var _this;

      (0, _classCallCheck2.default)(this, HeadTurnVoice);
      _this = _super.call(this, 'HeadTurnVoice');
      _this.return_obj = {
        "intent": "",
        "text": "",
        "result": ""
      };
      _this.viewModel = viewModel;
      return _this;
    }

    (0, _createClass2.default)(HeadTurnVoice, [{
      key: "onListenCallback",
      value: function onListenCallback(intent, result, id, text) {
        console.log('DemoVoice : ' + text + "   result====:" + JSON.stringify(result));

        switch (intent) {
          default:
            this.return_obj.intent = intent;
            this.return_obj.text = text;
            this.return_obj.result = result;
            var result_str = JSON.stringify(this.return_obj);
            console.log("语音识别数据信息：" + result_str);

            _orionosEveCore.NLPApkControl.onRobotMessage(_ThirdApkInfo.ThirdApkInfo.PACKAGE_NAME, result_str);

            return true;
        }
      }
    }, {
      key: "speak",
      value: function speak() {}
    }]);
    return HeadTurnVoice;
  }(_orionosEveCore.BaseVoice);

  exports.HeadTurnVoice = HeadTurnVoice;
},"system_2d01160272669884793b18983a46dcd0_app_demo_HeadTurnVoice.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_app_biz_base_ThirdApkInfo.ts","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/demo/HeadTurnVoice.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeadTurnTrigger = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[6], "orionos-eve-core");

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var HeadTurnTrigger = function (_Trigger) {
    (0, _inherits2.default)(HeadTurnTrigger, _Trigger);

    var _super = _createSuper(HeadTurnTrigger);

    function HeadTurnTrigger() {
      (0, _classCallCheck2.default)(this, HeadTurnTrigger);
      return _super.call(this, 'HeadTurn1199');
    }

    (0, _createClass2.default)(HeadTurnTrigger, [{
      key: "navSwitch",
      value: function navSwitch(from, to) {}
    }, {
      key: "trigger",
      value: function trigger(protocol) {
        switch (protocol.eventId) {
          case 36362226:
            console.log("最后一步有没有走到这里");

            this._trigger('home', protocol);

            break;

          case 36362227:
            console.log("最后一步有没有走到这里triggerToHome");

            this._trigger('home', protocol);

            break;

          case 36362228:
            console.log("最后一步有没有走到这里triggerToWakeup");

            this._trigger('wakeUp', protocol);

            break;

          case 36362229:
            console.log("最后一步有没有走到这里triggerToQueryLocation");

            this._trigger('queryLocation', protocol);

            break;

          case 36362230:
            console.log("最后一步有没有走到这里triggerToWeather");

            _orionosEveCore.speechApi.queryByText("今天天气");

            this._trigger('weather', protocol);

            break;
        }

        return undefined;
      }
    }]);
    return HeadTurnTrigger;
  }(_orionosEveCore.Trigger);

  exports.HeadTurnTrigger = HeadTurnTrigger;
},"system_2d01160272669884793b18983a46dcd0_app_demo_HeadTurnTrigger.ts",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts"],"app/demo/HeadTurnTrigger.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HeadTurnView = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[7], "react-native");

  var _mobxReact = _$$_REQUIRE(_dependencyMap[8], "mobx-react");

  var _class,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/headTurn/HeadTurnView.tsx";

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var styles = _reactNative.StyleSheet.create({
    rootView: {
      flex: 1,
      backgroundColor: 'white',
      alignItems: 'center',
      width: width,
      height: height
    },
    button: {
      width: '50%',
      marginBottom: 10
    },
    resultArea: {
      flex: 1,
      width: '90%',
      marginBottom: 20,
      borderWidth: 2,
      borderRadius: 10,
      borderColor: 'dodgerblue',
      alignItems: 'center'
    },
    resultScroll: {
      width: '90%',
      height: '100%'
    },
    resultText: {
      fontSize: 12,
      alignSelf: 'center',
      width: '100%',
      height: '100%'
    }
  });

  var HeadTurnView = (0, _mobxReact.observer)(_class = function (_Component) {
    (0, _inherits2.default)(HeadTurnView, _Component);

    var _super = _createSuper(HeadTurnView);

    function HeadTurnView() {
      var _this;

      (0, _classCallCheck2.default)(this, HeadTurnView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.setScroll = function (scroll) {
        _this.mScroll = scroll;
      };

      _this.onContentSizeChange = function () {
        _this.mScroll && _this.mScroll.scrollToEnd();
      };

      return _this;
    }

    (0, _createClass2.default)(HeadTurnView, [{
      key: "render",
      value: function render() {
        if (!this.props.viewModel) {
          return null;
        }

        return _react.default.createElement(_reactNative.View, {
          style: styles.rootView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 88,
            columnNumber: 13
          }
        }, _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '抬头',
          onPress: this.props.viewModel.onPressHeadUp,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '低头',
          onPress: this.props.viewModel.onPressHeadDown,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '左转',
          onPress: this.props.viewModel.onPressTurnLeft,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '右转',
          onPress: this.props.viewModel.onPressTurnRight,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 108,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 113,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '停止',
          onPress: this.props.viewModel.onPressStop,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 114,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.SafeAreaView, {
          style: styles.resultArea,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 119,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.ScrollView, {
          ref: this.setScroll,
          onContentSizeChange: this.onContentSizeChange,
          style: styles.resultScroll,
          showsVerticalScrollIndicator: false,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 120,
            columnNumber: 21
          }
        }, _react.default.createElement(_reactNative.Text, {
          style: styles.resultText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 125,
            columnNumber: 25
          }
        }, this.props.viewModel.getResultText()))));
      }
    }]);
    return HeadTurnView;
  }(_react.Component)) || _class;

  exports.HeadTurnView = HeadTurnView;
},"system_2d01160272669884793b18983a46dcd0_app_headTurn_HeadTurnView.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react_index.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","node_modules_mobx-react_native.js"],"app/headTurn/HeadTurnView.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BasicMotionView = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[7], "react-native");

  var _mobxReact = _$$_REQUIRE(_dependencyMap[8], "mobx-react");

  var _class,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/basicMotion/BasicMotionView.tsx";

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var styles = _reactNative.StyleSheet.create({
    rootView: {
      flex: 1,
      backgroundColor: 'white',
      alignItems: 'center',
      width: width,
      height: height
    },
    button: {
      width: '50%',
      marginBottom: 10
    },
    resultArea: {
      flex: 1,
      width: '90%',
      marginBottom: 20,
      borderWidth: 2,
      borderRadius: 10,
      borderColor: 'dodgerblue',
      alignItems: 'center'
    },
    resultScroll: {
      width: '90%',
      height: '100%'
    },
    resultText: {
      fontSize: 12,
      alignSelf: 'center',
      width: '100%',
      height: '100%'
    }
  });

  var BasicMotionView = (0, _mobxReact.observer)(_class = function (_Component) {
    (0, _inherits2.default)(BasicMotionView, _Component);

    var _super = _createSuper(BasicMotionView);

    function BasicMotionView() {
      var _this;

      (0, _classCallCheck2.default)(this, BasicMotionView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.setScroll = function (scroll) {
        _this.mScroll = scroll;
      };

      _this.onContentSizeChange = function () {
        _this.mScroll && _this.mScroll.scrollToEnd();
      };

      return _this;
    }

    (0, _createClass2.default)(BasicMotionView, [{
      key: "render",
      value: function render() {
        if (!this.props.viewModel) {
          return null;
        }

        return _react.default.createElement(_reactNative.View, {
          style: styles.rootView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 88,
            columnNumber: 13
          }
        }, _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '前进',
          onPress: this.props.viewModel.onPressGoForward,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '后退',
          onPress: this.props.viewModel.onPressGoBackward,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '左转',
          onPress: this.props.viewModel.onPressTurnLeft,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '右转',
          onPress: this.props.viewModel.onPressTurnRight,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 108,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 113,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '停止',
          onPress: this.props.viewModel.onPressStop,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 114,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.SafeAreaView, {
          style: styles.resultArea,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 119,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.ScrollView, {
          ref: this.setScroll,
          onContentSizeChange: this.onContentSizeChange,
          style: styles.resultScroll,
          showsVerticalScrollIndicator: false,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 120,
            columnNumber: 21
          }
        }, _react.default.createElement(_reactNative.Text, {
          style: styles.resultText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 125,
            columnNumber: 25
          }
        }, this.props.viewModel.getResultText()))));
      }
    }]);
    return BasicMotionView;
  }(_react.Component)) || _class;

  exports.BasicMotionView = BasicMotionView;
},"system_2d01160272669884793b18983a46dcd0_app_basicMotion_BasicMotionView.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react_index.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","node_modules_mobx-react_native.js"],"app/basicMotion/BasicMotionView.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StandardFaceTrackView = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[7], "react-native");

  var _mobxReact = _$$_REQUIRE(_dependencyMap[8], "mobx-react");

  var _class,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/standardFaceTrack/StandardFaceTrackView.tsx";

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var styles = _reactNative.StyleSheet.create({
    rootView: {
      flex: 1,
      backgroundColor: 'white',
      alignItems: 'center',
      width: width,
      height: height
    },
    button: {
      width: '50%',
      marginBottom: 10
    },
    resultArea: {
      flex: 1,
      width: '90%',
      marginBottom: 20,
      borderWidth: 2,
      borderRadius: 10,
      borderColor: 'dodgerblue',
      alignItems: 'center'
    },
    resultScroll: {
      width: '90%',
      height: '100%'
    },
    resultText: {
      fontSize: 12,
      alignSelf: 'center',
      width: '100%',
      height: '100%'
    }
  });

  var StandardFaceTrackView = (0, _mobxReact.observer)(_class = function (_Component) {
    (0, _inherits2.default)(StandardFaceTrackView, _Component);

    var _super = _createSuper(StandardFaceTrackView);

    function StandardFaceTrackView() {
      var _this;

      (0, _classCallCheck2.default)(this, StandardFaceTrackView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.setScroll = function (scroll) {
        _this.mScroll = scroll;
      };

      _this.onContentSizeChange = function () {
        _this.mScroll && _this.mScroll.scrollToEnd();
      };

      return _this;
    }

    (0, _createClass2.default)(StandardFaceTrackView, [{
      key: "render",
      value: function render() {
        if (!this.props.viewModel) {
          return null;
        }

        return _react.default.createElement(_reactNative.View, {
          style: styles.rootView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 88,
            columnNumber: 13
          }
        }, _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '开始人脸跟随',
          onPress: this.props.viewModel.onPressHeadUp,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '停止人脸跟随',
          onPress: this.props.viewModel.onPressHeadDown,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.SafeAreaView, {
          style: styles.resultArea,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.ScrollView, {
          ref: this.setScroll,
          onContentSizeChange: this.onContentSizeChange,
          style: styles.resultScroll,
          showsVerticalScrollIndicator: false,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102,
            columnNumber: 21
          }
        }, _react.default.createElement(_reactNative.Text, {
          style: styles.resultText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107,
            columnNumber: 25
          }
        }, this.props.viewModel.getResultText()))));
      }
    }]);
    return StandardFaceTrackView;
  }(_react.Component)) || _class;

  exports.StandardFaceTrackView = StandardFaceTrackView;
},"system_2d01160272669884793b18983a46dcd0_app_standardFaceTrack_StandardFaceTrackView.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react_index.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","node_modules_mobx-react_native.js"],"app/standardFaceTrack/StandardFaceTrackView.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ChargeStartView = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[7], "react-native");

  var _mobxReact = _$$_REQUIRE(_dependencyMap[8], "mobx-react");

  var _class,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/chargeStart/ChargeStartView.tsx";

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var styles = _reactNative.StyleSheet.create({
    rootView: {
      flex: 1,
      backgroundColor: 'white',
      alignItems: 'center',
      width: width,
      height: height
    },
    button: {
      width: '50%',
      marginBottom: 10
    },
    resultArea: {
      flex: 1,
      width: '90%',
      marginBottom: 20,
      borderWidth: 2,
      borderRadius: 10,
      borderColor: 'dodgerblue',
      alignItems: 'center'
    },
    resultScroll: {
      width: '90%',
      height: '100%'
    },
    resultText: {
      fontSize: 12,
      alignSelf: 'center',
      width: '100%',
      height: '100%'
    }
  });

  var ChargeStartView = (0, _mobxReact.observer)(_class = function (_Component) {
    (0, _inherits2.default)(ChargeStartView, _Component);

    var _super = _createSuper(ChargeStartView);

    function ChargeStartView() {
      var _this;

      (0, _classCallCheck2.default)(this, ChargeStartView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.setScroll = function (scroll) {
        _this.mScroll = scroll;
      };

      _this.onContentSizeChange = function () {
        _this.mScroll && _this.mScroll.scrollToEnd();
      };

      return _this;
    }

    (0, _createClass2.default)(ChargeStartView, [{
      key: "render",
      value: function render() {
        if (!this.props.viewModel) {
          return null;
        }

        return _react.default.createElement(_reactNative.View, {
          style: styles.rootView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 88,
            columnNumber: 13
          }
        }, _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '开始去充电',
          onPress: this.props.viewModel.onPressStartChargeStart,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '停止去充电',
          onPress: this.props.viewModel.onPressStopChargeStart,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.SafeAreaView, {
          style: styles.resultArea,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.ScrollView, {
          ref: this.setScroll,
          onContentSizeChange: this.onContentSizeChange,
          style: styles.resultScroll,
          showsVerticalScrollIndicator: false,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102,
            columnNumber: 21
          }
        }, _react.default.createElement(_reactNative.Text, {
          style: styles.resultText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107,
            columnNumber: 25
          }
        }, this.props.viewModel.getResultText()))));
      }
    }]);
    return ChargeStartView;
  }(_react.Component)) || _class;

  exports.ChargeStartView = ChargeStartView;
},"system_2d01160272669884793b18983a46dcd0_app_chargeStart_ChargeStartView.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react_index.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","node_modules_mobx-react_native.js"],"app/chargeStart/ChargeStartView.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationView = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[7], "react-native");

  var _mobxReact = _$$_REQUIRE(_dependencyMap[8], "mobx-react");

  var _class,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/navigation/NavigationView.tsx";

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var styles = _reactNative.StyleSheet.create({
    rootView: {
      flex: 1,
      backgroundColor: 'white',
      alignItems: 'center',
      width: width,
      height: height
    },
    button: {
      width: '50%',
      marginBottom: 10
    },
    resultArea: {
      flex: 1,
      width: '90%',
      marginBottom: 20,
      borderWidth: 2,
      borderRadius: 10,
      borderColor: 'dodgerblue',
      alignItems: 'center'
    },
    resultScroll: {
      width: '90%',
      height: '100%'
    },
    resultText: {
      fontSize: 12,
      alignSelf: 'center',
      width: '100%',
      height: '100%'
    }
  });

  var NavigationView = (0, _mobxReact.observer)(_class = function (_Component) {
    (0, _inherits2.default)(NavigationView, _Component);

    var _super = _createSuper(NavigationView);

    function NavigationView() {
      var _this;

      (0, _classCallCheck2.default)(this, NavigationView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.setScroll = function (scroll) {
        _this.mScroll = scroll;
      };

      _this.onContentSizeChange = function () {
        _this.mScroll && _this.mScroll.scrollToEnd();
      };

      return _this;
    }

    (0, _createClass2.default)(NavigationView, [{
      key: "render",
      value: function render() {
        if (!this.props.viewModel) {
          return null;
        }

        return _react.default.createElement(_reactNative.View, {
          style: styles.rootView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 88,
            columnNumber: 13
          }
        }, _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '开始导航',
          onPress: this.props.viewModel.onPressStartNavigationView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '结束导航',
          onPress: this.props.viewModel.onPressStopNavigation,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.SafeAreaView, {
          style: styles.resultArea,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.ScrollView, {
          ref: this.setScroll,
          onContentSizeChange: this.onContentSizeChange,
          style: styles.resultScroll,
          showsVerticalScrollIndicator: false,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102,
            columnNumber: 21
          }
        }, _react.default.createElement(_reactNative.Text, {
          style: styles.resultText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107,
            columnNumber: 25
          }
        }, this.props.viewModel.getResultText()))));
      }
    }]);
    return NavigationView;
  }(_react.Component)) || _class;

  exports.NavigationView = NavigationView;
},"system_2d01160272669884793b18983a46dcd0_app_navigation_NavigationView.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react_index.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","node_modules_mobx-react_native.js"],"app/navigation/NavigationView.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PersonAppearView = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[7], "react-native");

  var _mobxReact = _$$_REQUIRE(_dependencyMap[8], "mobx-react");

  var _class,
      _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/personAppear/PersonAppearView.tsx";

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var styles = _reactNative.StyleSheet.create({
    rootView: {
      flex: 1,
      backgroundColor: 'white',
      alignItems: 'center',
      width: width,
      height: height
    },
    button: {
      width: '50%',
      marginBottom: 10
    },
    resultArea: {
      flex: 1,
      width: '90%',
      marginBottom: 20,
      borderWidth: 2,
      borderRadius: 10,
      borderColor: 'dodgerblue',
      alignItems: 'center'
    },
    resultScroll: {
      width: '90%',
      height: '100%'
    },
    resultText: {
      fontSize: 12,
      alignSelf: 'center',
      width: '100%',
      height: '100%'
    }
  });

  var PersonAppearView = (0, _mobxReact.observer)(_class = function (_Component) {
    (0, _inherits2.default)(PersonAppearView, _Component);

    var _super = _createSuper(PersonAppearView);

    function PersonAppearView() {
      var _this;

      (0, _classCallCheck2.default)(this, PersonAppearView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.setScroll = function (scroll) {
        _this.mScroll = scroll;
      };

      _this.onContentSizeChange = function () {
        _this.mScroll && _this.mScroll.scrollToEnd();
      };

      return _this;
    }

    (0, _createClass2.default)(PersonAppearView, [{
      key: "render",
      value: function render() {
        if (!this.props.viewModel) {
          return null;
        }

        return _react.default.createElement(_reactNative.View, {
          style: styles.rootView,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 88,
            columnNumber: 13
          }
        }, _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 89,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '开始人脸检测',
          onPress: this.props.viewModel.onPressStartPersonAppear,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.View, {
          style: styles.button,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.Button, {
          color: 'dodgerblue',
          title: '停止人脸检测',
          onPress: this.props.viewModel.onPressFinishPersonAppear,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96,
            columnNumber: 21
          }
        })), _react.default.createElement(_reactNative.SafeAreaView, {
          style: styles.resultArea,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101,
            columnNumber: 17
          }
        }, _react.default.createElement(_reactNative.ScrollView, {
          ref: this.setScroll,
          onContentSizeChange: this.onContentSizeChange,
          style: styles.resultScroll,
          showsVerticalScrollIndicator: false,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102,
            columnNumber: 21
          }
        }, _react.default.createElement(_reactNative.Text, {
          style: styles.resultText,
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107,
            columnNumber: 25
          }
        }, this.props.viewModel.getResultText()))));
      }
    }]);
    return PersonAppearView;
  }(_react.Component)) || _class;

  exports.PersonAppearView = PersonAppearView;
},"system_2d01160272669884793b18983a46dcd0_app_personAppear_PersonAppearView.tsx",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","node_modules_react_index.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","node_modules_mobx-react_native.js"],"app/personAppear/PersonAppearView.tsx");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
	"name": "shadow_opk_for_android",
	"version": "0.0.23",
	"appid": "system_2d01160272669884793b18983a46dcd0",
	"private": true,
	"commitId": "",
	"opkType": "plugin",
	"scripts": {
		"run": "orionos-sh run",
		"pack": "orionos-sh pack"
	},
	"dependencies": {
		"@types/react-native-snap-carousel": "^3.7.4",
		"eslint-plugin-orion-os": "^0.8.0",
		"orionos-eve-core": "2.8.0",
		"react-native-snap-carousel": "^3.8.0",
		"rn-viewpager": "^1.2.9"
	},
	"devDependencies": {
		"@babel/core": "7.4.5",
		"@babel/plugin-proposal-class-properties": "7.4.4",
		"@babel/plugin-proposal-decorators": "7.4.4",
		"@babel/preset-env": "7.4.5",
		"@babel/preset-react": "7.0.0",
		"@babel/runtime": "7.4.5",
		"@types/jest": "24.0.13",
		"@types/react": "16.8.21",
		"@types/react-native": "0.57.65",
		"@types/react-test-renderer": "16.8.1",
		"babel-eslint": "10.0.1",
		"babel-jest": "24.8.0",
		"eslint": "5.16.0",
		"eslint-config-koot": "0.1.0",
		"jest": "24.8.0",
		"jsc-android": "236355.1.1",
		"lint-staged": "8.1.6",
		"metro-react-native-babel-preset": "0.66.0",
		"prettier": "1.17.0",
		"react-native-typescript-transformer": "1.2.12",
		"react-test-renderer": "16.8.3",
		"ts-jest": "24.0.0",
		"typescript": "3.9.9"
	},
	"jest": {
		"jest": {
			"preset": "react-native",
			"moduleFileExtensions": [
				"ts",
				"tsx",
				"js"
			],
			"transform": {
				"^.+\\.(js)$": "<rootDir>/node_modules/babel-jest",
				"\\.(ts|tsx)$": "<rootDir>/node_modules/ts-jest/preprocessor.js"
			},
			"testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
			"testPathIgnorePatterns": [
				"\\.snap$",
				"<rootDir>/node_modules/"
			],
			"cacheDirectory": ".jest/cache"
		}
	},
	"husky": {
		"hooks": {
			"pre-commit": "lint-staged"
		}
	},
	"lint-staged": {
		"*.{js,jsx,ts,tsx,cjs,mjs}": [
			"eslint --fix",
			"prettier --write",
			"git add"
		],
		"*.{json,md,css,less,sass,scss}": [
			"prettier --write",
			"git add"
		]
	}
}
;
},"system_2d01160272669884793b18983a46dcd0_package.json",[],"package.json");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "name": "Eve",
  "displayName": "Eve"
}
;
},"system_2d01160272669884793b18983a46dcd0_app.json",[],"app.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _get2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/get"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf"));

  var _orionosEveCore = _$$_REQUIRE(_dependencyMap[7], "orionos-eve-core");

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[9], "react-native");

  var _HeadTurnScreen = _$$_REQUIRE(_dependencyMap[10], "./demo/HeadTurnScreen");

  var _jsxFileName = "/Applications/htdoc/shadow_opk_for_android/app/AppDebug.js";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AppDebug = function (_BaseComponent) {
    (0, _inherits2.default)(AppDebug, _BaseComponent);

    var _super = _createSuper(AppDebug);

    function AppDebug(props) {
      var _this;

      (0, _classCallCheck2.default)(this, AppDebug);
      _this = _super.call(this, props);

      _orionosEveCore.listenersManager.listen(_reactNative.DeviceEventEmitter);

      _orionosEveCore.triggerManager.start();

      return _this;
    }

    (0, _createClass2.default)(AppDebug, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(AppDebug.prototype), "componentDidMount", this).call(this);
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {}
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(AppDebug.prototype), "componentWillUnmount", this).call(this);
      }
    }, {
      key: "render",
      value: function render() {
        return _react.default.createElement(_HeadTurnScreen.HeadTurnScreen, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 31,
            columnNumber: 17
          }
        });
      }
    }]);
    return AppDebug;
  }(_orionosEveCore.BaseComponent);

  exports.default = AppDebug;
},"system_2d01160272669884793b18983a46dcd0_app_AppDebug.js",["node_modules_@babel_runtime_helpers_interopRequireDefault.js","node_modules_@babel_runtime_helpers_classCallCheck.js","node_modules_@babel_runtime_helpers_createClass.js","node_modules_@babel_runtime_helpers_get.js","node_modules_@babel_runtime_helpers_inherits.js","node_modules_@babel_runtime_helpers_possibleConstructorReturn.js","node_modules_@babel_runtime_helpers_getPrototypeOf.js","system_2d01160272669884793b18983a46dcd0_node_modules_orionos-eve-core_index.ts","node_modules_react_index.js","node_modules_react-native_Libraries_react-native_react-native-implementation.js","system_2d01160272669884793b18983a46dcd0_app_demo_HeadTurnScreen.tsx"],"app/AppDebug.js");
__r("node_modules_react-native_Libraries_Core_InitializeCore.js");
__r("system_2d01160272669884793b18983a46dcd0_index.js");
//# sourceMappingURL=source.map